{
"version":3,
"file":"script.js",
"sourceRoot":"file://",
"sources":["/usr/lib/haxe/std/js/_std/EReg.hx","/usr/lib/haxe/std/js/_std/HxOverrides.hx","/usr/lib/haxe/std/Lambda.hx","/usr/lib/haxe/std/List.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/Main.hx","/usr/lib/haxe/std/js/_std/Reflect.hx","/usr/lib/haxe/std/js/_std/Std.hx","/usr/lib/haxe/std/StringBuf.hx","/usr/lib/haxe/std/StringTools.hx","/usr/lib/haxe/std/js/_std/Type.hx","/usr/lib/haxe/std/js/_std/Xml.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/AABB.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/AABBTree.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/Array2D.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/DLL.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/Grid2D.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/IDManager.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/aabbtree/DebugRenderer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/aabbtree/InsertStrategyPerimeter.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/aabbtree/Node.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/ds/aabbtree/NodePool.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/core/ClassMap.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/core/Component.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/core/Engine.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/core/Entity.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/core/System.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/signals/ListenerNode.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/signals/ListenerNodePool.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/signals/SignalBase.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/signals/Signal0.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/signals/SignalMacro.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/signals/Signal2.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/systems/EntityUpdater.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/GameLoop.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Behavior.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Action.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Composite.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Selector.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/ActiveSelector.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/BehaviorContext.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/BehaviorTree.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Decorator.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Parallel.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Repeat.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/Sequence.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/actions/Delay.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/behaviors/actions/GetLocalEntities.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/steering/SteeringBehavior.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/steering/behaviours/Behavior.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Vector2D.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/steering/behaviours/Seek.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/CameraController.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/eco/core/ComponentBuilder.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Controls.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Display.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Lifecycle.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/ParticleEmitters.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Physics.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Position.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Script.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/components/Steering.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/core/BaseGame.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ds/EntityCollection.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ds/EntityCollectionItem.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/graphics/StaticLayerDisplayManager.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/input/DigitalInput.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxLayer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxMap.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxObject.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxObjectGroup.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxOrderedHash.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxPropertySet.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/map/tmx/TmxTileSet.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/systems/InputSystem.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/systems/ParticleSystem.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/systems/PhysicsSystem.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/systems/RenderSystem.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/view/View.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/game/exile/Exile.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/game/exile/components/GunTurret.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/game/exile/components/Player.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/game/exile/components/ProjectileA.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/game/exile/entities/EntityFactory.hx","/usr/lib/haxe/std/js/_std/haxe/ds/IntMap.hx","/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx","/usr/lib/haxe/std/haxe/xml/Fast.hx","/usr/lib/haxe/std/haxe/xml/Parser.hx","/usr/lib/haxe/std/js/Boot.hx","/usr/lib/haxe/std/js/Lib.hx","/usr/lib/haxe/std/js/html/CanvasElement.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/PhysicsEngine.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/collision/broadphase/managedgrid/Cell.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/collision/broadphase/managedgrid/ManagedGrid.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/collision/narrowphase/sat/SAT.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/constraints/Constraint.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/Arbiter.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/Body.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/BodyContact.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/BodyContactManager.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/Contact.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/Feature.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/dynamics/Material.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/AABB.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Axis.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/GeometricShape.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Circle.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Polygon.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Ray.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Segment.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/VertexList.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/utils/EventTarget.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/utils/AssetLoader.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/utils/Base64.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/utils/Maths.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/utils/Random.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/display/DisplayObject.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/display/DisplayObjectContainer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/display/Camera.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/display/Sprite.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/display/Stage.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/geom/AABB.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/geom/Matrix3.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/geom/Matrix4.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/geom/Point.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/geom/Rectangle.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/particle/BlockSpriteParticle.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/particle/BlockSpriteParticleEngine.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/particle/PointSpriteParticle.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/particle/PointSpriteParticleEngine.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/particle/emitter/Explosion.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/particle/emitter/RandomSpray.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/canvas/CanvasDebugView.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/PointSpriteLightMapRenderer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/PointSpriteRenderer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/ShaderWrapper.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/SpriteRenderer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/TileLayer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/TileMap.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/WebGLBatch.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/WebGLRenderer.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/renderers/webgl/WebGLShaders.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/texture/BaseTexture.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/texture/Texture.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/wgr/texture/TextureManager.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/World.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/WorldData.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/WorldPhysicsEngine.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/tiles/TileSegment.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/tiles/Tile.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/tiles/TileFactory.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/worldEngine/tiles/TileFeature.hx","/usr/lib/haxe/std/Math.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/engine/ai/steering/SteeringSettings.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/Constants.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/physics/geometry/Shapes.hx","/Users/richard.jewson/Workspace/webgl/webglEngine/src/utils/Limits.hx"],
"sourcesContent":["/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class EReg {\n\n\tvar r : Dynamic;\n\n\tpublic function new( r : String, opt : String ) : Void {\n\t\topt = opt.split(\"u\").join(\"\"); // 'u' (utf8) depends on page encoding\n\t\tthis.r = untyped __new__(\"RegExp\",r,opt);\n\t}\n\n\tpublic function match( s : String ) : Bool {\n\t\tif( r.global ) r.lastIndex = 0;\n\t\tr.m = r.exec(s);\n\t\tr.s = s;\n\t\treturn (r.m != null);\n\t}\n\n\tpublic function matched( n : Int ) : String {\n\t\treturn if( r.m != null && n >= 0 && n < r.m.length ) r.m[n] else throw \"EReg::matched\";\n\t}\n\n\tpublic function matchedLeft() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn r.s.substr(0,r.m.index);\n\t}\n\n\tpublic function matchedRight() : String {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\tvar sz = r.m.index+r.m[0].length;\n\t\treturn r.s.substr(sz,r.s.length-sz);\n\t}\n\n\tpublic function matchedPos() : { pos : Int, len : Int } {\n\t\tif( r.m == null ) throw \"No string matched\";\n\t\treturn { pos : r.m.index, len : r.m[0].length };\n\t}\n\n\tpublic function matchSub( s : String, pos : Int, len : Int = -1):Bool {\n\t\treturn if (r.global) {\n\t\t\tr.lastIndex = pos;\n\t\t\tr.m = r.exec(len < 0 ? s : s.substr(0, pos + len));\n\t\t\tvar b = r.m != null;\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t}\n\t\t\tb;\n\t\t} else {\n\t\t\t// TODO: check some ^/$ related corner cases\n\t\t\tvar b = match( len < 0 ? s.substr(pos) : s.substr(pos,len) );\n\t\t\tif (b) {\n\t\t\t\tr.s = s;\n\t\t\t\tr.m.index += pos;\n\t\t\t}\n\t\t\tb;\n\t\t}\n\t}\n\n\tpublic function split( s : String ) : Array<String> {\n\t\t// we can't use directly s.split because it's ignoring the 'g' flag\n\t\tvar d = \"#__delim__#\";\n\t\treturn untyped s.replace(r,d).split(d);\n\t}\n\n\tpublic function replace( s : String, by : String ) : String {\n\t\treturn untyped s.replace(r,by);\n\t}\n\n\tpublic function map( s : String, f : EReg -> String ) : String {\n\t\tvar offset = 0;\n\t\tvar buf = new StringBuf();\n\t\tdo {\n\t\t\tif (offset >= s.length)\n\t\t\t\tbreak;\n\t\t\telse if (!matchSub(s, offset)) {\n\t\t\t\tbuf.add(s.substr(offset));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar p = matchedPos();\n\t\t\tbuf.add(s.substr(offset, p.pos - offset));\n\t\t\tbuf.add(f(this));\n\t\t\tif (p.len == 0) {\n\t\t\t\tbuf.add(s.substr(p.pos, 1));\n\t\t\t\toffset = p.pos + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\toffset = p.pos + p.len;\n\t\t} while (r.global);\n\t\tif (!r.global && offset > 0 && offset < s.length)\n\t\t\tbuf.add(s.substr(offset));\n\t\treturn buf.toString();\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:noDoc\nclass HxOverrides {\n\n\tstatic function dateStr( date :Date ) : String {\n\t\tvar m = date.getMonth() + 1;\n\t\tvar d = date.getDate();\n\t\tvar h = date.getHours();\n\t\tvar mi = date.getMinutes();\n\t\tvar s = date.getSeconds();\n\t\treturn date.getFullYear()\n\t\t\t+\"-\"+(if( m < 10 ) \"0\"+m else \"\"+m)\n\t\t\t+\"-\"+(if( d < 10 ) \"0\"+d else \"\"+d)\n\t\t\t+\" \"+(if( h < 10 ) \"0\"+h else \"\"+h)\n\t\t\t+\":\"+(if( mi < 10 ) \"0\"+mi else \"\"+mi)\n\t\t\t+\":\"+(if( s < 10 ) \"0\"+s else \"\"+s);\n\t}\n\n\tstatic function strDate( s : String ) : Date {\n\t\tswitch( s.length ) {\n\t\tcase 8: // hh:mm:ss\n\t\t\tvar k = s.split(\":\");\n\t\t\tvar d : Date = untyped __new__(Date);\n\t\t\tuntyped d[\"setTime\"](0);\n\t\t\tuntyped d[\"setUTCHours\"](k[0]);\n\t\t\tuntyped d[\"setUTCMinutes\"](k[1]);\n\t\t\tuntyped d[\"setUTCSeconds\"](k[2]);\n\t\t\treturn d;\n\t\tcase 10: // YYYY-MM-DD\n\t\t\tvar k = s.split(\"-\");\n\t\t\treturn new Date(cast k[0],cast untyped k[1] - 1,cast k[2],0,0,0);\n\t\tcase 19: // YYYY-MM-DD hh:mm:ss\n\t\t\tvar k = s.split(\" \");\n\t\t\tvar y = k[0].split(\"-\");\n\t\t\tvar t = k[1].split(\":\");\n\t\t\treturn new Date(cast y[0],cast untyped y[1] - 1,cast y[2],cast t[0],cast t[1],cast t[2]);\n\t\tdefault:\n\t\t\tthrow \"Invalid date format : \" + s;\n\t\t}\n\t}\n\n\tstatic function cca( s : String, index : Int ) : Null<Int> {\n\t\t#if mt\n\t\tvar x = (cast s).cca(index);\n\t\t#else\n\t\tvar x = (cast s).charCodeAt(index);\n\t\t#end\n\t\tif( x != x ) // fast isNaN\n\t\t\treturn untyped undefined; // isNaN will still return true\n\t\treturn x;\n\t}\n\n\tstatic function substr( s : String, pos : Int, ?len : Int ) : String {\n\t\tif( pos != null && pos != 0 && len != null && len < 0 ) return \"\";\n\t\tif( len == null ) len = s.length;\n\t\tif( pos < 0 ){\n\t\t\tpos = s.length + pos;\n\t\t\tif( pos < 0 ) pos = 0;\n\t\t}else if( len < 0 ){\n\t\t\tlen = s.length + len - pos;\n\t\t}\n\n\t\treturn (untyped s).substr(pos, len);\n\t}\n\n\tstatic function indexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i < 0) {\n\t\t\ti += len;\n\t\t\tif (i < 0) i = 0;\n\t\t}\n\t\twhile (i < len)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function lastIndexOf<T>( a : Array<T>, obj : T, i : Int) {\n\t\tvar len = a.length;\n\t\tif (i >= len)\n\t\t\ti = len - 1;\n\t\telse if (i < 0)\n\t\t\ti += len;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tif (untyped __js__(\"a[i] === obj\"))\n\t\t\t\treturn i;\n\t\t\ti--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic function remove<T>( a : Array<T>, obj : T ) {\n\t\tvar i = a.indexOf(obj);\n\t\tif( i == -1 ) return false;\n\t\ta.splice(i,1);\n\t\treturn true;\n\t}\n\n\tstatic function iter<T>( a : Array<T> ) : Iterator<T> untyped {\n\t\treturn {\n\t\t\tcur : 0,\n\t\t\tarr : a,\n\t\t\thasNext : function() {\n\t\t\t\treturn __this__.cur < __this__.arr.length;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\treturn __this__.arr[__this__.cur++];\n\t\t\t}\n\t\t};\n\t}\n\n\tstatic function __init__() untyped {\n#if !js_es5\n\t\t__feature__('HxOverrides.indexOf', if( Array.prototype.indexOf ) __js__(\"HxOverrides\").indexOf = function(a,o,i) return Array.prototype.indexOf.call(a, o, i));\n\t\t__feature__('HxOverrides.lastIndexOf', if( Array.prototype.lastIndexOf ) __js__(\"HxOverrides\").lastIndexOf = function(a,o,i) return Array.prototype.lastIndexOf.call(a, o, i));\n#end\n\n#if mt\n\t\tif( String.prototype.cca == null ) String.prototype.cca = String.prototype.charCodeAt;\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n/**\n\tThe `Lambda` class is a collection of methods to support functional\n\tprogramming. It is ideally used with 'using Lambda' and then acts as an\n\textension to Iterable types.\n\n\tOn static platforms, working with the Iterable structure might be slower\n\tthan performing the operations directly on known types, such as Array and\n\tList.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\nclass Lambda {\n\n\t/**\n\t\tCreates an Array from Iterable `it`.\n\n\t\tIf `it` is an Array, this function returns a copy of it.\n\t**/\n\tpublic static function array<A>( it : Iterable<A> ) : Array<A> {\n\t\tvar a = new Array<A>();\n\t\tfor(i in it)\n\t\t\ta.push(i);\n\t\treturn a;\n\t}\n\n\t/**\n\t\tCreates a List form Iterable `it`.\n\n\t\tIf `it` is a List, this function returns a copy of it.\n\t**/\n\tpublic static function list<A>( it : Iterable<A> ) : List<A> {\n\t\tvar l = new List<A>();\n\t\tfor(i in it)\n\t\t\tl.add(i);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tCreates a new List by applying function `f` to all elements of `it`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function map<A,B>( it : Iterable<A>, f : A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tfor( x in it )\n\t\t\tl.add(f(x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tSimilar to map, but also passes the index of each element to `f`.\n\n\t\tThe order of elements is preserved.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function mapi<A,B>( it : Iterable<A>, f : Int -> A -> B ) : List<B> {\n\t\tvar l = new List<B>();\n\t\tvar i = 0;\n\t\tfor( x in it )\n\t\t\tl.add(f(i++,x));\n\t\treturn l;\n\t}\n\n\t/**\n\t\tTells if `it` contains `elt`.\n\n\t\tThis function returns true as soon as an element is found which is equal\n\t\tto `elt` according to the `==` operator.\n\n\t\tIf no such element is found, the result is false.\n\t**/\n\tpublic static function has<A>( it : Iterable<A>, elt : A ) : Bool {\n\t\tfor( x in it )\n\t\t\tif( x == elt )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `it` contains an element for which `f` is true.\n\n\t\tThis function returns true as soon as an element is found for which a\n\t\tcall to `f` returns true.\n\n\t\tIf no such element is found, the result is false.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function exists<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t\tTells if `f` is true for all elements of `it`.\n\n\t\tThis function returns false as soon as an element is found for which a\n\t\tcall to `f` returns false.\n\n\t\tIf no such element is found, the result is true.\n\n\t\tIn particular, this function always returns true if `it` is empty.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function foreach<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tfor( x in it )\n\t\t\tif( !f(x) )\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t\tCalls `f` on all elements of `it`, in order.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function iter<A>( it : Iterable<A>, f : A -> Void ) {\n\t\tfor( x in it )\n\t\t\tf(x);\n\t}\n\n\t/**\n\t\tReturns a List containing those elements of `it` for which `f` returned\n\t\ttrue.\n\n\t\tIf `it` is empty, the result is the empty List even if `f` is null.\n\n\t\tOtherwise if `f` is null, the result is unspecified.\n\t**/\n\tpublic static function filter<A>( it : Iterable<A>, f : A -> Bool ) {\n\t\tvar l = new List<A>();\n\t\tfor( x in it )\n\t\t\tif( f(x) )\n\t\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n\t/**\n\t\tFunctional fold on Iterable `it`, using function `f` with start argument\n\t\t`first`.\n\n\t\tIf `it` has no elements, the result is `first`.\n\n\t\tOtherwise the first element of `it` is passed to `f` alongside `first`.\n\t\tThe result of that call is then passed to `f` with the next element of\n\t\t`it`, and so on until `it` has no more elements.\n\n\t\tIf `it` or `f` are null, the result is unspecified.\n\t**/\n\tpublic static function fold<A,B>( it : Iterable<A>, f : A -> B -> B, first : B ) : B {\n\t\tfor( x in it )\n\t\t\tfirst = f(x,first);\n\t\treturn first;\n\t}\n\n\t/**\n\t\tReturns the number of elements in `it` for which `pred` is true, or the\n\t\ttotal number of elements in `it` if `pred` is null.\n\n\t\tThis function traverses all elements.\n\t**/\n\tpublic static function count<A>( it : Iterable<A>, ?pred : A -> Bool ) {\n\t\tvar n = 0;\n\t\tif( pred == null )\n\t\t\tfor( _ in it )\n\t\t\t\tn++;\n\t\telse\n\t\t\tfor( x in it )\n\t\t\t\tif( pred(x) )\n\t\t\t\t\tn++;\n\t\treturn n;\n\t}\n\n\t/**\n\t\tTells if Iterable `it` does not contain any element.\n\t**/\n\tpublic static function empty<T>( it : Iterable<T> ) : Bool {\n\t\treturn !it.iterator().hasNext();\n\t}\n\n\t/**\n\t\tReturns the index of the first element `v` within Iterable `it`.\n\n\t\tThis function uses operator `==` to check for equality.\n\n\t\tIf `v` does not exist in `it`, the result is -1.\n\t**/\n\tpublic static function indexOf<T>( it : Iterable<T>, v : T ) : Int {\n\t\tvar i = 0;\n\t\tfor( v2 in it ) {\n\t\t\tif( v == v2 )\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t\tReturns the first element of `it` for which `f` is true.\n\n\t\tThis function returns as soon as an element is found for which a call to\n\t\t`f` returns true.\n\n\t\tIf no such element is found, the result is null.\n\n\t\tIf `f` is null, the result is unspecified.\n\t**/\n\tpublic static function find<T>( it : Iterable<T>, f : T -> Bool ) : Null<T> {\n\t\tfor( v in it ) {\n\t\t\tif(f(v)) return v;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t\tReturns a new List containing all elements of Iterable `a` followed by\n\t\tall elements of Iterable `b`.\n\n\t\tIf `a` or `b` are null, the result is unspecified.\n\t**/\n\tpublic static function concat<T>( a : Iterable<T>, b : Iterable<T> ) : List<T> {\n\t\tvar l = new List();\n\t\tfor( x in a )\n\t\t\tl.add(x);\n\t\tfor( x in b )\n\t\t\tl.add(x);\n\t\treturn l;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA linked-list of elements. The list is composed of two-elements arrays\n\tthat are chained together. It is optimized so that adding or removing an\n\telement does not imply copying the whole array content every time.\n**/\nclass List<T> {\n\n\tprivate var h : Array<Dynamic>;\n\tprivate var q : Array<Dynamic>;\n\n\t/**\n\t\tThe length of `this` List.\n\t**/\n\tpublic var length(default,null) : Int;\n\n\t/**\n\t\tCreates a new empty list.\n\t**/\n\tpublic function new() {\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tAdds element `item` at the end of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function add( item : T ) {\n\t\tvar x:Array<Dynamic> = #if neko untyped __dollar__array(item,null) #else [item] #end;\n\t\tif( h == null )\n\t\t\th = x;\n\t\telse\n\t\t\tq[1] = x;\n\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tAdds element `item` at the beginning of `this` List.\n\n\t\t`this.length` increases by 1.\n\t**/\n\tpublic function push( item : T ) {\n\t\tvar x : Array<Dynamic> = #if neko\n\t\t\tuntyped __dollar__array(item,h)\n\t\t#else\n\t\t\t[item,h]\n\t\t#end;\n\t\th = x;\n\t\tif( q == null )\n\t\t\tq = x;\n\t\tlength++;\n\t}\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function first() : Null<T> {\n\t\treturn if( h == null ) null else h[0];\n\t}\n\n\t/**\n\t\tReturns the last element of `this` List, or null if no elements exist.\n\n\t\tThis function does not modify `this` List.\n\t**/\n\tpublic function last() : Null<T> {\n\t\treturn if( q == null ) null else q[0];\n\t}\n\n\n\t/**\n\t\tReturns the first element of `this` List, or null if no elements exist.\n\n\t\tThe element is removed from `this` List.\n\t**/\n\tpublic function pop() : Null<T> {\n\t\tif( h == null )\n\t\t\treturn null;\n\t\tvar x = h[0];\n\t\th = h[1];\n\t\tif( h == null )\n\t\t\tq = null;\n\t\tlength--;\n\t\treturn x;\n\t}\n\n\t/**\n\t\tTells if `this` List is empty.\n\t**/\n\tpublic function isEmpty() : Bool {\n\t\treturn (h == null);\n\t}\n\n\t/**\n\t\tEmpties `this` List.\n\n\t\tThis function does not traverse the elements, but simply sets the\n\t\tinternal references to null and `this.length` to 0.\n\t**/\n\tpublic function clear() : Void {\n\t\th = null;\n\t\tq = null;\n\t\tlength = 0;\n\t}\n\n\t/**\n\t\tRemoves the first occurence of `v` in `this` List.\n\n\t\tIf `v` is found by checking standard equality, it is removed from `this`\n\t\tList and the function returns true.\n\n\t\tOtherwise, false is returned.\n\t**/\n\tpublic function remove( v : T ) : Bool {\n\t\tvar prev = null;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( l[0] == v ) {\n\t\t\t\tif( prev == null )\n\t\t\t\t\th = l[1];\n\t\t\t\telse\n\t\t\t\t\tprev[1] = l[1];\n\t\t\t\tif( q == l )\n\t\t\t\t\tq = prev;\n\t\t\t\tlength--;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprev = l;\n\t\t\tl = l[1];\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t\tReturns an iterator on the elements of the list.\n\t**/\n\tpublic function iterator() : Iterator<T> {\n\t\t#if (java || cs)\n\t\tvar h = h;\n\t\treturn cast {\n\t\t\thasNext : function() {\n\t\t\t\treturn (h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\t{\n\t\t\t\t\tif( h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = h[0];\n\t\t\t\t\th = h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#else\n\t\treturn cast {\n\t\t\th : h,\n\t\t\thasNext : function() {\n\t\t\t\treturn untyped (__this__.h != null);\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\tuntyped {\n\t\t\t\t\tif( __this__.h == null )\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tvar x = __this__.h[0];\n\t\t\t\t\t__this__.h = __this__.h[1];\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List.\n\n\t\tThe result is enclosed in { } with the individual elements being\n\t\tseparated by a comma.\n\t**/\n\tpublic function toString() {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\ts.add(\"{\");\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(\", \");\n\t\t\ts.add(Std.string(l[0]));\n\t\t\tl = l[1];\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a string representation of `this` List, with `sep` separating\n\t\teach element.\n\t**/\n\tpublic function join(sep : String) {\n\t\tvar s = new StringBuf();\n\t\tvar first = true;\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tif( first )\n\t\t\t\tfirst = false;\n\t\t\telse\n\t\t\t\ts.add(sep);\n\t\t\ts.add(l[0]);\n\t\t\tl = l[1];\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t\tReturns a list filtered with `f`. The returned list will contain all\n\t\telements for which `f(x) == true`.\n\t**/\n\tpublic function filter( f : T -> Bool ) {\n\t\tvar l2 = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tif( f(v) )\n\t\t\t\tl2.add(v);\n\t\t}\n\t\treturn l2;\n\t}\n\n\t/**\n\t\tReturns a new list where all elements have been converted by the\n\t\tfunction `f`.\n\t**/\n\tpublic function map<X>(f : T -> X) : List<X> {\n\t\tvar b = new List();\n\t\tvar l = h;\n\t\twhile( l != null ) {\n\t\t\tvar v = l[0];\n\t\t\tl = l[1];\n\t\t\tb.add(f(v));\n\t\t}\n\t\treturn b;\n\t}\n\n}\n","package ;\n\nimport js.Browser;\n\nclass Main \n{\n\n\tpublic static function main() {\n        var exile = new game.exile.Exile();\n\n        Browser.document.getElementById(\"stopbutton\").addEventListener(\"click\",function(event){\n            exile.gameLoop.stop();\n        });\n        Browser.document.getElementById(\"startbutton\").addEventListener(\"click\",function(event){\n            exile.gameLoop.start();\n        });\n        Browser.document.getElementById(\"debugbutton\").addEventListener(\"click\",function(event){\n        });\n        Browser.document.getElementById(\"action1\").addEventListener(\"click\",function(event){\n        });\n        Browser.document.getElementById(\"action2\").addEventListener(\"click\",function(event){\n        });        \n    }\t\n    \n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n@:coreApi class Reflect {\n\n\tpublic inline static function hasField( o : Dynamic, field : String ) : Bool {\n\t\treturn untyped __js__('Object').prototype.hasOwnProperty.call(o, field);\n\t}\n\n\tpublic static function field( o : Dynamic, field : String ) : Dynamic untyped {\n\t\treturn try o[field] catch( e : Dynamic ) null;\n\t}\n\n\tpublic inline static function setField( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\to[field] = value;\n\t}\n\n\tpublic static inline function getProperty( o : Dynamic, field : String ) : Dynamic untyped {\n\t\tvar tmp;\n\t\treturn if( o == null ) __define_feature__(\"Reflect.getProperty\",null) else if( o.__properties__ && (tmp=o.__properties__[\"get_\"+field]) ) o[tmp]() else o[field];\n\t}\n\n\tpublic static inline function setProperty( o : Dynamic, field : String, value : Dynamic ) : Void untyped {\n\t\tvar tmp;\n\t\tif( o.__properties__ && (tmp=o.__properties__[\"set_\"+field]) ) o[tmp](value) else o[field] = __define_feature__(\"Reflect.setProperty\",value);\n\t}\n\n\tpublic inline static function callMethod( o : Dynamic, func : Dynamic, args : Array<Dynamic> ) : Dynamic untyped {\n\t\treturn func.apply(o,args);\n\t}\n\n\tpublic static function fields( o : Dynamic ) : Array<String> {\n\t\tvar a = [];\n\t\tif (o != null) untyped {\n\t\t\tvar hasOwnProperty = __js__('Object').prototype.hasOwnProperty;\n\t\t\t__js__(\"for( var f in o ) {\");\n\t\t\tif( f != \"__id__\" && f != \"hx__closures__\" && hasOwnProperty.call(o, f) ) a.push(f);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic static function isFunction( f : Dynamic ) : Bool untyped {\n\t\treturn __js__(\"typeof(f)\") == \"function\" && !(js.Boot.isClass(f) || js.Boot.isEnum(f));\n\t}\n\n\tpublic static function compare<T>( a : T, b : T ) : Int {\n\t\treturn ( a == b ) ? 0 : (((cast a) > (cast b)) ? 1 : -1);\n\t}\n\n\tpublic static function compareMethods( f1 : Dynamic, f2 : Dynamic ) : Bool {\n\t\tif( f1 == f2 )\n\t\t\treturn true;\n\t\tif( !isFunction(f1) || !isFunction(f2) )\n\t\t\treturn false;\n\t\treturn f1.scope == f2.scope && f1.method == f2.method && f1.method != null;\n\t}\n\n\tpublic static function isObject( v : Dynamic ) : Bool untyped {\n\t\tif( v == null )\n\t\t\treturn false;\n\t\tvar t = __js__(\"typeof(v)\");\n\t\treturn (t == \"string\" || (t == \"object\" && v.__enum__ == null)) || (t == \"function\" && (js.Boot.isClass(v) || js.Boot.isEnum(v)) != null);\n\t}\n\n\tpublic static function isEnumValue( v : Dynamic ) : Bool {\n\t\treturn v != null && v.__enum__ != null;\n\t}\n\n\tpublic static function deleteField( o : Dynamic, field : String ) : Bool untyped {\n\t\tif( !hasField(o,field) ) return false;\n\t\t__js__(\"delete\")(o[field]);\n\t\treturn true;\n\t}\n\n\tpublic static function copy<T>( o : T ) : T {\n\t\tvar o2 : Dynamic = {};\n\t\tfor( f in Reflect.fields(o) )\n\t\t\tReflect.setField(o2,f,Reflect.field(o,f));\n\t\treturn o2;\n\t}\n\n\t@:overload(function( f : Array<Dynamic> -> Void ) : Dynamic {})\n\tpublic static function makeVarArgs( f : Array<Dynamic> -> Dynamic ) : Dynamic {\n\t\treturn function() {\n\t\t\tvar a = untyped Array.prototype.slice.call(__js__(\"arguments\"));\n\t\t\treturn f(a);\n\t\t};\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nimport js.Boot;\n\n@:keepInit\n@:coreApi class Std {\n\n\tpublic static inline function is( v : Dynamic, t : Dynamic ) : Bool {\n\t\treturn untyped js.Boot.__instanceof(v,t);\n\t}\n\n\tpublic static inline function instance<T:{},S:T>( value : T, c : Class<S> ) : S {\n\t\treturn untyped __instanceof__(value, c) ? cast value : null;\n\t}\n\n\tpublic static function string( s : Dynamic ) : String {\n\t\treturn untyped js.Boot.__string_rec(s,\"\");\n\t}\n\n\tpublic static inline function int( x : Float ) : Int {\n\t\treturn cast(x) | 0;\n\t}\n\n\tpublic static function parseInt( x : String ) : Null<Int> {\n\t\tvar v = untyped __js__(\"parseInt\")(x, 10);\n\t\t// parse again if hexadecimal\n\t\tif( v == 0 && (x.charCodeAt(1) == 'x'.code || x.charCodeAt(1) == 'X'.code) )\n\t\t\tv = untyped __js__(\"parseInt\")(x);\n\t\tif( untyped __js__(\"isNaN\")(v) )\n\t\t\treturn null;\n\t\treturn cast v;\n\t}\n\n\tpublic static function parseFloat( x : String ) : Float {\n\t\treturn untyped __js__(\"parseFloat\")(x);\n\t}\n\n\tpublic static function random( x : Int ) : Int {\n\t\treturn untyped x <= 0 ? 0 : Math.floor(Math.random()*x);\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\t__feature__(\"js.Boot.getClass\",String.prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"String\"] = String,String));\n\t\t__feature__(\"js.Boot.isClass\",String.__name__ = __feature__(\"Type.getClassName\",[\"String\"],true));\n\t\t__feature__(\"Type.resolveClass\",$hxClasses[\"Array\"] = Array);\n\t\t__feature__(\"js.Boot.isClass\",Array.__name__ = __feature__(\"Type.getClassName\",[\"Array\"],true));\n\t\t__feature__(\"Date.*\", {\n\t\t\t__feature__(\"js.Boot.getClass\",__js__('Date').prototype.__class__ = __feature__(\"Type.resolveClass\",$hxClasses[\"Date\"] = __js__('Date'),__js__('Date')));\n\t\t\t__feature__(\"js.Boot.isClass\",__js__('Date').__name__ = [\"Date\"]);\n\t\t});\n\t\t__feature__(\"Int.*\",{\n\t\t\tvar Int = __feature__(\"Type.resolveClass\", $hxClasses[\"Int\"] = { __name__ : [\"Int\"] }, { __name__ : [\"Int\"] });\n\t\t});\n\t\t__feature__(\"Dynamic.*\",{\n\t\t\tvar Dynamic = __feature__(\"Type.resolveClass\", $hxClasses[\"Dynamic\"] = { __name__ : [\"Dynamic\"] }, { __name__ : [\"Dynamic\"] });\n\t\t});\n\t\t__feature__(\"Float.*\",{\n\t\t\tvar Float = __feature__(\"Type.resolveClass\", $hxClasses[\"Float\"] = __js__(\"Number\"), __js__(\"Number\"));\n\t\t\tFloat.__name__ = [\"Float\"];\n\t\t});\n\t\t__feature__(\"Bool.*\",{\n\t\t\tvar Bool = __feature__(\"Type.resolveEnum\",$hxClasses[\"Bool\"] = __js__(\"Boolean\"), __js__(\"Boolean\"));\n\t\t\tBool.__ename__ = [\"Bool\"];\n\t\t});\n\t\t__feature__(\"Class.*\",{\n\t\t\tvar Class = __feature__(\"Type.resolveClass\", $hxClasses[\"Class\"] = { __name__ : [\"Class\"] }, { __name__ : [\"Class\"] });\n\t\t});\n\t\t__feature__(\"Enum.*\",{\n\t\t\tvar Enum = {};\n\t\t});\n\t\t__feature__(\"Void.*\",{\n\t\t\tvar Void = __feature__(\"Type.resolveEnum\", $hxClasses[\"Void\"] = { __ename__ : [\"Void\"] }, { __ename__ : [\"Void\"] });\n\t\t});\n\n#if !js_es5\n\t\t__feature__(\"Array.map\",\n\t\t\tif( Array.prototype.map == null )\n\t\t\t\tArray.prototype.map = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length )\n\t\t\t\t\t\ta[i] = f(__this__[i]);\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n\t\t__feature__(\"Array.filter\",\n\t\t\tif( Array.prototype.filter == null )\n\t\t\t\tArray.prototype.filter = function(f) {\n\t\t\t\t\tvar a = [];\n\t\t\t\t\tfor( i in 0...__this__.length ) {\n\t\t\t\t\t\tvar e = __this__[i];\n\t\t\t\t\t\tif( f(e) ) a.push(e);\n\t\t\t\t\t}\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\t\t);\n#end\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tA String buffer is an efficient way to build a big string by appending small\n\telements together.\n\n\tIts cross-platform implementation uses String concatenation internally, but\n\tStringBuf may be optimized for different targets.\n\n\tUnlike String, an instance of StringBuf is not immutable in the sense that\n\tit can be passed as argument to functions which modify it by appending more\n\tvalues. However, the internal buffer cannot be modified.\n**/\nclass StringBuf {\n\n\tvar b:String = \"\";\n\n\t/**\n\t\tThe length of `this` StringBuf in characters.\n\t**/\n\tpublic var length(get,never) : Int;\n\n\t/**\n\t\tCreates a new StringBuf instance.\n\n\t\tThis may involve initialization of the internal buffer.\n\t**/\n\tpublic function new() {}\n\n\tinline function get_length() : Int {\n\t\treturn b.length;\n\t}\n\n\t/**\n\t\tAppends the representation of `x` to `this` StringBuf.\n\n\t\tThe exact representation of `x` may vary per platform. To get more\n\t\tconsistent behavior, this function should be called with\n\t\tStd.string(x).\n\n\t\tIf `x` is null, the String \"null\" is appended.\n\t**/\n\tpublic inline function add<T>( x : T ) : Void {\n\t\tb += x;\n\t}\n\n\t/**\n\t\tAppends the character identified by `c` to `this` StringBuf.\n\n\t\tIf `c` is negative or has another invalid value, the result is\n\t\tunspecified.\n\t**/\n\tpublic inline function addChar( c : Int ) : Void {\n\t\tb += String.fromCharCode(c);\n\t}\n\n\t/**\n\t\tAppends a substring of `s` to `this` StringBuf.\n\n\t\tThis function expects `pos` and `len` to describe a valid substring of\n\t\t`s`, or else the result is unspecified. To get more robust behavior,\n\t\t`this.add(s.substr(pos,len))` can be used instead.\n\n\t\tIf `s` or `pos` are null, the result is unspecified.\n\n\t\tIf `len` is omitted or null, the substring ranges from `pos` to the end\n\t\tof `s`.\n\t**/\n\tpublic inline function addSub( s : String, pos : Int, ?len : Int) : Void {\n\t\tb += (len == null ? s.substr(pos) : s.substr(pos, len));\n\t}\n\n\t/**\n\t\tReturns the content of `this` StringBuf as String.\n\n\t\tThe buffer is not emptied by this operation.\n\t**/\n\tpublic inline function toString() : String {\n\t\treturn b;\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class provides advanced methods on Strings. It is ideally used with\n\t'using StringTools' and then acts as an extension to the String class.\n\n\tIf the first argument to any of the methods is null, the result is\n\tunspecified.\n**/\n#if cs\n@:keep\n#end\nclass StringTools {\n\t/**\n\t\tEncode an URL by using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlEncode( s : String ) : String untyped {\n\t\t#if flash9\n\t\t\treturn __global__[\"encodeURIComponent\"](s);\n\t\t#elseif flash\n\t\t\treturn _global[\"escape\"](s);\n\t\t#elseif neko\n\t\t\treturn new String(_urlEncode(s.__s));\n\t\t#elseif js\n\t\t\treturn encodeURIComponent(s);\n\t\t#elseif cpp\n\t\t\treturn s.__URLEncode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLEncoder.encode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn cs.system.Uri.EscapeUriString(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tDecode an URL using the standard format.\n\t**/\n\t#if (!java && !cpp) inline #end public static function urlDecode( s : String ) : String untyped {\n\t\t#if flash9\n\t\t\treturn __global__[\"decodeURIComponent\"](s.split(\"+\").join(\" \"));\n\t\t#elseif flash\n\t\t\treturn _global[\"unescape\"](s);\n\t\t#elseif neko\n\t\t\treturn new String(_urlDecode(s.__s));\n\t\t#elseif js\n\t\t\treturn decodeURIComponent(s.split(\"+\").join(\" \"));\n\t\t#elseif cpp\n\t\t\treturn s.__URLDecode();\n\t\t#elseif java\n\t\t\ttry\n\t\t\t\treturn untyped __java__(\"java.net.URLDecoder.decode(s, \\\"UTF-8\\\")\")\n\t\t\tcatch (e:Dynamic) throw e;\n\t\t#elseif cs\n\t\t\treturn cs.system.Uri.UnescapeDataString(s);\n\t\t#else\n\t\t\treturn null;\n\t\t#end\n\t}\n\n\t/**\n\t\tEscapes HTML special characters of the string `s`.\n\n\t\tThe following replacements are made:\n\n\t\t- `&` becomes `&amp`;\n\t\t- `<` becomes `&lt`;\n\t\t- `>` becomes `&gt`;\n\n\t\tIf `quotes` is true, the following characters are also replaced:\n\n\t\t- `\"` becomes `&quot`;\n\t\t- `'` becomes `&#039`;\n\t**/\n\tpublic static function htmlEscape( s : String, ?quotes : Bool ) : String {\n\t\ts = s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t\treturn quotes ? s.split('\"').join(\"&quot;\").split(\"'\").join(\"&#039;\") : s;\n\t}\n\n\t/**\n\t\tUnescapes HTML special characters of the string `s`.\n\n\t\tThis is the inverse operation to htmlEscape, i.e. the following always\n\t\tholds: htmlUnescape(htmlEscape(s)) == s\n\n\t\tThe replacements follow:\n\n\t\t- `&amp;` becomes `&`\n\t\t- `&lt;` becomes `<`\n\t\t- `&gt;` becomes `>`\n\t\t- `&quot;` becomes `\"`\n\t\t- `&#039;` becomes `'`\n\t**/\n\tpublic static function htmlUnescape( s : String ) : String {\n\t\treturn s.split(\"&gt;\").join(\">\").split(\"&lt;\").join(\"<\").split(\"&quot;\").join('\"').split(\"&#039;\").join(\"'\").split(\"&amp;\").join(\"&\");\n\t}\n\n\t/**\n\t\tTells if the string `s` starts with the string `start`.\n\n\t\tIf `start` is null, the result is unspecified.\n\n\t\tIf `start` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function startsWith( s : String, start : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.startsWith(start);\n\t\t#elseif cs\n\t\treturn untyped s.StartsWith(start);\n\t\t#else\n\t\treturn( s.length >= start.length && s.substr(0, start.length) == start );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the string `s` ends with the string `end`.\n\n\t\tIf `end` is null, the result is unspecified.\n\n\t\tIf `end` is the empty String \"\", the result is true.\n\t**/\n\tpublic static #if (cs || java) inline #end function endsWith( s : String, end : String ) : Bool {\n\t\t#if java\n\t\treturn untyped s.endsWith(end);\n\t\t#elseif cs\n\t\treturn untyped s.EndsWith(end);\n\t\t#else\n\t\tvar elen = end.length;\n\t\tvar slen = s.length;\n\t\treturn( slen >= elen && s.substr(slen - elen, elen) == end );\n\t\t#end\n\t}\n\n\t/**\n\t\tTells if the character in the string `s` at position `pos` is a space.\n\n\t\tA character is considered to be a space character if its character code\n\t\tis 9,10,11,12,13 or 32.\n\n\t\tIf `s` is the empty String \"\", or if pos is not a valid position within\n\t\t`s`, the result is false.\n\t**/\n\tpublic static function isSpace( s : String, pos : Int ) : Bool {\n\t\tvar c = s.charCodeAt( pos );\n\t\treturn (c > 8 && c < 14) || c == 32;\n\t}\n\n\t/**\n\t\tRemoves leading space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function ltrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimStart();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,r) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 )\n\t\t\treturn s.substr(r, l-r);\n\t\telse\n\t\t\treturn s;\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves trailing space characters of `s`.\n\n\t\tThis function internally calls isSpace() to decide which characters to\n\t\tremove.\n\n\t\tIf `s` is the empty String \"\" or consists only of space characters, the\n\t\tresult is the empty String \"\".\n\t**/\n\tpublic #if cs inline #end static function rtrim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.TrimEnd();\n\t\t#else\n\t\tvar l = s.length;\n\t\tvar r = 0;\n\t\twhile( r < l && isSpace(s,l-r-1) ){\n\t\t\tr++;\n\t\t}\n\t\tif( r > 0 ){\n\t\t\treturn s.substr(0, l-r);\n\t\t}else{\n\t\t\treturn s;\n\t\t}\n\t\t#end\n\t}\n\n\t/**\n\t\tRemoves leading and trailing space characters of `s`.\n\n\t\tThis is a convenience function for ltrim(rtrim(s)).\n\t**/\n\tpublic #if (cs || java) inline #end static function trim( s : String ) : String {\n\t\t#if cs\n\t\treturn untyped s.Trim();\n\t\t#elseif java\n\t\treturn untyped s.trim();\n\t\t#else\n\t\treturn ltrim(rtrim(s));\n\t\t#end\n\t}\n\n\t/**\n\t\tConcatenates `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function lpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = c + s;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tAppends `c` to `s` until `s.length` is at least `l`.\n\n\t\tIf `c` is the empty String \"\" or if `l` does not exceed `s.length`,\n\t\t`s` is returned unchanged.\n\n\t\tIf `c.length` is 1, the resulting String length is exactly `l`.\n\n\t\tOtherwise the length may exceed `l`.\n\n\t\tIf `c` is null, the result is unspecified.\n\t**/\n\tpublic static function rpad( s : String, c : String, l : Int ) : String {\n\t\tif (c.length <= 0)\n\t\t\treturn s;\n\n\t\twhile (s.length < l) {\n\t\t\ts = s + c;\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReplace all occurences of the String `sub` in the String `s` by the\n\t\tString `by`.\n\n\t\tIf `sub` is the empty String \"\", `by` is inserted after each character\n\t\tof `s`. If `by` is also the empty String \"\", `s` remains unchanged.\n\n\t\tThis is a convenience function for `s.split(sub).join(by)`.\n\n\t\tIf `sub` or `by` are null, the result is unspecified.\n\t**/\n\tpublic static function replace( s : String, sub : String, by : String ) : String {\n\t\t#if java\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.replace(sub, by);\n\t\t#elseif cs\n\t\tif (sub.length == 0)\n\t\t\treturn s.split(sub).join(by);\n\t\telse\n\t\t\treturn untyped s.Replace(sub, by);\n\t\t#else\n\t\treturn s.split(sub).join(by);\n\t\t#end\n\t}\n\n\t/**\n\t\tEncodes `n` into a hexadecimal representation.\n\n\t\tIf `digits` is specified, the resulting String is padded with \"0\" until\n\t\tits length equals `digits`.\n\t**/\n\tpublic static function hex( n : Int, ?digits : Int ) {\n\t\t#if flash9\n\t\t\tvar n : UInt = n;\n\t\t\tvar s : String = untyped n.toString(16);\n\t\t\ts = s.toUpperCase();\n\t\t#else\n\t\t\tvar s = \"\";\n\t\t\tvar hexChars = \"0123456789ABCDEF\";\n\t\t\tdo {\n\t\t\t\ts = hexChars.charAt(n&15) + s;\n\t\t\t\tn >>>= 4;\n\t\t\t} while( n > 0 );\n\t\t#end\n\t\tif( digits != null )\n\t\t\twhile( s.length < digits )\n\t\t\t\ts = \"0\"+s;\n\t\treturn s;\n\t}\n\n\t/**\n\t\tReturns the character code at position `index` of String `s`.\n\n\t\tThis method is faster than String.charCodeAt() on most platforms.\n\t\tHowever, unlike String.charCodeAt(), the result is unspecified if\n\t\t`index` is negative or exceeds `s.length`.\n\n\t\tThis operation is not guaranteed to work if `s` contains the \\0\n\t\tcharacter.\n\t**/\n\tpublic static inline function fastCodeAt( s : String, index : Int ) : Int untyped {\n\t\t#if neko\n\t\treturn untyped __dollar__sget(s.__s, index);\n\t\t#elseif cpp\n\t\treturn s.cca(index);\n\t\t#elseif flash9\n\t\treturn s.cca(index);\n\t\t#elseif flash\n\t\treturn s[\"cca\"](index);\n\t\t#elseif java\n\t\treturn ( index < s.length ) ? cast(_charAt(s, index), Int) : -1;\n\t\t#elseif cs\n\t\treturn ( cast(index, UInt) < s.length ) ? cast(untyped s[index], Int) : -1;\n\t\t#elseif js\n\t\t\t#if mt\n\t\treturn (untyped s).cca(index);\n\t\t\t#else\n\t\treturn (untyped s).charCodeAt(index);\n\t\t\t#end\n\t\t#else\n\t\treturn s.cca(index);\n\t\t#end\n\t}\n\n\t/*\n\t\tTells if `c` represents the end-of-file (EOF) character.\n\t*/\n\t@:noUsing public static inline function isEof( c : Int ) : Bool {\n\t\t#if (flash9 || cpp)\n\t\treturn c == 0;\n\t\t#elseif flash8\n\t\treturn c <= 0; // fast NaN\n\t\t#elseif js\n\t\treturn c != c; // fast NaN\n\t\t#elseif neko\n\t\treturn c == null;\n\t\t#elseif cs\n\t\treturn c == -1;\n\t\t#elseif java\n\t\treturn c == -1;\n\t\t#else\n\t\treturn false;\n\t\t#end\n\t}\n\n\t#if java\n\tprivate static inline function _charAt(str:String, idx:Int):java.StdTypes.Char16 return untyped str._charAt(idx);\n\t#end\n\n\t#if neko\n\tprivate static var _urlEncode = neko.Lib.load(\"std\",\"url_encode\",1);\n\tprivate static var _urlDecode = neko.Lib.load(\"std\",\"url_decode\",1);\n\t#end\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum ValueType {\n\tTNull;\n\tTInt;\n\tTFloat;\n\tTBool;\n\tTObject;\n\tTFunction;\n\tTClass( c : Class<Dynamic> );\n\tTEnum( e : Enum<Dynamic> );\n\tTUnknown;\n}\n\n@:coreApi class Type {\n\n\tpublic static function getClass<T>( o : T ) : Class<T> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn js.Boot.getClass(o);\n\t}\n\n\tpublic static function getEnum( o : EnumValue ) : Enum<Dynamic> untyped {\n\t\tif( o == null )\n\t\t\treturn null;\n\t\treturn o.__enum__;\n\t}\n\n\tpublic static function getSuperClass( c : Class<Dynamic> ) : Class<Dynamic> untyped {\n\t\treturn c.__super__;\n\t}\n\n\n\tpublic static function getClassName( c : Class<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped c.__name__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function getEnumName( e : Enum<Dynamic> ) : String {\n\t\tvar a : Array<String> = untyped e.__ename__;\n\t\treturn a.join(\".\");\n\t}\n\n\tpublic static function resolveClass( name : String ) : Class<Dynamic> untyped {\n\t\tvar cl : Class<Dynamic> = $hxClasses[name];\n\t\t// ensure that this is a class\n\t\tif( cl == null || !js.Boot.isClass(cl) )\n\t\t\treturn null;\n\t\treturn cl;\n\t}\n\n\tpublic static function resolveEnum( name : String ) : Enum<Dynamic> untyped {\n\t\tvar e : Dynamic = $hxClasses[name];\n\t\t// ensure that this is an enum\n\t\tif( e == null || !js.Boot.isEnum(e) )\n\t\t\treturn null;\n\t\treturn e;\n\t}\n\n\tpublic static function createInstance<T>( cl : Class<T>, args : Array<Dynamic> ) : T untyped {\n\t\tswitch( args.length ) {\n\t\tcase 0:\n\t\t\treturn __new__(cl);\n\t\tcase 1:\n\t\t\treturn __new__(cl,args[0]);\n\t\tcase 2:\n\t\t\treturn __new__(cl,args[0],args[1]);\n\t\tcase 3:\n\t\t\treturn __new__(cl,args[0],args[1],args[2]);\n\t\tcase 4:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3]);\n\t\tcase 5:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4]);\n\t\tcase 6:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5]);\n\t\tcase 7:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6]);\n\t\tcase 8:\n\t\t\treturn __new__(cl,args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);\n\t\tdefault:\n\t\t\tthrow \"Too many arguments\";\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static function createEmptyInstance<T>( cl : Class<T> ) : T untyped {\n\t\t__js__(\"function empty() {}; empty.prototype = cl.prototype\");\n\t\treturn __js__(\"new empty()\");\n\t}\n\n\tpublic static function createEnum<T>( e : Enum<T>, constr : String, ?params : Array<Dynamic> ) : T {\n\t\tvar f = Reflect.field(e,constr);\n\t\tif( f == null ) throw \"No such constructor \"+constr;\n\t\tif( Reflect.isFunction(f) ) {\n\t\t\tif( params == null ) throw \"Constructor \"+constr+\" need parameters\";\n\t\t\treturn Reflect.callMethod(e,f,params);\n\t\t}\n\t\tif( params != null && params.length != 0 )\n\t\t\tthrow \"Constructor \"+constr+\" does not need parameters\";\n\t\treturn f;\n\t}\n\n\tpublic static function createEnumIndex<T>( e : Enum<T>, index : Int, ?params : Array<Dynamic> ) : T {\n\t\tvar c : String = (untyped e.__constructs__)[index];\n\t\tif( c == null ) throw index+\" is not a valid enum constructor index\";\n\t\treturn createEnum(e,c,params);\n\t}\n\n\tpublic static function getInstanceFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = [];\n\t\tuntyped __js__(\"for(var i in c.prototype) a.push(i)\");\n\t\ta.remove(\"__class__\");\n\t\ta.remove(\"__properties__\");\n\t\treturn a;\n\t}\n\n\tpublic static function getClassFields( c : Class<Dynamic> ) : Array<String> {\n\t\tvar a = Reflect.fields(c);\n\t\ta.remove(\"__name__\");\n\t\ta.remove(\"__interfaces__\");\n\t\ta.remove(\"__properties__\");\n\t\ta.remove(\"__super__\");\n\t\ta.remove(\"prototype\");\n\t\treturn a;\n\t}\n\n\tpublic static function getEnumConstructs( e : Enum<Dynamic> ) : Array<String> {\n\t\tvar a : Array<String> = untyped e.__constructs__;\n\t\treturn a.copy();\n\t}\n\n\tpublic static function typeof( v : Dynamic ) : ValueType untyped {\n\t\tswitch( __js__(\"typeof\")(v) ) {\n\t\tcase \"boolean\": return TBool;\n\t\tcase \"string\": return TClass(String);\n\t\tcase \"number\":\n\t\t\t// this should handle all cases : NaN, +/-Inf and Floats outside range\n\t\t\tif( Math.ceil(v) == v%2147483648.0 )\n\t\t\t\treturn TInt;\n\t\t\treturn TFloat;\n\t\tcase \"object\":\n\t\t\tif( v == null )\n\t\t\t\treturn TNull;\n\t\t\tvar e = v.__enum__;\n\t\t\tif( e != null )\n\t\t\t\treturn TEnum(e);\n\t\t\tvar c = js.Boot.getClass(v);\n\t\t\tif( c != null )\n\t\t\t\treturn TClass(c);\n\t\t\treturn TObject;\n\t\tcase \"function\":\n\t\t\tif( js.Boot.isClass(v) || js.Boot.isEnum(v) )\n\t\t\t\treturn TObject;\n\t\t\treturn TFunction;\n\t\tcase \"undefined\":\n\t\t\treturn TNull;\n\t\tdefault:\n\t\t\treturn TUnknown;\n\t\t}\n\t}\n\n\tpublic static function enumEq<T>( a : T, b : T ) : Bool untyped {\n\t\tif( a == b )\n\t\t\treturn true;\n\t\ttry {\n\t\t\tif( a[0] != b[0] )\n\t\t\t\treturn false;\n\t\t\tfor( i in 2...a.length )\n\t\t\t\tif( !enumEq(a[i],b[i]) )\n\t\t\t\t\treturn false;\n\t\t\tvar e = a.__enum__;\n\t\t\tif( e != b.__enum__ || e == null )\n\t\t\t\treturn false;\n\t\t} catch( e : Dynamic ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic inline static function enumConstructor( e : EnumValue ) : String {\n\t\treturn untyped e[0];\n\t}\n\n\tpublic inline static function enumParameters( e : EnumValue ) : Array<Dynamic> {\n\t\treturn untyped e.slice(2);\n\t}\n\n\tpublic inline static function enumIndex( e : EnumValue ) : Int {\n\t\treturn untyped e[1];\n\t}\n\n\tpublic static function allEnums<T>( e : Enum<T> ) : Array<T> {\n\t\treturn untyped e.__empty_constructs__;\n\t}\n\n}\n\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nenum XmlType {\n}\n\n@:coreApi class Xml {\n\n\tpublic static var Element(default,null) : XmlType;\n\tpublic static var PCData(default,null) : XmlType;\n\tpublic static var CData(default,null) : XmlType;\n\tpublic static var Comment(default,null) : XmlType;\n\tpublic static var DocType(default,null) : XmlType;\n\tpublic static var ProcessingInstruction(default,null) : XmlType;\n\tpublic static var Document(default,null) : XmlType;\n\n\tpublic var nodeType(default,null) : XmlType;\n\tpublic var nodeName(get,set) : String;\n\tpublic var nodeValue(get,set) : String;\n\tpublic var parent(get,null) : Xml;\n\n\tvar _nodeName : String;\n\tvar _nodeValue : String;\n\tvar _attributes : haxe.ds.StringMap<String>;\n\tvar _children : Array<Xml>;\n\tvar _parent : Xml;\n\n\tpublic static function parse( str : String ) : Xml {\n\t\treturn haxe.xml.Parser.parse(str);\n\t}\n\n\tprivate function new() : Void {\n\t}\n\n\tpublic static function createElement( name : String ) : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.Element;\n\t\tr._children = new Array();\n\t\tr._attributes = new haxe.ds.StringMap();\n\t\tr.set_nodeName( name );\n\t\treturn r;\n\t}\n\n\tpublic static function createPCData( data : String ) : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.PCData;\n\t\tr.set_nodeValue( data );\n\t\treturn r;\n\t}\n\n\tpublic static function createCData( data : String ) : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.CData;\n\t\tr.set_nodeValue( data );\n\t\treturn r;\n\t}\n\n\tpublic static function createComment( data : String ) : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.Comment;\n\t\tr.set_nodeValue( data );\n\t\treturn r;\n\t}\n\n\tpublic static function createDocType( data : String ) : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.DocType;\n\t\tr.set_nodeValue( data );\n\t\treturn r;\n\t}\n\n\tpublic static function createProcessingInstruction( data : String ) : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.ProcessingInstruction;\n\t\tr.set_nodeValue( data );\n\t\treturn r;\n\t}\n\n\tpublic static function createDocument() : Xml {\n\t\tvar r = new Xml();\n\t\tr.nodeType = Xml.Document;\n\t\tr._children = new Array();\n\t\treturn r;\n\t}\n\n\tprivate function get_nodeName() : String {\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _nodeName;\n\t}\n\n\tprivate function set_nodeName( n : String ) : String {\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _nodeName = n;\n\t}\n\n\tprivate function get_nodeValue() : String {\n\t\tif( nodeType == Xml.Element || nodeType == Xml.Document )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _nodeValue;\n\t}\n\n\tprivate function set_nodeValue( v : String ) : String {\n\t\tif( nodeType == Xml.Element || nodeType == Xml.Document )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _nodeValue = v;\n\t}\n\n\tprivate function get_parent() : Xml {\n\t\treturn _parent;\n\t}\n\n\tpublic function get( att : String ) : String {\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _attributes.get( att );\n\t}\n\n\tpublic function set( att : String, value : String ) : Void {\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\t_attributes.set( att, value );\n\t}\n\n\tpublic function remove( att : String ) : Void{\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\t_attributes.remove( att );\n\t}\n\n\tpublic function exists( att : String ) : Bool {\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _attributes.exists( att );\n\t}\n\n\tpublic function attributes() : Iterator<String> {\n\t\tif( nodeType != Xml.Element )\n\t\t\tthrow \"bad nodeType\";\n\t\treturn _attributes.keys();\n\t}\n\n\tpublic function iterator() : Iterator<Xml> {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\treturn untyped {\n\t\t\tcur: 0,\n\t\t\tx: this._children,\n\t\t\thasNext : function(){\n\t\t\t\treturn __this__.cur < __this__.x.length;\n\t\t\t},\n\t\t\tnext : function(){\n\t\t\t\treturn __this__.x[__this__.cur++];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function elements() : Iterator<Xml> {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\treturn untyped {\n\t\t\tcur: 0,\n\t\t\tx: this._children,\n\t\t\thasNext : function() {\n\t\t\t\tvar k = __this__.cur;\n\t\t\t\tvar l = __this__.x.length;\n\t\t\t\twhile( k < l ) {\n\t\t\t\t\tif( __this__.x[k].nodeType == Xml.Element )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tk += 1;\n\t\t\t\t}\n\t\t\t\t__this__.cur = k;\n\t\t\t\treturn k < l;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\tvar k = __this__.cur;\n\t\t\t\tvar l = __this__.x.length;\n\t\t\t\twhile( k < l ) {\n\t\t\t\t\tvar n = __this__.x[k];\n\t\t\t\t\tk += 1;\n\t\t\t\t\tif( n.nodeType == Xml.Element ) {\n\t\t\t\t\t\t__this__.cur = k;\n\t\t\t\t\t\treturn n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function elementsNamed( name : String ) : Iterator<Xml> {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\treturn untyped {\n\t\t\tcur: 0,\n\t\t\tx: this._children,\n\t\t\thasNext : function() {\n\t\t\t\tvar k = __this__.cur;\n\t\t\t\tvar l = __this__.x.length;\n\t\t\t\twhile( k < l ) {\n\t\t\t\t\tvar n = __this__.x[k];\n\t\t\t\t\tif( n.nodeType == Xml.Element && n._nodeName == name )\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\t__this__.cur = k;\n\t\t\t\treturn k < l;\n\t\t\t},\n\t\t\tnext : function() {\n\t\t\t\tvar k = __this__.cur;\n\t\t\t\tvar l = __this__.x.length;\n\t\t\t\twhile( k < l ) {\n\t\t\t\t\tvar n = __this__.x[k];\n\t\t\t\t\tk++;\n\t\t\t\t\tif( n.nodeType == Xml.Element && n._nodeName == name ) {\n\t\t\t\t\t\t__this__.cur = k;\n\t\t\t\t\t\treturn n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic function firstChild() : Xml {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\treturn _children[0];\n\t}\n\n\tpublic function firstElement() : Xml {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\tvar cur = 0;\n\t\tvar l = _children.length;\n\t\twhile( cur < l ) {\n\t\t\tvar n = _children[cur];\n\t\t\tif( n.nodeType == Xml.Element )\n\t\t\t\treturn n;\n\t\t\tcur++;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic function addChild( x : Xml ) : Void {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\tif( x._parent != null ) x._parent._children.remove(x);\n\t\tx._parent = this;\n\t\t_children.push( x );\n\t}\n\n\tpublic function removeChild( x : Xml ) : Bool {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\tvar b = _children.remove( x );\n\t\tif( b )\n\t\t\tx._parent = null;\n\t\treturn b;\n\t}\n\n\tpublic function insertChild( x : Xml, pos : Int ) : Void {\n\t\tif( _children == null ) throw \"bad nodetype\";\n\t\tif( x._parent != null ) x._parent._children.remove(x);\n\t\tx._parent = this;\n\t\t_children.insert( pos, x );\n\t}\n\n\tpublic function toString() : String {\n\t\tif( nodeType == Xml.PCData )\n\t\t\treturn StringTools.htmlEscape(_nodeValue);\n\t\tif( nodeType == Xml.CData )\n\t\t\treturn \"<![CDATA[\"+_nodeValue+\"]]>\";\n\t\tif( nodeType == Xml.Comment )\n\t\t\treturn \"<!--\"+_nodeValue+\"-->\";\n\t\tif( nodeType == Xml.DocType )\n\t\t\treturn \"<!DOCTYPE \"+_nodeValue+\">\";\n\t\tif( nodeType == Xml.ProcessingInstruction )\n\t\t\treturn \"<?\"+_nodeValue+\"?>\";\n\t\tvar s = new StringBuf();\n\n\t\tif( nodeType == Xml.Element ) {\n\t\t\ts.add(\"<\");\n\t\t\ts.add(_nodeName);\n\t\t\tfor( k in _attributes.keys() ){\n\t\t\t\ts.add(\" \");\n\t\t\t\ts.add(k);\n\t\t\t\ts.add(\"=\\\"\");\n\t\t\t\ts.add(_attributes.get(k));\n\t\t\t\ts.add(\"\\\"\");\n\t\t\t}\n\t\t\tif( _children.length == 0 ) {\n\t\t\t\ts.add(\"/>\");\n\t\t\t\treturn s.toString();\n\t\t\t}\n\t\t\ts.add(\">\");\n\t\t}\n\n\t\tfor( x in iterator() )\n\t\t\ts.add(x.toString());\n\n\t\tif( nodeType == Xml.Element ) {\n\t\t\ts.add(\"</\");\n\t\t\ts.add(_nodeName);\n\t\t\ts.add(\">\");\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tstatic function __init__() : Void untyped {\n\t\tXml.Element = \"element\";\n\t\tXml.PCData = \"pcdata\";\n\t\tXml.CData = \"cdata\";\n\t\tXml.Comment = \"comment\";\n\t\tXml.DocType = \"doctype\";\n\t\tXml.ProcessingInstruction = \"processingInstruction\";\n\t\tXml.Document = \"document\";\n\t}\n\n}\n","/*\n * This file is part of the AABBTree library for haxe (https://github.com/azrafe7/AABBTree).\n *\n * Developed by Giuseppe Di Mauro (aka azrafe7) and realeased under the MIT license (see LICENSE file).\n */\n\npackage ds;\n\n\n/**\n * Axis-Aligned Bounding Box.\n * \n * @author azrafe7\n */\nclass AABB\n{\t\n\tpublic var minX:Float;\n\tpublic var maxX:Float;\n\tpublic var minY:Float;\n\tpublic var maxY:Float;\n\n\tpublic var x(get, set):Float;\n\tinline private function get_x():Float\n\t{\n\t\treturn minX;\n\t}\n\tinline private function set_x(value:Float):Float\n\t{\n\t\tmaxX += value - minX;\n\t\treturn minX = value;\n\t}\n\t\n\tpublic var y(get, set):Float;\n\tinline private function get_y():Float\n\t{\n\t\treturn minY;\n\t}\n\tinline private function set_y(value:Float):Float\n\t{\n\t\tmaxY += value - minY;\n\t\treturn minY = value;\n\t}\n\t\n\tpublic var width(get, set):Float;\n\tinline private function get_width():Float\n\t{\n\t\treturn maxX - minX;\n\t}\n\tinline private function set_width(value:Float):Float\n\t{\n\t\treturn maxX = minX + value;\n\t}\n\t\n\tpublic var height(get, set):Float;\n\tinline private function get_height():Float\n\t{\n\t\treturn maxY - minY;\n\t}\n\tinline private function set_height(value:Float):Float\n\t{\n\t\treturn maxY = minY + value;\n\t}\n\t\n\t/** \n\t * Creates an AABB from the specified parameters.\n\t * \n\t * Note: `width` and `height` must be non-negative.\n\t */\n\tpublic function new(x:Float = 0, y:Float = 0, width:Float = 0, height:Float = 0):Void \n\t{\n\t\tminX = x;\n\t\tminY = y;\n\t\tmaxX = x + width;\n\t\tmaxY = y + height;\n\t}\n\n\tpublic function setTo(x:Float, y:Float, width:Float = 0, height:Float = 0):Void \n\t{\n\t\tminX = x;\n\t\tminY = y;\n\t\tmaxX = x + width;\n\t\tmaxY = y + height;\n\t}\n\n\tpublic function inflate(deltaX:Float, deltaY:Float):AABB\n\t{\n\t\tminX -= deltaX;\n\t\tminY -= deltaY;\n\t\tmaxX += deltaX;\n\t\tmaxY += deltaY;\n\t\treturn this;\n\t}\n\t\n\tpublic function getPerimeter():Float\n\t{\n\t\treturn 2 * ((maxX - minX) + (maxY - minY));\n\t}\n\t\n\tpublic function getArea():Float\n\t{\n\t\treturn (maxX - minX) * (maxY - minY);\n\t}\n\t\n\tpublic function getCenterX():Float\n\t{\n\t\treturn minX + .5 * (maxX - minX);\n\t}\n\t\n\tpublic function getCenterY():Float\n\t{\n\t\treturn minY + .5 * (maxY - minY);\n\t}\n\t\n\t/** Resizes this instance so that it tightly encloses `aabb`. */\n\tpublic function union(aabb:AABB):AABB\n\t{\n\t\tminX = Math.min(minX, aabb.minX);\n\t\tminY = Math.min(minY, aabb.minY);\n\t\tmaxX = Math.max(maxX, aabb.maxX);\n\t\tmaxY = Math.max(maxY, aabb.maxY);\n\t\treturn this;\n\t}\n\t\n\t/** Resizes this instance to the union of `aabb1` and `aabb2`. */\n\tpublic function asUnionOf(aabb1:AABB, aabb2:AABB):AABB\n\t{\n\t\tminX = Math.min(aabb1.minX, aabb2.minX);\n\t\tminY = Math.min(aabb1.minY, aabb2.minY);\n\t\tmaxX = Math.max(aabb1.maxX, aabb2.maxX);\n\t\tmaxY = Math.max(aabb1.maxY, aabb2.maxY);\n\t\treturn this;\n\t}\n\t\n\t/** Returns true if this instance intersects `aabb`. */\n\tpublic function overlaps(aabb:AABB):Bool\n\t{\n\t\treturn !(minX > aabb.maxX || maxX < aabb.minX || minY > aabb.maxY || maxY < aabb.minY);\n\t}\n\t\n\t/** Returns true if this instance fully contains `aabb`. */\n\tpublic function contains(aabb:AABB):Bool\n\t{\n\t\treturn (aabb.minX >= minX && aabb.maxX <= maxX && aabb.minY >= minY && aabb.maxY <= maxY);\n\t}\n\t\n\t/** Returns a new instance that is the intersection with `aabb`, or null if there's no interesection. */\n\tpublic function getIntersection(aabb:AABB):AABB \n\t{\n\t\tvar intersection = this.clone();\n\t\tintersection.minX = Math.max(minX, aabb.minX);\n\t\tintersection.maxX = Math.min(maxX, aabb.maxX);\n\t\tintersection.minY = Math.max(minY, aabb.minY);\n\t\tintersection.maxY = Math.min(maxY, aabb.maxY);\n\t\treturn (intersection.minX > intersection.maxX || intersection.minY > intersection.maxY) ? null : intersection;\n\t}\n\t\n\tpublic function clone():AABB\n\t{\n\t\treturn new AABB(minX, minY, maxX - minX, maxY - minY);\n\t}\n\n\t/** Copies values from the specified `aabb`. */\n\tpublic function fromAABB(aabb:AABB):AABB\n\t{\n\t\tminX = aabb.minX;\n\t\tminY = aabb.minY;\n\t\tmaxX = aabb.maxX;\n\t\tmaxY = aabb.maxY;\n\t\treturn this;\n\t}\n\t\n\tpublic function toString():String \n\t{\n\t\treturn '[x:${minX} y:${minY} w:${width} h:${height}]';\n\t}\n}\n","/*\n * This file is part of the AABBTree library for haxe (https://github.com/azrafe7/AABBTree).\n * \n * Developed by Giuseppe Di Mauro (aka azrafe7) and realeased under the MIT license (see LICENSE file).\n * \n * The code is heavily inspired by the implementations of a dynamic AABB tree by \n * \n *  - Nathanael Presson \t(Bullet Physics - http://bulletphysics.org)\n *\t- Erin Catto \t\t\t(Box2D - http://www.box2d.org)\n */\n\npackage ds;\n\nimport ds.AABB;\nimport ds.aabbtree.DebugRenderer;\nimport ds.aabbtree.Node;\nimport ds.aabbtree.NodePool;\nimport ds.aabbtree.IInsertStrategy;\nimport ds.aabbtree.InsertStrategyPerimeter;\n\n\n/**\n * Values that can be returned from query and raycast callbacks to decide how to proceed.\n */\nenum HitBehaviour {\n\tSKIP;\t\t\t\t// continue but don't include in results\n\tINCLUDE;\t\t\t// include and continue (default)\n\tINCLUDE_AND_STOP;\t// include and break out of the search\n\tSTOP;\t\t\t\t// break out of the search\n}\n\n/**\n * AABBTree implementation. A spatial partitioning data structure.\n * \n * Note: by default compiling in DEBUG mode will enable a series of tests\n * to ensure the structure's validity (will affect performance), while\n * in RELEASE mode they won't be executed.\n * \n * You can force the validation by passing -DTREE_CHECKS to the compiler,\n * or forcefully disable it with -DNO_TREE_CHECKS.\n * \n * The `isValidationEnabled` property will be set consequently.\n * \n * @author azrafe7\n */\n@:allow(ds.aabbtree.DebugRenderer)\n@:allow(ds.AABBTreeIterator)\nclass AABBTree<T>\n{\n\t\n#if ((debug && !NO_TREE_CHECKS) || TREE_CHECKS)\n\tpublic var isValidationEnabled(default, null):Bool = true;\n#else\n\tpublic var isValidationEnabled(default, null):Bool = false;\n#end\n\n\t/** How much to fatten the aabbs. */\n\tpublic var fattenDelta:Float;\n\t\n\t/** Algorithm to use for choosing where to insert a new leaf. */\n\tpublic var insertStrategy:IInsertStrategy<T>;\n\t\n\t/** Total number of nodes (includes unused ones). */\n\tpublic var numNodes(get, null):Int = 0;\n\tprivate function get_numNodes():Int \n\t{\n\t\treturn nodes.length;\n\t}\n\t\n\t/** Total number of leaves. */\n\tpublic var numLeaves(default, null):Int = 0;\n\t\n\t/** Height of the tree. */\n\tpublic var height(get, null):Int;\n\tinline private function get_height():Int\n\t{\n\t\treturn root != null ? root.invHeight : -1;\n\t}\n\t\n\t\n\t/* Pooled nodes stuff. */\n\tvar pool:NodePool<T>;\n\tvar maxId:Int = 0;\n\tvar unusedIds:Array<Int>;\n\t\n\tvar root:Node<T> = null;\n\t\n\t/* Cache-friendly array of nodes. Entries are set to null when removed (to be reused later). */\n\tvar nodes:Array<Node<T>>;\n\t\n\t/* Set of leaf nodes indices (implemented as IntMap - values are the same as keys). */\n\tvar leaves:Map<Int, Int>;\n\n\t\n\t/**\n\t * Creates a new AABBTree.\n\t * \n\t * @param\tfattenDelta\t\t\t\tHow much to fatten the aabbs (to avoid updating the nodes too frequently when the underlying data moves/resizes).\n\t * @param\tinsertStrategy\t\t\tStrategy to use for choosing where to insert a new leaf. Defaults to `InsertStrategyPerimeter`.\n\t * @param\tinitialPoolCapacity\t\tHow much free nodes to have in the pool initially.\n\t * @param\tpoolGrowthCapacity\t\tThe pool will grow by this factor when it's empty.\n\t */\n\tpublic function new(fattenDelta:Float = 10, ?insertStrategy:IInsertStrategy<T>, initialPoolCapacity:Int = 64, poolGrowthFactor:Float = 2):Void\n\t{\n\t\tthis.fattenDelta = fattenDelta;\n\t\tthis.insertStrategy = insertStrategy != null ? insertStrategy : new InsertStrategyPerimeter<T>();\n\t\tpool = new NodePool<T>(initialPoolCapacity, poolGrowthFactor);\n\t\tunusedIds = [];\n\t\tnodes = [];\n\t\tleaves = new Map<Int, Int>();\n\t}\n\n\t/** Iterator over leaves data. So you can do: `for (data in tree) ...`. */\n\tinline public function iterator():Iterator<T> \n\t{\n\t\treturn new AABBTreeIterator(this);\n\t}\n\t\n\t/** \n\t * Inserts a leaf node with the specified `aabb` values and associated `data`.\n\t * \n\t * The user must store the returned id and use it later to apply changes to the node (removeLeaf(), updateLeaf()).\n\t * \n\t * @return The index of the inserted node.\n\t */\n\tpublic function insertLeaf(data:T, x:Float, y:Float, width:Float = 0, height:Float = 0):Int\n\t{\n\t\t// create new node and fatten its aabb\n\t\tvar leafNode = pool.get(x, y, width, height, data, null, getNextId());\n\t\tleafNode.aabb.inflate(fattenDelta, fattenDelta);\n\t\tleafNode.invHeight = 0;\n\t\tnodes[leafNode.id] = leafNode;\n\t\tleaves[leafNode.id] = leafNode.id;\n\t\tnumLeaves++;\n\t\t\n\t\tif (root == null) {\n\t\t\troot = leafNode;\n\t\t\treturn leafNode.id;\n\t\t}\n\t\t\n\t\t// find best sibling to insert the leaf\n\t\tvar leafAABB = leafNode.aabb;\n\t\tvar combinedAABB = new AABB();\n\t\tvar left:Node<T>;\n\t\tvar right:Node<T>;\n\t\tvar node = root;\n\t\twhile (!node.isLeaf())\n\t\t{\n\t\t\tswitch (insertStrategy.choose(leafAABB, node))\n\t\t\t{\n\t\t\t\tcase InsertChoice.PARENT:\n\t\t\t\t\tbreak;\n\t\t\t\tcase InsertChoice.DESCEND_LEFT:\n\t\t\t\t\tnode = node.left;\n\t\t\t\tcase InsertChoice.DESCEND_RIGHT:\n\t\t\t\t\tnode = node.right;\n\t\t\t}\n\t\t}\n\n\t\tvar sibling = node;\n\t\t\n\t\t// create a new parent\n\t\tvar oldParent = sibling.parent;\n\t\tcombinedAABB.asUnionOf(leafAABB, sibling.aabb);\n\t\tvar newParent = pool.get(combinedAABB.x, combinedAABB.y, combinedAABB.width, combinedAABB.height, null, oldParent, getNextId());\n\t\tnewParent.invHeight = sibling.invHeight + 1;\n\t\tnodes[newParent.id] = newParent;\n\n\t\t// the sibling was not the root\n\t\tif (oldParent != null) {\n\t\t\t\n\t\t\tif (oldParent.left == sibling) {\n\t\t\t\toldParent.left = newParent;\n\t\t\t} else {\n\t\t\t\toldParent.right = newParent;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\t// the sibling was the root\n\t\t\troot = newParent;\n\t\t}\n\t\tnewParent.left = sibling;\n\t\tnewParent.right = leafNode;\n\t\tsibling.parent = newParent;\n\t\tleafNode.parent = newParent;\n\n\t\t// walk back up the tree fixing heights and AABBs\n\t\tnode = leafNode.parent;\n\t\twhile (node != null)\n\t\t{\n\t\t\tnode = nodes[balance(node.id)];\n\n\t\t\tleft = node.left;\n\t\t\tright = node.right;\n\n\t\t\tassert(left != null);\n\t\t\tassert(right != null);\n\n\t\t\tnode.invHeight = 1 + Std.int(Math.max(left.invHeight, right.invHeight));\n\t\t\tnode.aabb.asUnionOf(left.aabb, right.aabb);\n\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\tvalidate();\n\t\treturn leafNode.id;\n\t}\n\t\n\t/** \n\t * Updates the aabb of leaf node with the specified `leafId` (must be a leaf node).\n\t * \n\t * @param\tdx\tMovement prediction along the x axis.\n\t * @param\tdy\tMovement prediction along the y axis.\n\t * \n\t * @return false if the fat aabb didn't need to be expanded.\n\t */\n\tpublic function updateLeaf(leafId:Int, x:Float, y:Float, width:Float = 0, height:Float = 0, dx:Float = 0, dy:Float = 0):Bool\n\t{\n\t\tvar leafNode = nodes[leafId];\n\t\tassert(leafNode.isLeaf());\n\t\t\n\t\tvar newAABB = new AABB(x, y, width, height);\n\t\t\n\t\tif (leafNode.aabb.contains(newAABB)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar data = leafNode.data;\n\t\tremoveLeaf(leafId);\n\t\t\n\t\t// add movement prediction\n\t\tdx *= 2;\n\t\tdy *= 2;\n\t\tif (dx < 0) {\n\t\t\tx += dx;\n\t\t\twidth -= dx;\n\t\t} else {\n\t\t\twidth += dx;\n\t\t}\n\t\tif (dy < 0) {\n\t\t\ty += dy;\n\t\t\theight -= dy;\n\t\t} else {\n\t\t\theight += dy;\n\t\t}\n\t\t\n\t\tvar newId = insertLeaf(data, x, y, width, height);\n\t\t\n\t\tassert(newId == leafId);\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/** \n\t * Removes the leaf node with the specified `leafId` from the tree (must be a leaf node).\n\t */\n\tpublic function removeLeaf(leafId:Int):Void\n\t{\n\t\tvar leafNode = nodes[leafId];\n\t\tassert(leafNode.isLeaf());\n\t\t\n\t\tleaves.remove(leafId);\n\t\t\n\t\tif (leafNode == root) {\n\t\t\tdisposeNode(leafId);\n\t\t\troot = null;\n\t\t\treturn;\n\t\t}\n\n\t\tvar parent = leafNode.parent;\n\t\tvar grandParent = parent.parent;\n\t\tvar sibling = parent.left == leafNode ? parent.right : parent.left;\n\n\t\tif (grandParent != null) {\n\t\t\t// connect sibling to grandParent\n\t\t\tif (grandParent.left == parent) {\n\t\t\t\tgrandParent.left = sibling;\n\t\t\t} else {\n\t\t\t\tgrandParent.right = sibling;\n\t\t\t}\n\t\t\tsibling.parent = grandParent;\n\n\t\t\t// adjust ancestor bounds\n\t\t\tvar node = grandParent;\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tnode = nodes[balance(node.id)];\n\n\t\t\t\tvar left = node.left;\n\t\t\t\tvar right = node.right;\n\n\t\t\t\tnode.aabb.asUnionOf(left.aabb, right.aabb);\n\t\t\t\tnode.invHeight = 1 + Std.int(Math.max(left.invHeight, right.invHeight));\n\n\t\t\t\tnode = node.parent;\n\t\t\t}\n\t\t} else {\n\t\t\troot = sibling;\n\t\t\troot.parent = null;\n\t\t}\n\t\t\n\t\t// destroy parent\n\t\tassert(parent.id != -1);\n\t\tdisposeNode(parent.id);\n\t\tdisposeNode(leafId);\n\t\t\n\t\tassert(numLeaves == [for (k in leaves.keys()) k].length);\n\t\t\n\t\tvalidate();\n\t}\n\t\n\t/** \n\t * Removes all nodes from the tree. \n\t * \n\t * @param\tresetPool\tIf true the internal pool will be reset to its initial capacity.\n\t */\n\tpublic function clear(resetPool:Bool = false)\n\t{\n\t\tvar count = numNodes;\n\t\twhile (count > 0) {\n\t\t\tvar node = nodes[count - 1];\n\t\t\tif (node != null) disposeNode(node.id);\n\t\t\tcount--;\n\t\t}\n\t\troot = null;\n\t\tnodes = [];\n\t\tleaves = new Map<Int, Int>();\n\t\tunusedIds = [];\n\t\tmaxId = 0;\n\t\tif (resetPool) pool.reset();\n\t\t\n\t\tassert(numNodes == 0);\n\t}\n\t\n\t/** Rebuilds the tree using a bottom-up strategy (should result in a better tree, but is very expensive). */\n\tpublic function rebuild():Void \n\t{\n\t\tif (root == null) return;\n\n\t\t// free non-leaf nodes\n\t\tfor (node in nodes) {\n\t\t\tif (node == null) continue;\n\t\t\tif (!node.isLeaf()) {\n\t\t\t\tdisposeNode(node.id);\n\t\t\t} else {\n\t\t\t\tnode.parent = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// copy leaves ids\n\t\tvar leafIds = [for (id in leaves.keys()) id];\n\t\t\n\t\tvar aabb = new AABB();\n\t\tvar count = leafIds.length;\n\t\twhile (count > 1) {\n\t\t\tvar minCost = Math.POSITIVE_INFINITY;\n\t\t\tvar iMin = -1;\n\t\t\tvar jMin = -1;\n\t\t\t\n\t\t\t// find pair with least perimeter enlargement\n\t\t\tfor (i in 0...count) {\n\t\t\t\tvar iAABB = nodes[leafIds[i]].aabb;\n\n\t\t\t\tfor (j in i + 1...count) {\n\t\t\t\t\tvar jAABB = nodes[leafIds[j]].aabb;\n\t\t\t\t\t\n\t\t\t\t\taabb.asUnionOf(iAABB, jAABB);\n\t\t\t\t\tvar cost = aabb.getPerimeter();\n\t\t\t\t\tif (cost < minCost) {\n\t\t\t\t\t\tiMin = i;\n\t\t\t\t\t\tjMin = j;\n\t\t\t\t\t\tminCost = cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar left = nodes[leafIds[iMin]];\n\t\t\tvar right = nodes[leafIds[jMin]];\n\t\t\taabb.asUnionOf(left.aabb, right.aabb);\n\t\t\tvar parent = pool.get(aabb.x, aabb.y, aabb.width, aabb.height, null, null, getNextId());\n\t\t\tparent.left = left;\n\t\t\tparent.right = right;\n\t\t\tparent.invHeight = Std.int(1 + Math.max(left.invHeight, right.invHeight));\n\t\t\tnodes[parent.id] = parent;\n\t\t\t\n\t\t\tleft.parent = parent;\n\t\t\tright.parent = parent;\n\t\t\t\n\t\t\tleafIds[iMin] = parent.id;\n\t\t\tleafIds[jMin] = leafIds[count - 1];\n\t\t\t\n\t\t\tcount--;\n\t\t}\n\n\t\troot = nodes[leafIds[0]];\n\n\t\tvalidate();\n\t}\n\t\n\t/** Returns a list of all the data objects attached to leaves (optionally appending them to `into`). */\n\tpublic function getLeavesData(?into:Array<T>):Array<T>\n\t{\n\t\tvar res = into != null ? into : [];\n\t\tfor (id in leaves.keys()) res.push(nodes[id].data);\n\t\treturn res;\n\t}\n\t\n\t/** Returns a list of all the leaves' ids (optionally appending them to `into`). */\n\tpublic function getLeavesIds(?into:Array<Int>):Array<Int>\n\t{\n\t\tvar res = into != null ? into : [];\n\t\tfor (id in leaves.keys()) res.push(id);\n\t\treturn res;\n\t}\n\t\n\t/** Returns data associated to the node with the specified `leafId` (must be a leaf node). */\n\tpublic function getData(leafId:Int):T\n\t{\n\t\tvar leafNode = nodes[leafId];\n\t\tassert(leafNode.isLeaf());\n\t\t\n\t\treturn leafNode.data;\n\t}\n\t\n\t/** Returns a clone of the aabb associated to the node with the specified `leafId` (must be a leaf node). */\n\tpublic function getFatAABB(leafId:Int):AABB\n\t{\n\t\tvar leafNode = nodes[leafId];\n\t\tassert(leafNode.isLeaf());\n\t\t\n\t\treturn leafNode.aabb.clone();\n\t}\n\t\n\t/**\n\t * Queries the tree for objects in the specified AABB.\n\t * \n\t * @param\tinto\t\t\tHit objects will be appended to this (based on callback return value).\n\t * @param\tstrictMode\t\tIf set to true only objects fully contained in the AABB will be processed. Otherwise they will be checked for intersection (default).\n\t * @param\tcallback\t\tA function called for every object hit (function callback(data:T, id:Int):HitBehaviour).\n\t * \n\t * @return A list of all the objects found (or `into` if it was specified).\n\t */\n\tpublic function query(x:Float, y:Float, width:Float = 0, height:Float = 0, strictMode:Bool = false, ?into:Array<T>, ?callback:T->Int->HitBehaviour):Array<T>\n\t{\n\t\tvar res = into != null ? into : new Array<T>();\n\t\tif (root == null) return res;\n\t\t\n\t\tvar stack = [root];\n\t\tvar queryAABB = new AABB(x, y, width, height);\n\t\tvar cnt = 0;\n\t\twhile (stack.length > 0) {\n\t\t\tvar node = stack.pop();\n\t\t\tcnt++;\n\t\t\t\n\t\t\tif (queryAABB.overlaps(node.aabb)) {\n\t\t\t\tif (node.isLeaf() && (!strictMode || (strictMode && queryAABB.contains(node.aabb)))) {\n\t\t\t\t\tif (callback != null) {\n\t\t\t\t\t\tvar hitBehaviour = callback(node.data, node.id);\n\t\t\t\t\t\tif (hitBehaviour == INCLUDE || hitBehaviour == INCLUDE_AND_STOP) {\n\t\t\t\t\t\t\tres.push(node.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hitBehaviour == STOP || hitBehaviour == INCLUDE_AND_STOP) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.push(node.data);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (node.left != null) stack.push(node.left);\n\t\t\t\t\tif (node.right != null) stack.push(node.right);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//trace(\"examined: \" + cnt);\n\t\treturn res;\n\t}\n\t\n\t/**\n\t * Queries the tree for objects overlapping the specified point.\n\t * \n\t * @param\tinto\t\t\tHit objects will be appended to this (based on callback return value).\n\t * @param\tcallback\t\tA function called for every object hit (function callback(data:*, id:int):HitBehaviour).\n\t * \n\t * @return A list of all the objects found (or `into` if it was specified).\n\t */\n\tinline public function queryPoint(x:Float, y:Float, ?into:Array<T>, ?callback:T->Int->HitBehaviour):Array<T>\n\t{\n\t\treturn query(x, y, 0, 0, false, into, callback);\n\t}\n\t\n\t/**\n\t * Queries the tree for objects crossing the specified ray.\n\t * \n\t * Notes: \n\t * \t- the intersecting objects will be returned in no particular order (closest ones to the start point may appear later in the list!).\n\t *  - the callback will also be called if an object fully contains the ray's start and end point.\n\t * \n\t * TODO: see how this can be optimized and return results in order\n\t * \n\t * @param\tinto\t\tHit objects will be appended to this (based on callback return value).\n\t * @param\tcallback\tA function called for every object hit (function callback(data:T, id:Int):HitBehaviour).\n\t * \n\t * @return A list of all the objects found (or `into` if it was specified).\n\t */\n\tpublic function rayCast(fromX:Float, fromY:Float, toX:Float, toY:Float, ?into:Array<T>, ?callback:T->Int->HitBehaviour):Array<T>\n\t{\n\t\tvar res = into != null ? into : new Array<T>();\n\t\tif (root == null) return res;\n\t\t\n\t\tvar queryAABBResultsIds = [];\n\n\t\t\n\t\tfunction rayAABBCallback(data:T, id:Int):HitBehaviour\n\t\t{\n\t\t\tvar node = nodes[id];\n\t\t\tvar aabb = node.aabb;\n\t\t\tvar fromPointAABB = new AABB(fromX, fromY);\n\t\t\tvar toPointAABB = new AABB(toX, toY);\n\t\t\t\n\t\t\tvar hit = false;\n\t\t\tfor (i in 0...4) {\t// test for intersection with node's aabb edges\n\t\t\t\tswitch (i) {\n\t\t\t\t\tcase 0:\t// top edge\n\t\t\t\t\t\thit = segmentIntersect(fromX, fromY, toX, toY, aabb.minX, aabb.minY, aabb.maxX, aabb.minY);\n\t\t\t\t\tcase 1:\t// left edge\n\t\t\t\t\t\thit = segmentIntersect(fromX, fromY, toX, toY, aabb.minX, aabb.minY, aabb.minX, aabb.maxY);\n\t\t\t\t\tcase 2:\t// bottom edge\n\t\t\t\t\t\thit = segmentIntersect(fromX, fromY, toX, toY, aabb.minX, aabb.maxY, aabb.maxX, aabb.maxY);\n\t\t\t\t\tcase 3:\t// right edge\n\t\t\t\t\t\thit = segmentIntersect(fromX, fromY, toX, toY, aabb.maxX, aabb.minY, aabb.maxX, aabb.maxY);\n\t\t\t\t\tdefault:\t\n\t\t\t\t}\n\t\t\t\tif (hit) break;\n\t\t\t}\n\t\t\t\n\t\t\t// add intersected node id to array\n\t\t\tif (hit || (!hit && aabb.contains(fromPointAABB))) {\n\t\t\t\tqueryAABBResultsIds.push(id);\n\t\t\t}\n\t\t\t\n\t\t\treturn SKIP;\t// don't bother adding to results\n\t\t}\n\t\t\n\t\tvar tmp:Float;\n\t\tvar rayAABB = new AABB(fromX, fromY, toX - fromX, toY - fromY);\n\t\tif (rayAABB.minX > rayAABB.maxX) {\n\t\t\ttmp = rayAABB.maxX;\n\t\t\trayAABB.maxX = rayAABB.minX;\n\t\t\trayAABB.minX = tmp;\n\t\t}\n\t\tif (rayAABB.minY > rayAABB.maxY) {\n\t\t\ttmp = rayAABB.maxY;\n\t\t\trayAABB.maxY = rayAABB.minY;\n\t\t\trayAABB.minY = tmp;\n\t\t}\n\t\t\n\t\tquery(rayAABB.x, rayAABB.y, rayAABB.width , rayAABB.height, false, null, rayAABBCallback);\n\t\t\n\t\tfor (id in queryAABBResultsIds) {\n\t\t\tvar node = nodes[id];\n\t\t\tif (callback != null) {\n\t\t\t\tvar hitBehaviour = callback(node.data, node.id);\n\t\t\t\tif (hitBehaviour == INCLUDE || hitBehaviour == INCLUDE_AND_STOP) {\n\t\t\t\t\tres.push(node.data);\n\t\t\t\t}\n\t\t\t\tif (hitBehaviour == STOP || hitBehaviour == INCLUDE_AND_STOP) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres.push(node.data);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\t/** Gets the next available id for a node, fecthing it from the list of unused ones if available. */\n\tprivate function getNextId():Int \n\t{\n\t\tvar newId = unusedIds.length > 0 && unusedIds[unusedIds.length - 1] < maxId ? unusedIds.pop() : maxId++;\n\t\treturn newId;\n\t}\n\t\n\t/** Returns the node with the specified `id` to the pool. */\n\tprivate function disposeNode(id:Int) {\n\t\tassert(nodes[id] != null);\n\n\t\tvar node = nodes[id];\n\t\tif (node.isLeaf()) numLeaves--;\n\t\tnodes[node.id] = null;\n\t\tunusedIds.push(node.id);\n\t\tpool.put(node);\n\t}\n\t\n\t/**\n\t * Performs a left or right rotation if `nodeId` is unbalanced.\n\t * \n\t * @return The new parent index.\n\t */\n\tprivate function balance(nodeId:Int):Int\n\t{\n\t\tvar A = nodes[nodeId];\n\t\tassert(A != null);\n\n\t\tif (A.isLeaf() || A.invHeight < 2) {\n\t\t\treturn A.id;\n\t\t}\n\n\t\tvar B = A.left;\n\t\tvar C = A.right;\n\n\t\tvar balanceValue = C.invHeight - B.invHeight;\n\n\t\t// rotate C up\n\t\tif (balanceValue > 1) return rotateLeft(A, B, C);\n\t\t\n\t\t// rotate B up\n\t\tif (balanceValue < -1) return rotateRight(A, B, C);\n\n\t\treturn A.id;\n\t}\n\n\t/** Returns max height distance between two children (of the same parent) in the tree. */\n\tpublic function getMaxBalance():Int\n\t{\n\t\tvar maxBalance = 0;\n\t\tfor (i in 0...nodes.length) {\n\t\t\tvar node = nodes[i];\n\t\t\tif (node.invHeight <= 1 || node == null) continue;\n\n\t\t\tassert(!node.isLeaf());\n\n\t\t\tvar left = node.left;\n\t\t\tvar right = node.right;\n\t\t\tvar balance = Math.abs(right.invHeight - left.invHeight);\n\t\t\tmaxBalance = Std.int(Math.max(maxBalance, balance));\n\t\t}\n\n\t\treturn maxBalance;\n\t}\n\t\n\t/*\n\t *           A\t\t\tparent\n\t *         /   \\\n\t *        B     C\t\tleft and right nodes\n\t *             / \\\n\t *            F   G\n\t */\n\tprivate function rotateLeft(parentNode:Node<T>, leftNode:Node<T>, rightNode:Node<T>):Int\n\t{\n\t\tvar F = rightNode.left;\n\t\tvar G = rightNode.right;\n\n\t\t// swap A and C\n\t\trightNode.left = parentNode;\n\t\trightNode.parent = parentNode.parent;\n\t\tparentNode.parent = rightNode;\n\n\t\t// A's old parent should point to C\n\t\tif (rightNode.parent != null) {\n\t\t\tif (rightNode.parent.left == parentNode) {\n\t\t\t\trightNode.parent.left = rightNode;\n\t\t\t} else {\n\t\t\t\tassert(rightNode.parent.right == parentNode);\n\t\t\t\trightNode.parent.right = rightNode;\n\t\t\t}\n\t\t} else {\n\t\t\troot = rightNode;\n\t\t}\n\n\t\t// rotate\n\t\tif (F.invHeight > G.invHeight) {\n\t\t\trightNode.right = F;\n\t\t\tparentNode.right = G;\n\t\t\tG.parent = parentNode;\n\t\t\tparentNode.aabb.asUnionOf(leftNode.aabb, G.aabb);\n\t\t\trightNode.aabb.asUnionOf(parentNode.aabb, F.aabb);\n\n\t\t\tparentNode.invHeight = 1 + Std.int(Math.max(leftNode.invHeight, G.invHeight));\n\t\t\trightNode.invHeight = 1 + Std.int(Math.max(parentNode.invHeight, F.invHeight));\n\t\t} else {\n\t\t\trightNode.right = G;\n\t\t\tparentNode.right = F;\n\t\t\tF.parent = parentNode;\n\t\t\tparentNode.aabb.asUnionOf(leftNode.aabb, F.aabb);\n\t\t\trightNode.aabb.asUnionOf(parentNode.aabb, G.aabb);\n\n\t\t\tparentNode.invHeight = 1 + Std.int(Math.max(leftNode.invHeight, F.invHeight));\n\t\t\trightNode.invHeight = 1 + Std.int(Math.max(parentNode.invHeight, G.invHeight));\n\t\t}\n\t\t\n\t\treturn rightNode.id;\n\t}\n\t\n\t/*\n\t *           A\t\t\tparent\n\t *         /   \\\n\t *        B     C\t\tleft and right nodes\n\t *       / \\\n\t *      D   E\n\t */\n\tprivate function rotateRight(parentNode:Node<T>, leftNode:Node<T>, rightNode:Node<T>):Int\n\t{\n\t\tvar D = leftNode.left;\n\t\tvar E = leftNode.right;\n\n\t\t// swap A and B\n\t\tleftNode.left = parentNode;\n\t\tleftNode.parent = parentNode.parent;\n\t\tparentNode.parent = leftNode;\n\n\t\t// A's old parent should point to B\n\t\tif (leftNode.parent != null)\n\t\t{\n\t\t\tif (leftNode.parent.left == parentNode) {\n\t\t\t\tleftNode.parent.left = leftNode;\n\t\t\t} else {\n\t\t\t\tassert(leftNode.parent.right == parentNode);\n\t\t\t\tleftNode.parent.right = leftNode;\n\t\t\t}\n\t\t} else {\n\t\t\troot = leftNode;\n\t\t}\n\n\t\t// rotate\n\t\tif (D.invHeight > E.invHeight) {\n\t\t\tleftNode.right = D;\n\t\t\tparentNode.left = E;\n\t\t\tE.parent = parentNode;\n\t\t\tparentNode.aabb.asUnionOf(rightNode.aabb, E.aabb);\n\t\t\tleftNode.aabb.asUnionOf(parentNode.aabb, D.aabb);\n\n\t\t\tparentNode.invHeight = 1 + Std.int(Math.max(rightNode.invHeight, E.invHeight));\n\t\t\tleftNode.invHeight = 1 + Std.int(Math.max(parentNode.invHeight, D.invHeight));\n\t\t} else {\n\t\t\tleftNode.right = E;\n\t\t\tparentNode.left = D;\n\t\t\tD.parent = parentNode;\n\t\t\tparentNode.aabb.asUnionOf(rightNode.aabb, D.aabb);\n\t\t\tleftNode.aabb.asUnionOf(parentNode.aabb, E.aabb);\n\n\t\t\tparentNode.invHeight = 1 + Std.int(Math.max(rightNode.invHeight, D.invHeight));\n\t\t\tleftNode.invHeight = 1 + Std.int(Math.max(parentNode.invHeight, E.invHeight));\n\t\t}\n\n\t\treturn leftNode.id;\n\t}\n\t\n\tprivate function getNode(id:Int):Node<T> \n\t{\n\t\tassert(id >= 0 && nodes[id] != null);\n\t\treturn nodes[id];\n\t}\n\t\n\t/** Tests validity of node with the specified `id` (and its children). */\n\tprivate function validateNode(id:Int):Void \n\t{\n\t\tvar aabb = new AABB();\n\t\tvar root = nodes[id];\n\t\tvar stack = [root];\n\t\twhile (stack.length > 0) {\n\t\t\tvar node = stack.pop();\n\t\t\tassert(node != null);\n\t\t\t\n\t\t\tvar left = node.left;\n\t\t\tvar right = node.right;\n\t\t\t\n\t\t\tif (node.isLeaf()) {\n\t\t\t\tassert(left == null);\n\t\t\t\tassert(right == null);\n\t\t\t\tnode.invHeight = 0;\n\t\t\t\tassert(leaves[node.id] >= 0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tassert(left.id >= 0);\n\t\t\tassert(right.id >= 0);\n\t\t\t\n\t\t\tassert(node.invHeight == 1 + Math.max(left.invHeight, right.invHeight));\n\t\t\taabb.asUnionOf(left.aabb, right.aabb);\n\t\t\tassert(Math.abs(node.aabb.minX - aabb.minX) < 0.000001);\n\t\t\tassert(Math.abs(node.aabb.minY - aabb.minY) < 0.000001);\n\t\t\tassert(Math.abs(node.aabb.maxX - aabb.maxX) < 0.000001);\n\t\t\tassert(Math.abs(node.aabb.maxY - aabb.maxY) < 0.000001);\n\t\t}\n\t}\n\t\n\tstatic private function segmentIntersect(p0x:Float, p0y:Float, p1x:Float, p1y:Float, q0x:Float, q0y:Float, q1x:Float, q1y:Float):Bool\n\t{\n\t\tvar intX:Float, intY:Float;\n\t\tvar a1:Float, a2:Float;\n\t\tvar b1:Float, b2:Float;\n\t\tvar c1:Float, c2:Float;\n\t \n\t\ta1 = p1y - p0y;\n\t\tb1 = p0x - p1x;\n\t\tc1 = p1x * p0y - p0x * p1y;\n\t\ta2 = q1y - q0y;\n\t\tb2 = q0x - q1x;\n\t\tc2 = q1x * q0y - q0x * q1y;\n\t \n\t\tvar denom:Float = a1 * b2 - a2 * b1;\n\t\tif (denom == 0){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tintX = (b1 * c2 - b2 * c1) / denom;\n\t\tintY = (a2 * c1 - a1 * c2) / denom;\n\t \n\t\t// check to see if distance between intersection and endpoints\n\t\t// is longer than actual segments.\n\t\t// return false otherwise.\n\t\tif (distanceSquared(intX, intY, p1x, p1y) > distanceSquared(p0x, p0y, p1x, p1y)) return false;\n\t\tif (distanceSquared(intX, intY, p0x, p0y) > distanceSquared(p0x, p0y, p1x, p1y)) return false;\n\t\tif (distanceSquared(intX, intY, q1x, q1y) > distanceSquared(q0x, q0y, q1x, q1y)) return false;\n\t\tif (distanceSquared(intX, intY, q0x, q0y) > distanceSquared(q0x, q0y, q1x, q1y)) return false;\n\t\t\n\t\treturn true;\n\t}\n\t\n\tinline static private function distanceSquared(px:Float, py:Float, qx:Float, qy:Float):Float { return sqr(px - qx) + sqr(py - qy); }\n\t\n\tinline static private function sqr(x:Float):Float { return x * x; }\n\n\t\n#if ((debug && !NO_TREE_CHECKS) || TREE_CHECKS)\n\n\tfunction validate() {\n\t\tif (root != null) validateNode(root.id);\n\t\tassert(numLeaves >= 0 && numLeaves <= numNodes);\n\t}\n\t\n\tstatic function assert(cond:Bool) {\n\t\tif (!cond) throw \"ASSERT FAILED!\";\n\t}\n\t\n#else\n\n\tinline function validate() {\n\t\treturn;\n\t}\n\t\n\tinline static function assert(cond:Bool) {\n\t\treturn;\n\t}\n\t\n#end\n}\n\n\nclass AABBTreeIterator<T>\n{\n\tvar it:Int;\n\tvar length:Int;\n\tvar tree:AABBTree<T>;\n\tvar ids:Array<Int>;\n\t\n\tpublic function new(tree:AABBTree<T>) {\n\t\tthis.tree = tree;\n\t\tit = 0;\n\t\tlength = tree.numLeaves;\n\t\tids = tree.getLeavesIds();\n\t}\n\t\n\tpublic function hasNext():Bool {\n\t\treturn it < length;\n\t}\n\t\n\tpublic function next():T {\n\t\treturn tree.nodes[ids[it++]].data;\n\t}\n}","\npackage ds;\n\nimport js.html.ArrayBuffer;\nimport js.html.Uint32Array;\nimport js.html.Uint8Array;\nimport physics.geometry.Vector2D;\n\nclass Array2D \n{\n\n    public var w:Int;\n    public var h:Int;\n\n    public var buffer:ArrayBuffer;\n    public var data32:Uint32Array;\n    public var data8:Uint8Array;\n\n    public function new(width:Int,height:Int,buffer:ArrayBuffer=null) {\n        w = width;\n        h = height;\n\n        if (buffer==null)\n            this.buffer = new ArrayBuffer(w*h*4);\n        else\n            this.buffer = buffer;\n        data32 = new Uint32Array(this.buffer);\n        data8 = new Uint8Array(this.buffer);\n    }\n\n    inline public function get(x:Int, y:Int):Int {\n        return data32[getIndex(x,y)];\n    }\n\n    inline public function set(x:Int, y:Int, v:Dynamic) {\n        data32[getIndex(x,y)] = v;\n    }\n\n    inline public function getIndex(x:Int, y:Int):Int {\n        return y * w + x;\n    }\n\n    public function castRay( p1Original:Vector2D, p2Original:Vector2D, tileSize:Int = 16 ):Vector2D {\n        //INITIALISE//////////////////////////////////////////\n        // p2Original.plusEquals(p1Original);\n        // p1Original.plusEquals2(0.5,0.5);\n        // p2Original.plusEquals2(0.5,0.5);\n        // p1Original.multEquals(16);\n        // p2Original.multEquals(16);\n\n        // normalise the points\n        var p1:Vector2D = new Vector2D( p1Original.x / tileSize, p1Original.y / tileSize);\n        var p2:Vector2D = new Vector2D( p2Original.x / tileSize, p2Original.y / tileSize);\n    \n        if ( Std.int( p1.x ) == Std.int( p2.x ) && Std.int( p1.y ) == Std.int( p2.y ) ) {\n            //since it doesn't cross any boundaries, there can't be a collision\n            return p2Original;\n        }\n        \n        //find out which direction to step, on each axis\n        var stepX:Int = ( p2.x > p1.x ) ? 1 : -1;  \n        var stepY:Int = ( p2.y > p1.y ) ? 1 : -1;\n    \n        var rayDirection:Vector2D = new Vector2D( p2.x - p1.x, p2.y - p1.y );\n    \n        //find out how far to move on each axis for every whole integer step on the other\n        var ratioX:Float = rayDirection.x / rayDirection.y;\n        var ratioY:Float = rayDirection.y / rayDirection.x;\n    \n        var deltaY:Float = p2.x - p1.x;\n        var deltaX:Float = p2.y - p1.y;\n        //faster than Math.abs()...\n        deltaX = deltaX < 0 ? -deltaX : deltaX;\n        deltaY = deltaY < 0 ? -deltaY : deltaY;\n    \n        //initialise the integer test coordinates with the coordinates of the starting tile, in tile space ( integer )\n        //Note: using noralised version of p1\n        var testX:Int = Std.int(p1.x); \n        var testY:Int = Std.int(p1.y);\n    \n        //initialise the non-integer step, by advancing to the next tile boundary / ( whole integer of opposing axis )\n        //if moving in positive direction, move to end of curent tile, otherwise the beginning\n        var maxX:Float = deltaX * ( ( stepX > 0 ) ? ( 1.0 - (p1.x % 1) ) : (p1.x % 1) ); \n        var maxY:Float = deltaY * ( ( stepY > 0 ) ? ( 1.0 - (p1.y % 1) ) : (p1.y % 1) );\n    \n        var endTileX:Int = Std.int(p2.x);\n        var endTileY:Int = Std.int(p2.y);\n        \n        //TRAVERSE//////////////////////////////////////////\n    \n        var hit:Bool;\n        var collisionPoint:Vector2D = new Vector2D();\n\n        while( testX != endTileX || testY != endTileY ) {\n\n            if (  maxX < maxY ) {\n                maxX += deltaX;\n                testX += stepX;\n                var data = get( testX, testY );\n                if ( data != 0 ) {\n                    collisionPoint.x = testX;\n                    if ( stepX < 0 ) collisionPoint.x += 1.0; //add one if going left\n                    collisionPoint.y = p1.y + ratioY * ( collisionPoint.x - p1.x);  \n                    collisionPoint.x *= tileSize;//scale up\n                    collisionPoint.y *= tileSize;\n                    return collisionPoint;\n                }\n            } else {\n                maxY += deltaY;\n                testY += stepY;\n                var data = get( testX, testY );\n                if ( data != 0 ) {\n                    collisionPoint.y = testY;\n                    if ( stepY < 0 ) collisionPoint.y += 1.0; //add one if going up\n                    collisionPoint.x = p1.x + ratioX * ( collisionPoint.y - p1.y);\n                    collisionPoint.x *= tileSize;//scale up\n                    collisionPoint.y *= tileSize;\n                    return collisionPoint;\n                }\n            }\n    \n        }\n        //no intersection found, just return end point:\n        return null;\n    }\n\n}","\npackage ds;\n\ninterface DLLNode<T>\n{\n    var prev:T;\n    var next:T;\n}\n\nclass DLL<T:(DLLNode<T>)>\n{\n\n    public var head:T;\n    public var tail:T;\n\n    public var length:Int;\n\n    public function new() {\n        length = 0;\n    }\n\n    //Linked List Functions\n    public inline function insertAfter(node:T,newNode:T) {\n        length++;\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next==null)\n            tail = newNode;\n        else\n            node.next.prev = newNode;\n        node.next = newNode;\n    }\n\n    public inline function insertBefore(node:T,newNode:T) {\n        length++;\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev == null)\n            head = newNode;\n        else\n            node.prev.next = newNode;\n        node.prev = newNode;\n    }\n\n    public inline function insertBeginning(newNode:T) {\n        if (head == null) {\n            length++;\n            head = newNode;\n            tail = newNode;\n            newNode.prev = null;\n            newNode.next = null;\n        } else  \n            insertBefore(head, newNode);\n     }\n\n     public inline function insertEnd(newNode:T) {\n        if (tail == null)\n            insertBeginning(newNode);\n        else\n            insertAfter(tail, newNode);\n     }\n\n    public inline function remove(node:T):T {\n        length--;\n        var next = node.next;\n        if (node.prev == null)\n            head = node.next;\n        else\n            node.prev.next = node.next;\n        if (node.next == null)\n            tail = node.prev;\n        else\n            node.next.prev = node.prev;\n        node.prev = node.next = null;\n        return node;\n    }\n\n    //TODO Iterate,Sort\n\n}","package ds;\n\n/**\n * ...\n * @author rje\n */\n\nclass Grid2D<T>\n{\n\n\tpublic var data:Array<T>;\n\t\n\tpublic var gridWidth:Int;\n\tpublic var gridHeight:Int;\t\n\t\n\tpublic var cellSize:Int;\n\tpublic var invCellSize:Float;\n\t\n\t\n\tpublic function new(gridWidth:Int, gridHeight:Int, cellSize:Int) \n\t{\n\t\tinitalize(gridWidth, gridHeight, cellSize);\n\t}\n\t\n\tpublic function initalize(gridWidth:Int, gridHeight:Int, cellSize:Int):Void {\n\t\tthis.gridWidth = gridWidth;\n\t\tthis.gridHeight = gridHeight;\n\t\t\n\t\tthis.cellSize = cellSize;\n\t\tthis.invCellSize = 1 / cellSize;\n\t\t\n\t\tdata = new Array<T>();\t\t\n\t}\n\t\n\tinline public function GetGrid(x:Int, y:Int):T {\n\t\treturn data[y * gridWidth + x];\n\t}\n\t\n\tinline public function GetGridSafe(x:Int, y:Int):T {\n\t\treturn ((x >= gridWidth) || (y >= gridHeight) || (x < 0) || (y < 0)) ? null : data[y * gridWidth + x];\n\t}\t\n\t\n\tinline public function SetGrid(x:Int, y:Int, value:T):Void {\n\t\tdata[y * gridWidth + x] = value;\n\t}\n\t\n\tinline public function Index(value:Float):Int {\n\t\t//FIXME Not sure this always works...\n\t\t//return Std.int(value / cellSize);\n\t\t//return Math.floor(value * invCellSize);\n\t\treturn Std.int(value * invCellSize);\n\t}\t\n\t\n\tinline public function Width():Int {\n\t\treturn gridWidth * cellSize;\n\t}\t\n\t\n\tinline public function Height():Int {\n\t\treturn gridHeight * cellSize;\n\t}\n\t\n}\n\nclass Grid2DIterator<T> {\n\t\n\tpublic function new() {\n\t\t\n\t}\n\t\n}","package ds;\n\n/**\n * ...\n * @author rje\n */\n\nclass IDManager \n{\n\n\tstatic var NEXT_PERSISTENT_ID:Int = 0;\n\t\n\tstatic var TRANSIENT_START_ID:Int = 10000;\n\t\n\tstatic var TRANSIENT_CACHE_LENGTH:Int = 10000;\n\t\n\tstatic var TRANSIENT_CACHE:Array<Int> = {\n\t\tvar cache = new Array<Int>();\n\t\tfor (i in 0...TRANSIENT_CACHE_LENGTH) {\n\t\t\tcache.push(TRANSIENT_START_ID + i);\n\t\t}\n\t\tcache;\n    } \n\t\n\tstatic var TRANSIENT_POINTER:Int = 0;\n\t\n\tpublic static function GetPersistentID():Int {\n\t\treturn NEXT_PERSISTENT_ID++;\n\t}\n\t\n\tpublic static function GetTransientID():Int {\n\t\tvar id:Int = TRANSIENT_CACHE[TRANSIENT_POINTER];\n\t\t//trace(id);\n\t\tTRANSIENT_CACHE[TRANSIENT_POINTER] = 0;\n\t\tTRANSIENT_POINTER++;\n\t\t//trace(\"Allocated:\" + id + \" at position \" + TRANSIENT_POINTER);\n\t\treturn id;\n\t}\n\t\n\tpublic static function ReleaseTransientID(id:Int):Void {\n\t\tTRANSIENT_POINTER--;\n\t\tTRANSIENT_CACHE[TRANSIENT_POINTER] = id;\n\t\t//trace(\"Returned:\" + id + \" at position \" +TRANSIENT_POINTER);\n\t}\n\t\n}","/*\n * This file is part of the AABBTree library for haxe (https://github.com/azrafe7/AABBTree).\n *\n * Developed by Giuseppe Di Mauro (aka azrafe7) and realeased under the MIT license (see LICENSE file).\n */\n\npackage ds.aabbtree;\n\n\nimport ds.AABB;\n\n\ninterface IDebugRenderer<T>\n{\n\tfunction drawAABB(aabb:AABB, isLeaf:Bool, level:Int):Void;\n\t\n\tfunction drawNode(node:Node<T>, isLeaf:Bool, level:Int):Void;\n\t\n\tfunction drawTree(tree:AABBTree<T>):Void;\n}\n\n/**\n * Extend this class and override its methods to implement a custom AABBTree renderer.\n * \n * @author azrafe7\n */\nclass DebugRenderer<T> implements IDebugRenderer<T>\n{\n\n\tpublic function new() \n\t{\n\t\t\n\t}\n\t\n\t/** Draw the `aabb`. `isLeaf` will be true if the `aabb` belongs to a leaf node. `level` will be zero if `node` is the root (> 0 otherwise).*/\n\tpublic function drawAABB(aabb:AABB, isLeaf:Bool, level:Int):Void\n\t{\n\t\t\n\t}\n\t\n\t/** Draw a `node`. `isLeaf` will be true if `node` is a leaf node. `level` will be zero if `node` is the root (> 0 otherwise). */\n\tpublic function drawNode(node:Node<T>, isLeaf:Bool, level:Int):Void\n\t{\n\t\tdrawAABB(node.aabb, node.isLeaf(), level);\n\t}\n\t\n\t/** Draw the whole `tree` (level-wise, starting from the root). */\n\tpublic function drawTree(tree:AABBTree<T>):Void\n\t{\n\t\tif (tree.root == null) return;\n\t\t\n\t\tvar height = tree.height;\n\t\tvar stack = [tree.root];\n\t\twhile (stack.length > 0) {\n\t\t\tvar node = stack.pop();\n\t\t\tif (!node.isLeaf()) {\n\t\t\t\tstack.push(node.left);\n\t\t\t\tstack.push(node.right);\n\t\t\t}\n\t\t\tdrawNode(node, node.isLeaf(), height - node.invHeight);\n\t\t}\n\t}\n}","/*\n * This file is part of the AABBTree library for haxe (https://github.com/azrafe7/AABBTree).\n *\n * Developed by Giuseppe Di Mauro (aka azrafe7) and realeased under the MIT license (see LICENSE file).\n */\n\npackage ds.aabbtree;\n\nimport ds.aabbtree.IInsertStrategy.InsertChoice;\n\n\n/**\n * Choose best node based on perimeter.\n * \n * @author azrafe7\n */\nclass InsertStrategyPerimeter<T> implements IInsertStrategy<T>\n{\n\tvar combinedAABB = new AABB();\n\t\n\tpublic function new() {}\n\t\n\tpublic function choose<T>(leafAABB:AABB, parent:Node<T>, ?extraData:Dynamic):InsertChoice\n\t{\n\t\tvar left = parent.left;\n\t\tvar right = parent.right;\n\t\tvar perimeter = parent.aabb.getPerimeter();\n\n\t\tcombinedAABB.asUnionOf(parent.aabb, leafAABB);\n\t\tvar combinedPerimeter = combinedAABB.getPerimeter();\n\n\t\t// cost of creating a new parent for this node and the new leaf\n\t\tvar costParent = 2 * combinedPerimeter;\n\n\t\t// minimum cost of pushing the leaf further down the tree\n\t\tvar costDescend = 2 * (combinedPerimeter - perimeter);\n\n\t\t// cost of descending into left node\n\t\tcombinedAABB.asUnionOf(leafAABB, left.aabb);\n\t\tvar costLeft = combinedAABB.getPerimeter() + costDescend;\n\t\tif (!left.isLeaf()) {\n\t\t\tcostLeft -= left.aabb.getPerimeter();\n\t\t}\n\n\t\t// cost of descending into right node\n\t\tcombinedAABB.asUnionOf(leafAABB, right.aabb);\n\t\tvar costRight = combinedAABB.getPerimeter() + costDescend;\n\t\tif (!right.isLeaf()) {\n\t\t\tcostRight -= right.aabb.getPerimeter();\n\t\t}\n\n\t\t// break/descend according to the minimum cost\n\t\tif (costParent < costLeft && costParent < costRight) {\n\t\t\treturn InsertChoice.PARENT;\n\t\t}\n\n\t\t// descend\n\t\treturn costLeft < costRight ? InsertChoice.DESCEND_LEFT : InsertChoice.DESCEND_RIGHT;\n\t}\n}","/*\n * This file is part of the AABBTree library for haxe (https://github.com/azrafe7/AABBTree).\n * \n * Developed by Giuseppe Di Mauro (aka azrafe7) and realeased under the MIT license (see LICENSE file).\n * \n * The code is heavily inspired by the implementations of a dynamic AABB tree by \n * \n *  - Nathanael Presson \t(Bullet Physics - http://bulletphysics.org)\n *\t- Erin Catto \t\t\t(Box2D - http://www.box2d.org)\n */\n\npackage ds.aabbtree;\n\n/**\n * Node class used by AABBTree.\n * \n * @author azrafe7\n */\n@:publicFields\nclass Node<T> \n{\n\tvar left:Node<T> = null;\n\tvar right:Node<T> = null;\n\tvar parent:Node<T> = null;\n\t\n\t// fat AABB\n\tvar aabb:AABB;\n\t\n\t// 0 for leafs\n\tvar invHeight:Int = -1;\n\t\n\tvar data:T;\n\t\n\tvar id:Int = -1;\n\t\n\tfunction new(aabb:AABB, data:T, parent:Node<T> = null, id:Int = -1)\n\t{\n\t\tthis.aabb = aabb;\n\t\tthis.data = data;\n\t\tthis.parent = parent;\n\t\tthis.id = id;\n\t}\n\t\n\t/** If it's a leaf both left and right nodes should be null. */\n\tinline function isLeaf():Bool\n\t{\n\t\treturn left == null;\n\t}\n}\n","/*\n * This file is part of the AABBTree library for haxe (https://github.com/azrafe7/AABBTree).\n * \n * Developed by Giuseppe Di Mauro (aka azrafe7) and realeased under the MIT license (see LICENSE file).\n * \n * The code is heavily inspired by the implementations of a dynamic AABB tree by \n * \n *  - Nathanael Presson \t(Bullet Physics - http://bulletphysics.org)\n *\t- Erin Catto \t\t\t(Box2D - http://www.box2d.org)\n */\n\npackage ds.aabbtree;\n\n/**\n * Node pool used by AABBTree.\n * \n * @author azrafe7\n */\n@:publicFields\nclass NodePool<T>\n{\n\t/** The pool will grow by this factor when it's empty. */\n\tvar growthFactor:Float;\n\t\n\t/** Initial capacity of the pool. */\n\tvar capacity:Int;\n\t\n\tvar freeNodes:Array<Node<T>>;\n\t\n\t\n\tfunction new(capacity:Int, growthFactor:Float = 2)\n\t{\n\t\tthis.capacity = capacity;\n\t\tthis.growthFactor = growthFactor;\n\t\tfreeNodes = new Array<Node<T>>();\n\t\tfor (i in 0...capacity) freeNodes.push(new Node(new AABB(), null));\n\t}\n\t\n\t/** Fetches a node from the pool (if available) or creates a new one. */\n\tfunction get(x:Float, y:Float, width:Float = 0, height:Float = 0, ?data:T, parent:Node<T> = null, id:Int = -1):Node<T>\n\t{\n\t\tvar newNode:Node<T>;\n\t\t\n\t\tif (freeNodes.length > 0) {\n\t\t\tnewNode = freeNodes.pop();\n\t\t\tnewNode.aabb.setTo(x, y, width, height);\n\t\t\tnewNode.data = data;\n\t\t\tnewNode.parent = parent;\n\t\t\tnewNode.id = id;\n\t\t} else {\n\t\t\tnewNode = new Node(new AABB(x, y, width, height), data, parent, id);\n\t\t\tcapacity = Std.int(capacity * growthFactor);\n\t\t\tgrow(capacity);\n\t\t}\n\t\t\n\t\treturn newNode;\n\t}\n\t\n\t/** Reinserts an unused node into the pool (for future use). */\n\tfunction put(node:Node<T>):Void \n\t{\n\t\tfreeNodes.push(node);\n\t\tnode.parent = node.left = node.right = null;\n\t\tnode.id = -1;\n\t\tnode.invHeight = -1;\n\t\tnode.data = null;\n\t}\n\t\n\t/** Resets the pool to its capacity (removing all the other nodes). */\n\tfunction reset():Void \n\t{\n\t\tif (freeNodes.length > capacity) freeNodes.splice(capacity, freeNodes.length - capacity);\n\t}\n\t\n\t/** Grows the pool to contain `n` nodes. Nothing will be done if `n` is less than the current number of nodes. */\n\tfunction grow(n:Int):Void\n\t{\n\t\tvar len = freeNodes.length;\n\t\tif (n <= len) return;\n\t\t\n\t\tfor (i in len...n) {\n\t\t\tfreeNodes.push(new Node(new AABB(), null));\n\t\t}\n\t}\n}","\npackage eco.core;\n\nimport eco.core.System;\n\nclass ClassMap \n{\n    // Component String Name > [System,System]\n    private var map:Map<String,Array<System>>;\n\n    public function new() {\n        map = new Map<String,Array<System>>();\n    }\n\n    public function registerSystem(system:System) {\n        for (componentClass in system.registeredComponents) {\n            var className = Type.getClassName(componentClass);\n            if (!map.exists(className)) {\n                map.set(className,new Array<System>());\n            }\n            map.get(className).push(system);\n        }\n    }\n\n    public function componentAdded(e:Entity,c:Class<Component>) {\n        var className = Type.getClassName(c);\n        var systems = map.get(className);\n        if (systems!=null) {\n            for (system in systems) \n                system.componentAdded(e,c);\n        }\n\n    }\n\n    public function componentRemoved(e:Entity,c:Class<Component>) {\n        var className = Type.getClassName(c);\n        var systems = map.get(className);\n        if (systems!=null) {\n            for (system in systems) \n                system.componentRemoved(e,c);\n        }\n    }\n\n}","\npackage eco.core;\n\nimport eco.core.Entity;\n\n@:autoBuild(eco.core.ComponentBuilder.build())\n@:componentBase\n\nclass Component {\n\n    public var owner:Entity = null;\n    public var name (get, null):String;\n    public var started:Bool = false;\n    public var priority:Int;\n\n    public function onAdded() {\n    }\n\n    public function onRemoved() {\n    }\n\n    public function onStarted() {\n    }\n\n    public function update(time:Float) {\n    }\n\n    private function get_name ():String {\n        return null;\n    }\n\n}","\npackage eco.core;\n\nimport eco.core.ClassMap;\nimport eco.core.Component;\nimport eco.core.Entity;\nimport eco.core.System;\nimport eco.signals.Signal2;\nimport haxe.ds.HashMap;\n\nclass Engine \n{\n\n    public var entities:Array<Entity>;\n\n    public var systems:Array<System>;\n    public var systemMap:Map<String,System>;\n\n    public var componentSystemMap:ClassMap;\n\n    public var componentAdded(default, null):Signal2<Entity, Class<Component>>;\n    public var componentRemoved(default, null):Signal2<Entity, Class<Component>>;\n\n    public var componentPriorities:Map<String,Int>;\n\n    public var updating:Bool;\n\n    public function new() {\n\n        entities = new Array<Entity>();\n        systems = new Array<System>();\n\n        systemMap = new Map<String,System>();\n\n        componentSystemMap = new ClassMap();\n\n        componentAdded = new Signal2<Entity, Class<Component>>();\n        componentRemoved = new Signal2<Entity, Class<Component>>();\n\n        componentAdded.add(componentSystemMap.componentAdded);\n        componentRemoved.add(componentSystemMap.componentRemoved);\n\n        updating = false;\n\n        componentPriorities = new Map<String,Int>();\n\n    }\n\n    public function addEntity(entity:Entity) {\n        entities.push(entity);\n        entity.onAdded(this);\n    }\n\n    public function removeEntity(entity:Entity) {\n        var i = entities.indexOf(entity);\n        if (i>=0) {\n            entities.splice(i,1);\n            entity.onRemoved();\n        }\n    }\n\n    public function addSystem(system:System) {\n        systems.push(system);\n        systemMap.set(Type.getClassName(Type.getClass(system)),system);\n        componentSystemMap.registerSystem(system);\n        system.onAdded(this);\n    }\n\n    public function removeSystem(system:System) {\n        var i = systems.indexOf(system);\n        if (i>=0) {\n            systems.splice(i,1);\n            system.onRemoved();\n            systemMap.remove(Type.getClassName(Type.getClass(system)));\n        }\n    }\n\n    public function getSystemByClass(system:Class<System>):System {\n        return systemMap.get(Type.getClassName(system));\n    }\n\n    public function registerComponent(component:Class<Component>,priority:Int) {\n        var registeredName = Type.getClassName(component).split(\".\").pop();\n        componentPriorities.set(registeredName,priority);\n    }\n\n    public function setComponentPriority(component:Component) {\n        component.priority = componentPriorities.exists(component.name) ? componentPriorities.get(component.name) : 0;\n    }\n\n    public function update(time:Float) {\n        updating = true;\n        \n        for (system in systems)\n            system.update(time);\n\n        updating = false;\n        // updateComplete.dispatch();\n    }\n\n}","\npackage eco.core;\n\nimport eco.core.Component;\nimport eco.core.Entity;\nimport eco.signals.Signal2;\n\nclass Entity \n{\n\n    public var name:String;\n\n    public var components:Array<Component>;\n    public var componentMap:Dynamic<Component>;\n\n    public var engine:Engine;\n\n    public var events:Signal2<String,Dynamic>;\n\n    public function new(name:String = null) {\n        this.name = name;\n        components = [];\n        componentMap = {};\n        events = new Signal2<String,Dynamic>();\n    }\n\n    public function add(component:Component):Entity {\n        if (component.owner!=null) {\n            component.owner.remove(component);\n        }\n\n        var name = component.name;\n        var prev = getComponent(name);\n        if (prev != null) {\n            remove(prev);\n        }\n\n        untyped componentMap[name] = component;\n        components.push(component);\n\n        component.owner = this;\n        component.onAdded();\n\n        if (engine!=null) {\n            engine.setComponentPriority(component);\n            engine.componentAdded.dispatch(this,Type.getClass(component));\n            sortComponents();\n        }\n\n        return this;\n    }\n\n    public function remove(component:Component):Entity {\n        if (component.owner!=this)\n            return this;\n        untyped __js__(\"delete\")(componentMap[p.name]);\n        var i = components.indexOf(component);\n        if (i>=0)\n            components.splice(i,1);\n        return this;\n    }\n\n    public function onAdded(engine:Engine) {\n        this.engine = engine;\n        for (component in components) {\n            engine.setComponentPriority(component);\n            engine.componentAdded.dispatch(this,Type.getClass(component));\n        }\n        sortComponents();\n    }\n\n    public function onRemoved() {\n        for (component in components) {\n            engine.componentRemoved.dispatch(this,Type.getClass(component));\n        }        \n        \n        this.engine = null;\n    }\n\n    public function update(time:Float) {\n        for (component in components) {\n            if (!component.started) {\n                component.started = true;\n                component.onStarted();\n            }\n            component.update(time);\n        }\n    }\n\n    public function sortComponents() {\n        components.sort(function(a:Component,b:Component):Int {\n            return b.priority - a.priority;\n        });\n    }\n\n    public inline function getComponent(name:String):Component {\n        return untyped componentMap[name];\n    }\n\n    public inline function getComponentByClass(component:Class<Component>):Component {\n        return untyped componentMap[component.NAME];\n    }\n\n    public function registerEvent(type:String,listener:Dynamic->Void) {\n        \n    }\n\n    public static function Create(components:Array<Component>):Entity {\n        var entity = new Entity();\n        for (component in components)\n            entity.add(component);\n        return entity;\n    }\n\n}","\npackage eco.core;\n\nclass System \n{\n\n    public var engine:Engine;\n\n    public var registeredComponents (get, null):Array<Class<Component>>;\n\n    public function new () {\n    }\n\n    public function get_registeredComponents ():Array<Class<Component>> {\n        return [];\n    }\n\n    public function onAdded(engine:Engine) {\n        this.engine = engine;\n    }\n\n    public function onRemoved() {\n\n    }\n\n    public function componentAdded(e:Entity,c:Class<Component>) {\n    }\n\n    public function componentRemoved(e:Entity,c:Class<Component>) {\n    }\n\n    public function update(time:Float) {\n    }\n\n}","package eco.signals;\n\n/**\n * A node in the list of listeners in a signal.\n */\nclass ListenerNode<TListener>\n{\n    public var previous:ListenerNode<TListener>;\n    public var next:ListenerNode<TListener>;\n    public var listener:TListener;\n    public var once:Bool;\n\n    public function new()\n    {\n    }\n}\n","package eco.signals;\n\n/**\n * This internal class maintains a pool of deleted listener nodes for reuse by framework. This reduces\n * the overhead from object creation and garbage collection.\n */\nclass ListenerNodePool<TListener>\n{\n    private var tail:ListenerNode<TListener>;\n    private var cacheTail:ListenerNode<TListener>;\n\n    public function new()\n    {\n    }\n\n    public function get():ListenerNode<TListener>\n    {\n        if (tail != null)\n        {\n            var node:ListenerNode<TListener> = tail;\n            tail = tail.previous;\n            node.previous = null;\n            return node;\n        }\n        else\n        {\n            return new ListenerNode<TListener>();\n        }\n    }\n\n    public function dispose(node:ListenerNode<TListener>):Void\n    {\n        node.listener = null;\n        node.once = false;\n        node.next = null;\n        node.previous = tail;\n        tail = node;\n    }\n\n    public function cache(node:ListenerNode<TListener>):Void\n    {\n        node.listener = null;\n        node.previous = cacheTail;\n        cacheTail = node;\n    }\n\n    public function releaseCache():Void\n    {\n        while (cacheTail != null)\n        {\n            var node:ListenerNode<TListener> = cacheTail;\n            cacheTail = node.previous;\n            node.next = null;\n            node.previous = tail;\n            tail = node;\n        }\n    }\n}\n","/*\n * Based on ideas used in Robert Penner's AS3-signals - https://github.com/robertpenner/as3-signals\n */\npackage eco.signals;\n\n/**\n * The base class for all the signal classes.\n */\n@:autoBuild(eco.signals.SignalMacro.build())\nclass SignalBase<TListener>\n{\n    public var head:ListenerNode<TListener>;\n    public var tail:ListenerNode<TListener>;\n\n    public var numListeners(default, null):Int;\n\n    private var listenerNodePool:ListenerNodePool<TListener>;\n    private var toAddHead:ListenerNode<TListener>;\n    private var toAddTail:ListenerNode<TListener>;\n    private var dispatching:Bool;\n\n    public function new()\n    {\n        listenerNodePool = new ListenerNodePool();\n        numListeners = 0;\n    }\n\n    private function startDispatch():Void\n    {\n        dispatching = true;\n    }\n\n    private function endDispatch():Void\n    {\n        dispatching = false;\n        if (toAddHead != null)\n        {\n            if (head == null)\n            {\n                head = toAddHead;\n                tail = toAddTail;\n            }\n            else\n            {\n                tail.next = toAddHead;\n                toAddHead.previous = tail;\n                tail = toAddTail;\n            }\n            toAddHead = null;\n            toAddTail = null;\n        }\n        listenerNodePool.releaseCache();\n    }\n\n    private inline function getNode(listener:TListener):ListenerNode<TListener>\n    {\n        var node:ListenerNode<TListener> = head;\n        while (node != null)\n        {\n            if (Reflect.compareMethods(node.listener, listener))\n                break;\n            node = node.next;\n        }\n\n        if (node == null)\n        {\n            node = toAddHead;\n            while (node != null)\n            {\n                if (Reflect.compareMethods(node.listener, listener))\n                    break;\n                node = node.next;\n            }\n        }\n\n        return node;\n    }\n\n    private inline function nodeExists(listener:TListener):Bool\n    {\n        return getNode(listener) != null;\n    }\n\n    public function add(listener:TListener):Void\n    {\n        if (nodeExists(listener))\n            return;\n\n        var node:ListenerNode<TListener> = listenerNodePool.get();\n        node.listener = listener;\n        addNode(node);\n    }\n\n    public function addOnce(listener:TListener):Void\n    {\n        if (nodeExists(listener))\n            return;\n\n        var node:ListenerNode<TListener> = listenerNodePool.get();\n        node.listener = listener;\n        node.once = true;\n        addNode(node);\n    }\n\n    private function addNode(node:ListenerNode<TListener>):Void\n    {\n        if (dispatching)\n        {\n            if (toAddHead == null)\n            {\n                toAddHead = toAddTail = node;\n            }\n            else\n            {\n                toAddTail.next = node;\n                node.previous = toAddTail;\n                toAddTail = node;\n            }\n        }\n        else\n        {\n            if (head == null)\n            {\n                head = tail = node;\n            }\n            else\n            {\n                tail.next = node;\n                node.previous = tail;\n                tail = node;\n            }\n        }\n        numListeners++;\n    }\n\n    public function remove(listener:TListener):Void\n    {\n        var node:ListenerNode<TListener> = getNode(listener);\n        if (node != null)\n        {\n            if (head == node)\n                head = head.next;\n            if (tail == node)\n                tail = tail.previous;\n            if (toAddHead == node)\n                toAddHead = toAddHead.next;\n            if (toAddTail == node)\n                toAddTail = toAddTail.previous;\n            if (node.previous != null)\n                node.previous.next = node.next;\n            if (node.next != null)\n                node.next.previous = node.previous;\n\n            if (dispatching)\n                listenerNodePool.cache(node);\n            else\n                listenerNodePool.dispose(node);\n\n            numListeners--;\n        }\n    }\n\n    public function removeAll():Void\n    {\n        while (head != null)\n        {\n            var node:ListenerNode<TListener> = head;\n            head = head.next;\n            listenerNodePool.dispose(node);\n        }\n        tail = null;\n        toAddHead = null;\n        toAddTail = null;\n        numListeners = 0;\n    }\n}\n","package eco.signals;\n\n/**\n * Provides a fast signal for use where no parameters are dispatched with the signal.\n */\nclass Signal0 extends SignalBase<Void->Void> {}\n","package eco.signals;\n\n#if macro\nimport haxe.macro.Context;\nimport haxe.macro.Expr;\nimport haxe.macro.Type;\n\nclass SignalMacro\n{\n    public static function build():Array<Field>\n    {\n        var fields = Context.getBuildFields();\n        var cls:ClassType = Context.getLocalClass().get();\n\n        var signature = switch(cls.superClass.params[0])\n        {\n            case TFun(args, _):\n                args;\n            default:\n                throw new Error(\"Invalid signal type parameter\", cls.pos);\n        }\n\n        var arguments:Array<FunctionArg> = [];\n        var callArgs:Array<Expr> = [];\n        var i = 0;\n        for (argDef in signature)\n        {\n            i++;\n            var name = 'object$i';\n            arguments.push({\n                name: name,\n                opt: argDef.opt,\n                type: haxe.macro.TypeTools.toComplexType(argDef.t)\n            });\n            callArgs.push(macro $i{name});\n        }\n\n        fields.push({\n            name: \"dispatch\",\n            access: [APublic],\n            meta: [],\n            kind: FFun({\n                args: arguments,\n                ret: macro : Void,\n                expr: macro {\n                    startDispatch();\n                    var node = head;\n                    while (node != null)\n                    {\n                        node.listener($a{callArgs});\n                        if (node.once)\n                            remove(node.listener);\n                        node = node.next;\n                    }\n                    endDispatch();\n                },\n                params: [],\n            }),\n            pos: cls.pos\n        });\n\n        return fields;\n    }\n}\n#end","package eco.signals;\n\n/**\n * Provides a fast signal for use where two parameters are dispatched with the signal.\n */\nclass Signal2<T1, T2> extends SignalBase<T1->T2->Void> {}\n","\npackage eco.systems;\n\nimport eco.core.Entity;\nimport eco.core.System;\n\nclass EntityUpdater extends System\n{\n    \n    public var entities:Array<Entity>;\n\n    public function new(entities:Array<Entity>) {\n        super();\n        this.entities = entities;\n    }\n\n    override public function update(time:Float) {\n        for (entity in entities)\n            entity.update(time);\n    }\n\n\n}","package engine;\n\nimport engine.input.DigitalInput;\nimport js.Browser;\nimport wgr.renderers.webgl.WebGLRenderer;\n\nclass GameLoop \n{\n\n    public var renderer:WebGLRenderer;\n    public var isRunning:Bool;\n    public var animationStartTimestamp:Float;\n    public var prevAnimationTime:Float;\n    public var delta:Float;\n    private var rafID:Int;\n\n    public var updateFunc:Float->Void;\n\n    public function new() {\n        isRunning = false;\n    }\n\n    public function update(timestamp:Float):Bool {\n        //Do stuff\n        delta = timestamp - prevAnimationTime;\n        prevAnimationTime = timestamp;\n        if (updateFunc!=null)\n            updateFunc(delta);\n        rafID = Browser.window.requestAnimationFrame(update);\n        return false;\n    }\n\n    public function start() {\n        if (isRunning==true)\n            return;\n        isRunning = true;\n        prevAnimationTime = animationStartTimestamp = Browser.window.performance.now();\n        rafID = Browser.window.requestAnimationFrame(update);\n    }\n\n    public function stop() {\n        if (isRunning==false)\n            return;\n        isRunning = false;\n        Browser.window.cancelAnimationFrame(rafID);\n    }\n\n}","package engine.ai.behaviors;\n\nclass Behavior\n{\n\n\t/**\n\t * The current status of the behavior\n\t */\n\tprivate var status(default, null):BehaviorStatus;\n\n\t/**\n\t * Behavior constructor\n\t */\n\tpublic function new()\n\t{\n\t\tstatus = Invalid;\n\t}\n\n\t/**\n\t * Called when the behavior initializes (should be overridden in sub classes)\n\t */\n\tprivate function initialize(context:BehaviorContext):Void { }\n\t/**\n\t * Called when the behavior terminates (should be overridden in sub classes)\n\t * @param status the status causing termination\n\t */\n\tprivate function terminate(status:BehaviorStatus):Void { }\n\t/**\n\t * Called when the behavior updates (should be overridden in sub classes)\n\t * @return The behavior status from that update\n\t */\n\tprivate function update(context:BehaviorContext):BehaviorStatus { return status; }\n\n\t/**\n\t * Specifies if the behavior is terminated\n\t */\n\tpublic var terminated(get, never):Bool;\n\tprivate inline function get_terminated():Bool\n\t{\n\t\treturn status == Success || status == Failure;\n\t}\n\n\t/**\n\t * Specifies if the behavior is running\n\t */\n\tpublic var running(get, never):Bool;\n\tprivate inline function get_running():Bool\n\t{\n\t\treturn status == Running;\n\t}\n\n\t/**\n\t * Resets the behavior\n\t */\n\tpublic function reset():Void\n\t{\n\t\tstatus = Invalid;\n\t}\n\n\t/**\n\t * Aborts the behavior\n\t */\n\tpublic function abort():Void\n\t{\n\t\tterminate(Aborted);\n\t\tstatus = Aborted;\n\t}\n\n\t/**\n\t * Advances the behavior logic (initializes, updates, and terminates when necessary)\n\t * @return The behavior status\n\t */\n\tpublic function tick(context:BehaviorContext):BehaviorStatus\n\t{\n\t\tif (status != Running)\n\t\t{\n\t\t\tinitialize(context);\n\t\t}\n\n\t\tstatus = update(context);\n\n\t\tif (status != Running)\n\t\t{\n\t\t\tterminate(status);\n\t\t}\n\n\t\treturn status;\n\t}\n\n}\n","package engine.ai.behaviors;\n\n/**\n * An action specifies a function to be called when updating\n */\nclass Action extends Behavior\n{\n\n\t/**\n\t * Action constructor\n\t * @param action the callback method when this behavior runs\n\t */\n\tpublic function new(action:String)\n\t{\n\t\tsuper();\n\t\tthis.action = action;\n\t}\n\n\toverride public function update(context:Dynamic):BehaviorStatus\n\t{\n\t\tvar f = Reflect.field(context, action);\n\t\tif (Reflect.isFunction(f))\n\t\t{\n\t\t\tvar result = Reflect.callMethod(context, f, []);\n\t\t\tif (Std.is(result, BehaviorStatus))\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn Failure;\n\t}\n\n\tprivate var action:String;\n\n}\n","package engine.ai.behaviors;\n\n/**\n * A composite is a collection of behaviors\n */\nclass Composite extends Behavior\n{\n\n\t/**\n\t * Composite constructor\n\t */\n\tpublic function new()\n\t{\n\t\tsuper();\n\t\tchildren = new List<Behavior>();\n\t}\n\n\t/**\n\t * Adds a child behavior to the composite\n\t * @param child The behavior to add\n\t */\n\tpublic inline function addChild(child:Behavior)\n\t{\n\t\tchildren.add(child);\n\t}\n\n\t/**\n\t * Removes a child behavior from the composite\n\t * @param child The behavior to remove\n\t */\n\tpublic inline function removeChild(child:Behavior)\n\t{\n\t\tchildren.remove(child);\n\t}\n\n\t/**\n\t * Removes all children from the composite\n\t */\n\tpublic inline function removeAll()\n\t{\n\t\tchildren.clear();\n\t}\n\n\tprivate var children:List<Behavior>;\n\n}\n","package engine.ai.behaviors;\n\n/**\n * A selector chooses the first behavior that doesn't fail\n */\nclass Selector extends Composite\n{\n\n\toverride private function initialize(context:BehaviorContext)\n\t{\n\t\t_current = children.iterator();\n\t\t_currentBehavior = _current.next();\n\t}\n\n\toverride private function update(context:BehaviorContext):BehaviorStatus\n\t{\n\t\twhile (_currentBehavior != null)\n\t\t{\n\t\t\tvar status = _currentBehavior.tick(context);\n\n\t\t\tif (status != Failure)\n\t\t\t{\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tif (_current.hasNext())\n\t\t\t{\n\t\t\t\t_currentBehavior = _current.next();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Failure;\n\t}\n\n\tprivate var _current:Iterator<Behavior>;\n\tprivate var _currentBehavior:Behavior;\n\n}\n","package engine.ai.behaviors;\n\n/**\n * An active selector\n */\nclass ActiveSelector extends Selector\n{\n\n\toverride private function initialize(context:BehaviorContext)\n\t{\n\t\t// get last iterator value\n\t\t_current = children.iterator();\n\t\twhile (_current.hasNext())\n\t\t{\n\t\t\t_currentBehavior = _current.next();\n\t\t}\n\t}\n\n\toverride private function update(context:BehaviorContext):BehaviorStatus\n\t{\n\t\tvar previousBehavior:Behavior = _currentBehavior;\n\n\t\tsuper.initialize(context);\n\t\tvar result = super.update(context);\n\n\t\tif (_currentBehavior != previousBehavior)\n\t\t{\n\t\t\tpreviousBehavior.terminate(Aborted);\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n","\npackage engine.ai.behaviors;\n\nimport eco.core.Entity;\nimport eco.signals.Signal0;\n\nclass BehaviorContext \n{\n\n    public var entity:Entity;\n\n    public var data:Map<String,Dynamic>;\n\n    public var event:Signal0;\n\n    public var time:Float;\n\n    public function new(entity:Entity) {\n        this.entity = entity;\n        this.time = 0;\n    }\n\n}","package engine.ai.behaviors;\n\nimport engine.ai.behaviors.Parallel;\n\n/**\n * Behavior tree generator\n */\nclass BehaviorTree\n{\n\n\t/**\n\t * Generate a behavior tree from an xml string\n\t * @param xmlData the xml data string to parse\n\t */\n\tpublic static function fromXml(xmlData:String):Selector\n\t{\n\t\tvar xml = Xml.parse(xmlData);\n\t\tvar selector = new Selector();\n\t\tif (xml != null)\n\t\t{\n\t\t\txml = xml.firstElement();\n\t\t\tcompositeFromXml(xml, selector);\n\t\t}\n\t\treturn selector;\n\t}\n\n\tprivate static function compositeFromXml(xml:Xml, composite:Composite)\n\t{\n\t\tfor (element in xml.elements())\n\t\t{\n\t\t\tcomposite.addChild(behaviorFromXml(element));\n\t\t}\n\t}\n\n\tprivate static function behaviorFromXml(xml:Xml):Behavior\n\t{\n\t\tswitch (xml.nodeName)\n\t\t{\n\t\t\tcase \"action\":\n\t\t\t\treturn new Action(xml.firstChild().nodeValue);\n\t\t\tcase \"sequence\":\n\t\t\t\tvar sequence = new Sequence();\n\t\t\t\tcompositeFromXml(xml, sequence);\n\t\t\t\treturn sequence;\n\t\t\tcase \"parallel\":\n\t\t\t\tvar success = xml.exists(\"success\") ? policyFromString(xml.get(\"success\")) : RequireOne;\n\t\t\t\tvar failure = xml.exists(\"failure\") ? policyFromString(xml.get(\"failure\")) : RequireOne;\n\t\t\t\tvar parallel = new Parallel(success, failure);\n\t\t\t\tcompositeFromXml(xml, parallel);\n\t\t\t\treturn parallel;\n\t\t\tcase \"repeat\":\n\t\t\t\tvar behavior = behaviorFromXml(xml.firstElement());\n\t\t\t\tvar count = xml.exists(\"count\") ? Std.parseInt(xml.get(\"count\")) : 1;\n\t\t\t\tvar repeat = new Repeat(behavior, count);\n\t\t\t\treturn repeat;\n\t\t\tcase \"active\":\n\t\t\t\tvar active = new ActiveSelector();\n\t\t\t\tcompositeFromXml(xml, active);\n\t\t\t\treturn active;\n\t\t\tcase \"selector\":\n\t\t\t\tvar selector = new Selector();\n\t\t\t\tcompositeFromXml(xml, selector);\n\t\t\t\treturn selector;\n\t\t\tdefault:\n\t\t\t\tthrow \"Unrecognized behavior type : \" + xml.nodeName;\n\t\t}\n\t}\n\n\tprivate static function policyFromString(policy:String):Policy\n\t{\n\t\tswitch (policy)\n\t\t{\n\t\t\tcase \"one\":\n\t\t\t\treturn RequireOne;\n\t\t\tcase \"all\":\n\t\t\t\treturn RequireAll;\n\t\t\tdefault:\n\t\t\t\tthrow \"Invalid policy, expected `one` or `all`.\";\n\t\t}\n\t}\n\n}\n","package engine.ai.behaviors;\n\n/**\n * A decorator contains a single behavior\n */\nclass Decorator extends Behavior\n{\n\n\tpublic function new(child:Behavior)\n\t{\n\t\tsuper();\n\t\tthis.child = child;\n\t}\n\n\tprivate var child:Behavior;\n\n}","package engine.ai.behaviors;\n\n/**\n * List of policy types\n */\nenum Policy\n{\n\tRequireOne; /** only requires one behavior to succeed or fail **/\n\tRequireAll; /** requires all behaviors to succeed or fail **/\n}\n\n/**\n * A parallel node processes all child behaviors at once and returns based on the policies provided\n */\nclass Parallel extends Composite\n{\n\n\t/**\n\t * Parallel constructor\n\t * @param success The policy for success\n\t * @param failure The policy for failure\n\t */\n\tpublic function new(success:Policy, failure:Policy)\n\t{\n\t\tsuper();\n\t\t_successPolicy = success;\n\t\t_failurePolicy = failure;\n\t}\n\n\toverride private function update(context:BehaviorContext):BehaviorStatus\n\t{\n\t\tvar successCount:Int = 0,\n\t\t\tfailureCount:Int = 0;\n\n\t\tfor (child in children)\n\t\t{\n\t\t\tif (!child.terminated)\n\t\t\t{\n\t\t\t\tchild.tick(context);\n\t\t\t}\n\n\t\t\tswitch (child.status)\n\t\t\t{\n\t\t\t\tcase Success:\n\t\t\t\t\tsuccessCount += 1;\n\t\t\t\t\tif (_successPolicy == RequireOne)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn Success;\n\t\t\t\t\t}\n\t\t\t\tcase Failure:\n\t\t\t\t\tfailureCount += 1;\n\t\t\t\t\tif (_failurePolicy == RequireOne)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn Failure;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\n\t\tif (_failurePolicy == RequireAll && failureCount == children.length)\n\t\t{\n\t\t\treturn Failure;\n\t\t}\n\n\t\tif (_successPolicy == RequireAll && successCount == children.length)\n\t\t{\n\t\t\treturn Success;\n\t\t}\n\n\t\treturn Running;\n\t}\n\n\toverride private function terminate(status:BehaviorStatus)\n\t{\n\t\tfor (child in children)\n\t\t{\n\t\t\tif (child.running)\n\t\t\t{\n\t\t\t\tchild.abort();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate var _successPolicy:Policy;\n\tprivate var _failurePolicy:Policy;\n\n}\n","package engine.ai.behaviors;\n\n/**\n * A repeat node will rerun the same behavior up to a certain number of iterations\n */\nclass Repeat extends Decorator\n{\n\n\t/**\n\t * The number of times to repeat the behavior action\n\t */\n\tpublic var count:Int = 0;\n\n\t/**\n\t * Repeat constructor\n\t * @param child The behavior to repeat\n\t * @param count The number of times to repeat\n\t */\n\tpublic function new(child:Behavior, count:Int = 0)\n\t{\n\t\tsuper(child);\n\t\tthis.count = count;\n\t}\n\n\toverride private function initialize(context:BehaviorContext)\n\t{\n\t\t_counter = 0;\n\t}\n\n\toverride private function update(context:BehaviorContext):BehaviorStatus\n\t{\n\t\twhile(true)\n\t\t{\n\t\t\tswitch (child.tick(context))\n\t\t\t{\n\t\t\t\tcase Running:\n\t\t\t\t\tbreak;\n\t\t\t\tcase Failure:\n\t\t\t\t\treturn Failure;\n\t\t\t\tdefault:\n\t\t\t\t\tif (++_counter == count) return Success;\n\t\t\t}\n\t\t\tchild.reset();\n\t\t}\n\t\treturn Invalid;\n\t}\n\n\tprivate var _counter:Int = 0;\n\n}\n","package engine.ai.behaviors;\n\n/**\n * A sequence handles behaviors in order and continues until one does not succeed\n */\nclass Sequence extends Composite\n{\n\n\toverride private function initialize(context:BehaviorContext)\n\t{\n\t\t_current = children.iterator();\n\t\t_currentBehavior = _current.next();\n\t}\n\n\toverride private function update(context:BehaviorContext):BehaviorStatus\n\t{\n\t\twhile (_currentBehavior != null)\n\t\t{\n\t\t\tvar status = _currentBehavior.tick(context);\n\n\t\t\t// if the child fails, or keeps running, do the same.\n\t\t\tif (status != Success)\n\t\t\t{\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tif (_current.hasNext())\n\t\t\t{\n\t\t\t\t_currentBehavior = _current.next();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Success;\n\t}\n\n\tprivate var _current:Iterator<Behavior>;\n\tprivate var _currentBehavior:Behavior;\n\n}\n","\npackage engine.ai.behaviors.actions;\n\nimport engine.ai.behaviors.Behavior;\nimport engine.ai.behaviors.BehaviorContext;\n\nclass Delay extends Behavior\n{\n\n    private var delay:Float;\n    private var elapsed:Float;\n\n    public function new(delay:Float) {\n        super();\n        this.delay = delay;\n    }\n\n    override private function initialize(context:BehaviorContext):Void {\n        trace(\"initalize\");\n        elapsed = 0;\n    }\n\n    override private function terminate(status:BehaviorStatus):Void { \n        trace(\"terminate:\"+status);\n    }\n\n    override private function update(context:BehaviorContext):BehaviorStatus { \n        elapsed+=context.time;\n        if (elapsed>delay) {\n            return Success;\n        }\n        return Running;\n    }\n\n}","\npackage engine.ai.behaviors.actions;\n\nimport engine.ai.behaviors.Behavior;\nimport engine.components.Physics;\nimport engine.ds.EntityCollection;\nimport engine.systems.PhysicsSystem;\nimport physics.dynamics.Body;\nimport physics.PhysicsEngine;\n\nclass GetLocalEntities extends Behavior\n{\n\n    public var range:Float;\n    private var physicsEngine:PhysicsEngine;\n    private var physics:Physics;\n\n    public var entityCollection:EntityCollection;\n\n    public function new(range:Float) {\n        super();\n        this.range = range;\n        this.entityCollection = new EntityCollection();\n    }\n\n    override private function initialize(context:BehaviorContext):Void {\n        //js.Lib.debug();\n        var physicsSystem:PhysicsSystem = cast context.entity.engine.getSystemByClass(PhysicsSystem);\n        physicsEngine = physicsSystem.physicsEngine;\n        physics = cast context.entity.getComponentByClass(Physics);\n    }\n\n    override private function update(context:BehaviorContext):BehaviorStatus { \n        //js.Lib.debug();\n        entityCollection.clear();\n        physicsEngine.Search( physics.body.position , range, BodyToEntityCollection);\n        //physicsEngine.actionResultCollection.RemoveBody(physics.body);\n        if(entityCollection.length>0) {\n            trace(\"Found items=\"+entityCollection.length);\n            return Success;\n        }\n        return Failure;\n    }\n\n    private function BodyToEntityCollection(body:Body,distanceSqrd:Float):Void {\n        trace(\"+\");\n        entityCollection.addItem(cast body.userData1);\n    }\n\n}","package engine.ai.steering;\nimport engine.ai.steering.behaviours.Behavior;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass SteeringBehavior \n{\n\tpublic static inline var CALCULATE_SUM : Int = 0;\n\t// Simply adds up all of the behaviors and truncates them to the max acceleration\n\tpublic static inline var CALCULATE_SPEED : Int = 1;\n\t// Prioritized Dithering\n\tpublic static inline var CALCULATE_ACCURACY : Int = 2;\n\t// Weighted Truncated Running Sum with Prioritization\n\tpublic var behaviors : Array<Behavior>;\n\tpublic var neighbors : Array<Body>;\n\t\n\tpublic var calculateMethod : Int;\n\tprivate var hasChanged : Bool;\n\tprivate var hasGroupBehavior : Bool;\n\tprivate var force : Vector2D;\n\tprivate var agent : Body;\n\t\t\n\tpublic function new(a_agent : Body, a_calculationMethod : Int = CALCULATE_ACCURACY) \n\t{\n\t\tcalculateMethod = a_calculationMethod;\n\t\tagent = a_agent;\n\t\tforce = new Vector2D();\n\t\tbehaviors = new Array<Behavior>();\n\t\t//neighbors = new Array<Body>();\n\t}\n\n\tpublic function addBehavior(behavior : Behavior) : Void {\n\t\tbehaviors.push(behavior);\n\t\tbehavior.agent = agent;\n\t\tbehavior.steering = this;\n\t\thasChanged = true;\n\t\t//if ( behavior is IGroupBehavior ) hasGroupBehavior = true;\n\t}\n\t\n\tpublic function removeBehaviour(behavior : Behavior) : Void {\n\t\tvar i = 0;\n\t\tfor (item in behaviors) {\n\t\t\tif (item == behavior) {\n\t\t\t\tbehaviors.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\tpublic function calculate() : Vector2D {\n\t\tif ( hasChanged ) {\n\t\t\tsort();\n\t\t\thasChanged = false;\n\t\t}\n\t\tforce.x = 0;\n\t\tforce.y = 0;\n\t\t// FIXME\n\t\t// if ( m_hasGroupBehavior ) {\n\t\t// neighbors = [];\n\t\t// var dist : Number = m_agent.neighborDistance * m_agent.neighborDistance;\n\t\t// for each ( var entity:Entity in m_agent.parent.getChildren() ) {\n\t\t// if ( entity is Boid && entity.actualPos.distanceSqTo(m_agent.actualPos) < dist ) {\n\t\t// neighbors.push(entity);\n\t\t// }\n\t\t// }\n\t\t// }\n\n\t\tswitch( calculateMethod ) {\n\t\t\tcase CALCULATE_SUM:\n\t\t\t\trunningSum();\n\t\t\tcase CALCULATE_SPEED:\n\t\t\t\tprioritizedDithering();\n\t\t\tcase CALCULATE_ACCURACY:\n\t\t\t\twtrsWithPriorization();\n\t\t}\n\n\t\treturn force;\n\t}\n\n\tprivate function prioritizedDithering() : Void {\n\t\tfor (behavior in behaviors) {\n\t\t\tif ( Math.random() < behavior.probability ) {\n\t\t\t\tforce.plusEquals(behavior.calculate().mult(behavior.weight));\n\t\t\t}\n\n\t\t\tif ( !force.equalsZero() ) {\n\t\t\t\tforce.clampMax(agent.maxAcceleration);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate function wtrsWithPriorization() : Void {\n\t\tfor (behavior in behaviors) {\n\t\t\tif ( !accumulateForce(force, behavior.calculate().mult(behavior.weight))) \n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate function runningSum() : Void {\n\t\tfor (behavior in behaviors) {\n\t\t\tforce.plusEquals(behavior.calculate().mult(behavior.weight));\n\t\t}\n\t\tforce.clampMax(agent.maxAcceleration);\n\t}\n\n\tprivate function accumulateForce(a_runningTotal : Vector2D, a_forceToAdd : Vector2D) : Bool {\n\t\tvar magnitudeSoFar : Float = a_runningTotal.length();\n\t\tvar magnitudeRemaining : Float = agent.maxAcceleration - magnitudeSoFar;\n\t\tif ( magnitudeRemaining <= 0 ) \n\t\t\treturn false;\n\n\t\tvar magnitudeToAdd : Float = a_forceToAdd.length();\n\n\t\tif ( magnitudeToAdd < magnitudeRemaining ) {\n\t\t\ta_runningTotal.x += a_forceToAdd.x;\n\t\t\ta_runningTotal.y += a_forceToAdd.y;\n\t\t\treturn true;\n\t\t} else {\n\t\t\ta_runningTotal.plusEquals(a_forceToAdd.unit().multEquals(magnitudeRemaining));\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tprivate function sort() : Void {\n\t\tbehaviors.sort(behaviorsCompare);\n\t}\n\n\tprivate function behaviorsCompare(a : Behavior, b : Behavior) : Int {\n\t\tif ( a.priority < b.priority ) return -1;\n\t\tif ( a.priority == b.priority ) return 0;\n\t\treturn 1;\n\t}\n\t\n}","package engine.ai.steering.behaviours;\nimport engine.ai.steering.SteeringBehavior;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Behavior \n{\n\tpublic var weight : Float;\n\t// Amount the final force will be scaled by\n\tpublic var probability : Float;\n\t// Probability this will be calculated in prioritized dithering\n\tpublic var priority : Int;\n\t// Order in which this will be calculated vs other behaviors\n\tpublic var agent : Body;\n\t\n\tpublic var steering:SteeringBehavior;\n\t\t\n\tpublic function new(a_weight : Float = 1.0, a_priority : Int = 1, a_probability : Float = 1) \n\t{\n\t\tthis.weight = a_weight;\n\t\tthis.priority = a_priority;\n\t\tthis.probability = a_probability;\n\t}\n\t\n\tpublic function calculate() : Vector2D {\n\t\treturn null;\n\t}\t\n\t\n}","package physics.geometry;\nimport utils.Maths;\n\n/**\n * ...\n * @author rje\n */\n\nclass Vector2D \n{\n\t\n\tpublic var x : Float;\n\tpublic var y : Float;\n\n\tpublic function new(x = .0, y = .0) \n\t{\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\tinline public function setTo(x : Float, y:Float):Vector2D {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\t\n\tinline public function copy(v : Vector2D) : Void {\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t}\n\t\n\tinline public function dot(v : Vector2D) : Float {\n\t\treturn x * v.x + y * v.y;\n\t}\n\n\tinline public function cross(v : Vector2D) : Float {\n\t\treturn x * v.y - y * v.x;\n\t}\n\n\t\n\t//Plus\n\tinline public function plus(v : Vector2D) : Vector2D {\n\t\treturn new Vector2D(x + v.x, y + v.y);\n\t}\n\n\tinline public function plus2(x : Float, y : Float) : Vector2D {\n\t\treturn new Vector2D(this.x + x, this.y + y);\n\t}\n\n\tinline public function plusEquals(v : Vector2D) : Vector2D {\n\t\tx += v.x;\n\t\ty += v.y;\n\t\treturn this;\n\t}\n\t\n\tinline public function plusEquals2(x : Float, y : Float) : Vector2D {\n\t\tthis.x += x;\n\t\tthis.y += y;\n\t\treturn this;\n\t}\n\n\tinline public function minus(v : Vector2D) : Vector2D {\n\t\treturn new Vector2D(x - v.x, y - v.y);\n\t}\n\n\tinline public function minus2(x : Float, y : Float) : Vector2D {\n\t\treturn new Vector2D(this.x - x, this.y - y);\n\t}\n\n\tinline public function minusEquals(v : Vector2D) : Vector2D {\n\t\tx -= v.x;\n\t\ty -= v.y;\n\t\treturn this;\n\t}\n\n\tinline public function minusEquals2(x : Float, y : Float) : Vector2D {\n\t\tthis.x -= x;\n\t\tthis.y -= y;\n\t\treturn this;\n\t}\n\n\tinline public function mult(s : Float) : Vector2D {\n\t\treturn new Vector2D(x * s, y * s);\n\t}\n\n\tinline public function multEquals(s : Float) : Vector2D {\n\t\tx *= s;\n\t\ty *= s;\n\t\treturn this;\n\t}\n\n\tinline public function times(v : Vector2D) : Vector2D {\n\t\treturn new Vector2D(x * v.x, y * v.y);\n\t}\n\n\tinline public function times2(x : Float, y : Float) : Vector2D {\n\t\treturn new Vector2D(this.x * x, this.y * y);\n\t}\n\n\tinline public function timesEquals(v : Vector2D) : Vector2D {\n\t\tx *= v.x;\n\t\ty *= v.y;\n\t\treturn this;\n\t}\n\n\tinline public function timesEquals2(x : Float, y : Float) : Vector2D {\n\t\tthis.x *= x;\n\t\tthis.y *= y;\n\t\treturn this;\n\t}\n\n\tinline public function div(s : Float) : Vector2D {\n\t\tif (s == 0) s = 0.0001;\n\t\treturn new Vector2D(x / s, y / s);\n\t}\n\n\tinline public function divEquals(s : Float) : Vector2D {\n\t\tif (s == 0) s = 0.0001;\n\t\tx /= s;\n\t\ty /= s;\n\t\treturn this;\n\t}\n\t\n\tinline public function length() : Float {\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\n\tinline public function lengthSqr() : Float {\n\t\treturn x * x + y * y;\n\t}\t\n\t\n\tinline public function unit() : Vector2D {\n\t\tvar t = Math.sqrt(x * x + y * y) + Maths.ZERO_TOLERANCE;\n\t\treturn new Vector2D(x / t, y / t);\n\t}\t\n\t\n\tinline public function unitEquals() : Vector2D {\n\t\tvar t = Math.sqrt(x * x + y * y) + Maths.ZERO_TOLERANCE;\n\t\tx /= t;\n\t\ty /= t;\n\t\treturn this;\n\t}\n\t\n\tinline public function leftHandNormal() : Vector2D {\n\t\treturn new Vector2D(this.y, -this.x);\n\t}\t\n\t\n\tinline public function leftHandNormalEquals() : Vector2D {\n\t\tvar t = x;\n\t\tx = y;\n\t\ty = -t;\n\t\treturn this;\n\t}\n\n\tinline public function rightHandNormal() : Vector2D {\n\t\treturn new Vector2D(-this.y, this.x);\n\t}\n\t\t\n\tinline public function rightHandNormalEquals() : Vector2D {\n\t\tvar t = x;\n\t\tx = -y;\n\t\ty = x;\n\t\treturn this;\n\t}\n\n\tpublic function distance(v : Vector2D) : Float {\n\t\tvar delta : Vector2D = v.minus(this);// this.minus(v);\n\t\treturn delta.length();\n\t}\n\n\tpublic inline function distanceSqrd(v:Vector2D):Float {\n\t\tvar dX = this.x - v.x;\n\t\tvar dY = this.y - v.y;\n\t\treturn dX * dX + dY * dY;\n\t}\n\t\n\tpublic function clampMax(max : Float) : Vector2D {\n\t\tvar l : Float = length();\n\t\tif (l > max) {\n\t\t\tmultEquals(max / l);\n\t\t}\n\t\treturn this;\n\t}\n\t\n\tpublic function interpolate(v:Vector2D, t:Float):Vector2D {\n\t\treturn mult(1 - t).plus(v.mult(t));\n\t\t//return cpvadd(cpvmult(v1, 1.0f - t), cpvmult(v2, t));\n\t}\n\t\n\tpublic function rotate(angle : Float) : Vector2D {\n\t\tvar a : Float = angle * Math.PI / 180;\n\t\tvar cos : Float = Math.cos(a);\n\t\tvar sin : Float = Math.sin(a);\n\t\treturn new Vector2D((cos * x) - (sin * y), (cos * y) + (sin * x));\n\t}\n\t\n\tpublic function rotateEquals(angle : Float) : Vector2D {\n\t\tvar a : Float = angle * Math.PI / 180;\n\t\tvar cos : Float = Math.cos(a);\n\t\tvar sin : Float = Math.sin(a);\n\t\tvar rx : Float = (cos * x) - (sin * y);\n\t\tvar ry : Float = (cos * y) + (sin * x);\n\t\tthis.x = rx;\n\t\tthis.y = ry;\n\t\treturn this;\n\t}\n\t\n\tinline public function isEquals(v:Vector2D) : Bool {\n\t\treturn (this.x==v.x)&&(this.y==v.y);\n\t}\n\n\tinline public function equalsZero() : Bool {\n\t\treturn this.x == 0 && this.y == 0;\n\t}\n\t\n\tpublic function clone() : Vector2D {\n\t\treturn new Vector2D(x, y);\n\t}\n\t\n\tpublic function toString() : String {\n\t\treturn (x + \":\" + y);\n\t}\n\t\n\tpublic static function fromString( str : String ) : Vector2D {\n\t\tif (str == null) return null;\n\t\t\n\t\tvar vectorParts = str.split(\":\");\n\t\tif ((vectorParts == null) || (vectorParts.length != 2)) return null;\n\t\tvar xVal : Float = Std.parseFloat(vectorParts[0]);\n\t\tvar yVal : Float = Std.parseFloat(vectorParts[1]);\n\t\tif ( (Math.isNaN(xVal)) || (Math.isNaN(yVal)) ) return null;\n\t\treturn new Vector2D(xVal, yVal);\n\t}\n\t\n}","package engine.ai.steering.behaviours;\nimport engine.ai.steering.SteeringSettings;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Seek extends Behavior\n{\n\n\tpublic var target : Vector2D;\n\tpublic var seekDistSq : Float;\n\n\tpublic static var wanderResult:Vector2D = new Vector2D();\n\n\tpublic function new(target : Vector2D, seekDistSq : Float = 0) {\n\t\tsuper(SteeringSettings.seekWeight, SteeringSettings.seekPriority);\n\t\t\n\t\tthis.target = target;\n\t\tthis.seekDistSq = seekDistSq;\n\t}\n\n\toverride public function calculate() : Vector2D {\n\t\treturn calc(agent, target, seekDistSq);\n\t}\n\n\t//Hand optimized as called so often\n\tpublic static inline function calc(agent : Body, target : Vector2D, seekDistSq : Float = 0) : Vector2D {\n\t\t\n\t\t//var wanderResult:Vector2D = new Vector2D();\n\t\t\n\t\tvar dX:Float = target.x - agent.averageCenter.x;\n\t\tvar dY:Float = target.y - agent.averageCenter.y;\n\t\tvar d:Float = dX * dX + dY * dY;\n\t\t\n\t\tif (seekDistSq < 0 && d < -seekDistSq) {\n\t\t\treturn wanderResult;\n\t\t} else if (seekDistSq > 0 && d > seekDistSq) {\n\t\t\treturn wanderResult;\n\t\t} else {\n\t\t\t//var desired = target.minus(agent.averageCenter);\n\t\t\t//desired.unitEquals();\n\t\t\t//desired.multEquals(agent.maxVelocityScalar);\n\t\t\t//desired.minusEquals(agent.GetVelocity());\n\t\t\t//return desired;\n\t\t\tvar t = Math.sqrt(d);\n\t\t\t\n\t\t\twanderResult.x = dX / t;\n\t\t\twanderResult.x *= 5;//agent.maxSteeringForcePerStep;\n\t\t\twanderResult.x -= agent.position.x - agent.prevPosition.x;\n\t\t\t\n\t\t\twanderResult.y = dY / t;\n\t\t\twanderResult.y *= 5;//agent.maxSteeringForcePerStep;\n\t\t\twanderResult.y -= agent.position.y - agent.prevPosition.y;\n\t\t\t\n\t\t\treturn wanderResult;\n\t\t}\n\t}\n\t\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.components.Position;\nimport physics.geometry.Vector2D;\n\nclass CameraController extends Component\n{\n\n    public var threshold:Float;\n\n    public function new() {\n\n    }\n\n    public function getPosition():Position {\n        var position:Position = cast owner.getComponent(\"Position\");\n        return position;\n    }\n\n}","package eco.core;\n\nimport haxe.macro.Expr;\nimport haxe.macro.Context;\nimport haxe.macro.Type;\n\n\n\nclass ComponentBuilder \n{\n\n    public static function build () :Array<Field> {\n        var pos = Context.currentPos();\n        var cl = Context.getLocalClass().get();\n\n        var name = Context.makeExpr(getComponentName(cl), pos);\n        var componentType = TPath({pack: cl.pack, name: cl.name, params: []});\n\n        var fields = buildFields(macro {\n            #if doc @:noDoc #end\n            var public__static__inline__NAME = $name;\n        });\n\n        // Only override get_name if this component directly extends a @:componentBase and creates a\n        // new namespace\n        if (extendsComponentBase(cl)) {\n            fields = fields.concat(buildFields(macro {\n                function override__private__get_name () :String {\n                    return $name;\n                }\n            }));\n        }\n\n        // if (extendsComponentBase(cl)) {\n        //     fields = fields.concat(buildFields(macro {\n        //         function override__private__get_name () :String {\n        //             return $name;\n        //         }\n        //     }));\n        // }\n\n        return fields.concat(Context.getBuildFields());\n    }\n\n    private static function getComponentName (cl :ClassType) :String\n    {\n        // Traverse up to the last non-component base\n        while (true) {\n            if (extendsComponentBase(cl)) {\n                break;\n            }\n            cl = cl.superClass.t.get();\n        }\n\n        // Look up the ID, otherwise generate one\n        var fullName = cl.pack.concat([cl.name]).join(\".\");\n        var name = _nameCache.get(fullName);\n        if (name == null) {\n            name = cl.name;// + \"_\" + _nextId;\n            _nameCache.set(fullName, name);\n            ++_nextId;\n        }\n\n        return name;\n    }\n\n    private static function extendsComponentBase (cl :ClassType)\n    {\n        var superClass = cl.superClass.t.get();\n        return superClass.meta.has(\":componentBase\");\n    }\n\n    public static function buildFields (block :Expr) :Array<Field>\n    {\n        var fields :Array<Field> = [];\n        switch (block.expr) {\n            case EBlock(exprs):\n                var metas = [];\n                for (expr in exprs) {\n                    switch (expr.expr) {\n                        case EMeta(meta, e):\n                            metas.push(meta);\n                        case EVars(vars):\n                            for (v in vars) {\n                                fields.push({\n                                    name: getFieldName(v.name),\n                                    doc: null,\n                                    access: getAccess(v.name),\n                                    kind: FVar(v.type, v.expr),\n                                    pos: v.expr.pos,\n                                    meta: metas,\n                                });\n                            }\n                            metas = [];\n                        case EFunction(name, f):\n                            fields.push({\n                                name: getFieldName(name),\n                                doc: null,\n                                access: getAccess(name),\n                                kind: FFun(f),\n                                pos: f.expr.pos,\n                                meta: metas,\n                            });\n                            metas = [];\n                        default:\n                    }\n                }\n            default:\n        }\n        return fields;\n    }\n\n    private static function getAccess (name :String) :Array<Access>\n    {\n        var result = [];\n        for (token in name.split(\"__\")) {\n            var access = switch (token) {\n                case \"public\": APublic;\n                case \"private\": APrivate;\n                case \"static\": AStatic;\n                case \"override\": AOverride;\n                case \"dynamic\": ADynamic;\n                case \"inline\": AInline;\n                default: null;\n            }\n            if (access != null) {\n                result.push(access);\n            }\n        }\n        return result;\n    }\n\n    private static function getFieldName (name :String) :String\n    {\n        var parts = name.split(\"__\");\n        return parts[parts.length-1];\n    }\n\n    private static var _nameCache = new Map<String,String>();\n    private static var _nextId = 0;    \n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.input.DigitalInput;\n\nclass Controls extends Component\n{\n\n    public var digitalInput:DigitalInput;\n\n    public function new() {\n\n    }\n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.components.Position;\nimport wgr.display.DisplayObject;\n\nclass Display extends Component\n{\n\n    public var displayObject:DisplayObject;\n\n    private var position:Position;\n\n    public var id:String;\n    public var tid:String;\n\n    public function new(id:String,tid:String) {\n        //this.displayObject = displayObject;\n        this.id = id;\n        this.tid = tid;\n    }\n\n    // public function new(displayObject:DisplayObject) {\n    //     this.displayObject = displayObject;\n    // }\n\n    override public function onAdded() {\n        position = cast owner.getComponent(\"Position\");\n    }\n\n    override public function update(time:Float) {\n        //var position = cast owner.getComponent(\"Position\");\n        displayObject.position.x = position.position.x;\n        displayObject.position.y = position.position.y;\n    }\n\n}","\npackage engine.components;\n\nimport eco.core.Component;\n\ntypedef LifecycleEvent = {\n    var age:Float;\n}\n\nclass Lifecycle extends Component\n{\n\n    public var ttl:Float;\n    public var age:Float;\n    public var expired:Bool;\n\n    public function new(ttl:Float) {\n        this.ttl = ttl;\n        this.age = 0;\n        this.expired = false;\n    }\n\n   override public function update(time:Float) {\n        age += time;\n        if (!expired && age>=ttl) {\n            owner.events.dispatch( \"lc\" , {age:age} );\n            expired = true;\n        }\n    }    \n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.components.Position;\nimport wgr.particle.emitter.IParticleEmitter;\nimport wgr.particle.IParticleEngine;\n\nclass ParticleEmitters extends Component\n{\n\n    public var emitters:Array<IParticleEmitter>;\n    public var position:Position;\n    public var particleEngine:IParticleEngine;\n\n    public function new(emitters:Array<IParticleEmitter>) {\n        this.emitters = emitters;\n    }\n\n    override public function onAdded() {\n        position = cast owner.getComponent(\"Position\");\n    }\n\n    public function AddEmitter(emitter:IParticleEmitter,forceEmit:Bool) {\n        emitters.push(emitter);\n        if (forceEmit==true && position!=null)\n            emitter.update(0, position.position, particleEngine);\n    }\n\n    override public function update(time:Float) {\n        for (emitter in emitters)\n            emitter.update(time, position.position, particleEngine);\n    }\n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.components.Position;\nimport physics.dynamics.Body;\nimport physics.geometry.GeometricShape;\nimport physics.geometry.Vector2D;\n\nclass Physics extends Component\n{\n\n    public var body:Body;\n    public var position:Position;\n\n    public function new(x:Float,y:Float,velocityX:Float,velocityY:Float,shapes:Array<GeometricShape>) {\n        body = new Body();\n        body.SetStaticPosition(new Vector2D(x,y));\n        body.SetVelocity(new Vector2D(velocityX,velocityY));\n        body.userData1 = this;\n        for (shape in shapes)\n            body.AddFeature(shape,new physics.dynamics.Material());\n    }\n\n    override public function onAdded() {\n        this.position = cast owner.getComponent(\"Position\");\n        this.position.position = body.position;\n    }\n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport physics.geometry.Vector2D;\n\nclass Position extends Component\n{\n\n    public var position:Vector2D;\n    public var rotation:Float;\n\n    public function new(x:Float = 0.0,y:Float = 0.0,rotation:Float = 0.0) {\n        position = new Vector2D(x,y);\n        this.rotation = rotation;\n    }\n\n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.ai.behaviors.Behavior;\nimport engine.ai.behaviors.BehaviorContext;\nimport engine.ai.behaviors.BehaviorTree;\nimport engine.ai.behaviors.Sequence;\n\nclass Script extends Component\n{\n    public var bt:Sequence;\n    public var bc:BehaviorContext;\n\n    public function new() {\n        bt = new Sequence();\n    }\n\n    override public function onAdded() {\n        bc = new BehaviorContext(owner);\n    }\n\n    override public function update(time:Float) {\n        bc.time = time;\n        bt.tick(bc);\n    }\n\n}","\npackage engine.components;\n\nimport eco.core.Component;\nimport engine.ai.steering.behaviours.Seek;\nimport engine.ai.steering.SteeringBehavior;\nimport engine.components.Physics;\nimport engine.components.Position;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\n\nclass Steering extends Component\n{\n\n    public var body:Body;\n    public var position:Position;\n\n    public var maxSteeringForcePerStep:Float;\n    public var maxAcceleration:Float;\n\n    public var steeringBehaviour:SteeringBehavior;\n\n    public function new() {\n        maxSteeringForcePerStep = 5;\n        maxAcceleration = 1;\n    }\n\n    override public function onAdded() {\n        this.position = cast owner.getComponentByClass(Position);\n        this.body = (cast owner.getComponentByClass(Physics)).body;\n        this.steeringBehaviour = new SteeringBehavior(this.body);\n        this.steeringBehaviour.addBehavior(new Seek(new Vector2D(100,100)));\n    }\n\n    override public function update(time:Float) {\n        body.AddForce(steeringBehaviour.calculate());\n    }\n\n}","\npackage engine.core;\n\nimport utils.AssetLoader;\n\nclass BaseGame \n{\n\n    public var assets:AssetLoader;\n\n    public var gameLoop:GameLoop;\n\n    public function new() {\n\n        gameLoop = new GameLoop();\n\n    }\n\n    public function loadAssets(assetList:Array<String>) {\n        assets = new AssetLoader();\n        assets.addEventListener(\"loaded\",prepare);\n        assets.SetImagesToLoad( assetList );\n        assets.Load();\n    }\n\n    public function prepare(event) {\n        preInit();\n        prepareRenderer();\n        prepareEngine();\n    }\n\n    public function preInit() {\n\n    }\n\n    public function prepareEngine() {\n\n    }\n\n    public function prepareRenderer() {\n\n    }\n\n}","\npackage engine.ds;\n\nimport eco.core.Entity;\nimport engine.ds.EntityCollectionItem;\n\nclass EntityCollection \n{\n\n    public static var itempool = {\n        var pool = new ds.DLL<EntityCollectionItem>();\n        pool;\n    }\n\n    public var entities:ds.DLL<EntityCollectionItem>;\n\n    public var length(get, never):Int;\n\n    public function new() {\n        entities = new ds.DLL<EntityCollectionItem>();\n    }\n\n    private inline function get_length():Int {\n        return entities.length;\n    }\n\n    public function addItem(entity:Entity):EntityCollectionItem {\n        var item;\n        if (engine.ds.EntityCollection.itempool.length==0) {\n            item = new EntityCollectionItem();\n        } else {\n            item = engine.ds.EntityCollection.itempool.remove(engine.ds.EntityCollection.itempool.tail);\n        }\n        item.entity = entity;\n        entities.insertBeginning(item);\n        return item;\n    }\n\n    public function clear() {\n        while (entities.length>0) {\n            var item = entities.remove(entities.tail);\n            item.reset();\n            engine.ds.EntityCollection.itempool.insertEnd(item);\n        }\n    }\n\n}","\npackage engine.ds;\n\nimport ds.DLL;\nimport eco.core.Entity;\n\nclass EntityCollectionItem implements DLLNode<EntityCollectionItem>\n{\n\n    public var prev:EntityCollectionItem;\n    public var next:EntityCollectionItem;\n\n    public var entity:Entity;\n\n    public var distance:Float;\n    public var priority:Float;\n    public var visible:Bool;\n\n    public function new() {\n\n    }\n\n    public function reset() {\n        \n    }\n\n}","\npackage engine.graphics;\n\nimport ds.Grid2D;\nimport wgr.display.DisplayObjectContainer;\nimport worldEngine.WorldData;\n\nclass StaticLayerDisplayManager \n{\n\n    public var grid:Grid2D<IGameGraphics>;\n\n    public var worldData:WorldData;\n\n    public var layerContainer:DisplayObjectContainer;\n\n    public function new(worldData:WorldData,cellSize:Int) {\n        this.worldData = worldData;\n        this.grid = new Grid2D<IGameGraphics>( Math.ceil(worldData.worldBounds.width()/cellSize) , Math.ceil(worldData.worldBounds.height()/cellSize) , cellSize);\n        hashItems();\n    }\n\n    public function hashItems() {\n        var data = worldData.tmxMap.getObjectGroup(\"foreground\");\n        for (item in data.objects) {\n            if (item.gid>=0) {\n                var tileSet = worldData.tmxMap.getGidOwner(item.gid);\n                var props = tileSet.getPropertiesByGid(item.gid);\n                trace(props);\n            }\n        }\n        trace(data);\n        //for (item in worldData.staticGraphics) {\n            // var x1 = world.Index(bodyFeature.shape.aabb.l+body.position.x);\n            // var y1 = world.Index(bodyFeature.shape.aabb.t+body.position.y);\n            // var x2 = world.Index(bodyFeature.shape.aabb.r+body.position.x)+1;\n            // var y2 = world.Index(bodyFeature.shape.aabb.b+body.position.y)+1;\n            // for( x in x1...x2 ) {\n            //     for ( y in y1...y2 ) {\n            //         tileFeature = world.GetGridSafe(x, y);\n            //         if (tileFeature.HasFlagBool(TileFeature.COLLIDABLE)) {\n            //             tempFeature.shape = tileFeature.tile;\n            //             tempFeature.position.setTo(x*world.cellSize,y*world.cellSize);\n            //             manager.narrowphase.CollideFeatures(tempFeature, bodyFeature);\n            //         }\n            //     }\n            // }           \n        //}\n    }\n\n    public function update(viewport:wgr.geom.AABB) {\n\n    }\n\n}","\npackage engine.input;\n\nimport js.html.EventTarget;\nimport physics.geometry.Vector2D;\n\nclass DigitalInput \n{\n\n    public var keyMap : Array<Int>;\n    public var mousePosition : Vector2D;\n    public var mousePreviousPosition : Vector2D;\n    public var mouseOffset : Vector2D;\n    private var frameRef : Int;\n    private var target : EventTarget;\n\n    public function new() {\n        keyMap = new Array<Int>();\n        for (i in 0...255) {\n            keyMap[i] = 0;\n        }\n        mousePosition = new Vector2D();\n        mousePreviousPosition = new Vector2D();\n        mouseOffset = new Vector2D();\n        frameRef = 2;       \n    }\n    \n    public function InputTarget(target : EventTarget) : Void {\n\n        this.target = target;\n        target.addEventListener(\"keydown\",KeyDown,false);\n        target.addEventListener(\"keyup\",KeyUp,false);\n        target.addEventListener(\"mousedown\",MouseDown,false);\n        //target.addEventListener(\"touchstart\",MouseDown,false);\n\n        target.addEventListener(\"mouseup\",MouseUp,false);\n        target.addEventListener(\"mousemove\",MouseMove,false);\n        // target.addEventListener(MouseEvent.RIGHT_MOUSE_DOWN, RightMouseDown, false, 0, true);\n        // target.addEventListener(MouseEvent.RIGHT_MOUSE_UP, RightMouseUp, false, 0, true);\n        \n    }\n\n    public function Update(x:Float,y:Float) : Void {\n        mouseOffset.x = x;\n        mouseOffset.y = y;\n        frameRef++;\n        // mousePreviousPosition.x = mousePosition.x;\n        // mousePreviousPosition.y = mousePosition.y;\n        // mousePosition.x = target.mouseX + screenOffset.x;\n        // mousePosition.y = target.mouseY + screenOffset.y;\n    }\n\n    public function KeyDown(event : Dynamic) : Void {\n        if (keyMap[event.keyCode] == 0) {           \n            keyMap[event.keyCode] = frameRef;\n        }\n    }\n\n    public function KeyUp(event : Dynamic) : Void {\n        keyMap[event.keyCode] = 0;\n    }\n\n    public function MouseDown(event : Dynamic) : Bool {\n        keyMap[200] = frameRef;\n        return false;\n    }\n\n    public function MouseUp(event : Dynamic) : Bool {\n        keyMap[200] = 0;\n        return false;\n    }\n\n    public function MouseMove(event : Dynamic) : Bool {\n        mousePreviousPosition.x = mousePosition.x;\n        mousePreviousPosition.y = mousePosition.y;\n        mousePosition.x = event.offsetX;\n        mousePosition.y = event.offsetY;\n        return false;\n    }\n\n    // public function RightMouseDown(event : MouseEvent) : Void {\n    //     keyMap[201] = frameRef;\n    // }\n\n    // public function RightMouseUp(event : MouseEvent) : Void {\n    //     keyMap[201] = 0;\n    // }\n    \n    inline public function Pressed(keyCode : Int) : Bool {\n        return (keyMap[keyCode] > 0);\n    }\n\n    inline public function JustPressed(keyCode : Int) : Bool {\n        return (keyMap[keyCode] == frameRef-1);\n    }\n    \n    inline public function PressedDuration(keyCode : Int) : Int {\n        var duration = keyMap[keyCode];\n        return (duration > 0) ? (frameRef - duration) : 0;\n    }\n    \n    inline public function Released(keyCode : Int) : Bool {\n        return (keyMap[keyCode] == 0);\n    }\n\n}","package engine.map.tmx;\n\nimport ds.Array2D;\nimport engine.map.tmx.TmxTileSet;\nimport haxe.xml.Fast;\nimport utils.Base64;\n\nclass TmxLayer\n{\n\tpublic var map:TmxMap;\n\tpublic var name:String;\n\tpublic var x:Int;\n\tpublic var y:Int;\n\tpublic var width:Int;\n\tpublic var height:Int;\n\tpublic var opacity:Float;\n\tpublic var visible:Bool;\n\tpublic var tileGIDs:Array2D;\n\tpublic var properties:TmxPropertySet;\n\t\n\tpublic function new(source:Fast, parent:TmxMap)\n\t{\n\t\tproperties = new TmxPropertySet();\n\t\tmap = parent;\n\t\tname = source.att.name;\n\t\tx = (source.has.x) ? Std.parseInt(source.att.x) : 0;\n\t\ty = (source.has.y) ? Std.parseInt(source.att.y) : 0;\n\t\twidth = Std.parseInt(source.att.width); \n\t\theight = Std.parseInt(source.att.height); \n\t\tvisible = (source.has.visible && source.att.visible == \"1\") ? true : false;\n\t\topacity = (source.has.opacity) ? Std.parseFloat(source.att.opacity) : 0;\n\t\t\n\t\t//load properties\n\t\tvar node:Fast;\n\t\tfor (node in source.nodes.properties)\n\t\t\tproperties.extend(node);\n\t\t\n\t\t//load tile GIDs\n\t\t//tileGIDs = [];\n\t\tvar data:Fast = source.node.data;\n\t\tif(data != null)\n\t\t{\n\t\t\tvar chunk:String = \"\";\n\t\t\tswitch(data.att.encoding)\n\t\t\t{\n\t\t\t\tcase \"base64\":\n\t\t\t\t\tchunk = StringTools.trim(data.innerData);\n\t\t\t\t\tvar compressed:Bool = false;\n\t\t\t\t\tif (data.has.compression)\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch(data.att.compression)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase \"zlib\":\n\t\t\t\t\t\t\t\tcompressed = true;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow \"TmxLayer - data compression type not supported!\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// js.Lib.debug();\n\t\t\t\t\ttileGIDs = new Array2D(width,height,Base64.Decode(chunk));//base64ToArray(chunk, width, compressed);\n\t\t\t\tcase \"csv\":\n\t\t\t\t\t// chunk = data.innerData;\n\t\t\t\t\t// tileGIDs = csvToArray(chunk);\n\t\t\t\tdefault:\n\t\t\t\t\t// //create a 2dimensional array\n\t\t\t\t\t// var lineWidth:Int = width;\n\t\t\t\t\t// var rowIdx:Int = -1;\n\t\t\t\t\t// for (node in data.nodes.tile)\n\t\t\t\t\t// {\n\t\t\t\t\t// \t//new line?\n\t\t\t\t\t// \tif(++lineWidth >= width)\n\t\t\t\t\t// \t{\n\t\t\t\t\t// \t\ttileGIDs[++rowIdx] = new Array<Int>();\n\t\t\t\t\t// \t\tlineWidth = 0;\n\t\t\t\t\t// \t}\n\t\t\t\t\t// \tvar gid:Int = Std.parseInt(node.att.gid);\n\t\t\t\t\t// \ttileGIDs[rowIdx].push(gid);\n\t\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// public function toCsv(tileSet:TmxTileSet = null):String\n\t// {\n\t// \tvar max:Int = 0xFFFFFF;\n\t// \tvar offset:Int = 0;\n\t// \tif(tileSet != null)\n\t// \t{\n\t// \t\toffset = tileSet.firstGID;\n\t// \t\tmax = tileSet.numTiles - 1;\n\t// \t}\n\t// \tvar result:String = \"\";\n\t// \tvar row:Array<Int>;\n\t// \tfor (row in tileGIDs)\n\t// \t{\n\t// \t\tvar id:Int = 0;\n\t// \t\tfor (id in row)\n\t// \t\t{\n\t// \t\t\tid -= offset;\n\t// \t\t\tif(id < 0 || id > max)\n\t// \t\t\t\tid = 0;\n\t// \t\t\tresult +=  id + \",\";\n\t// \t\t}\n\t// \t\tresult += id + \"\\n\";\n\t// \t}\n\t// \treturn result;\n\t// }\n\t\n\t/* ONE DIMENSION ARRAY\n\tpublic static function arrayToCSV(input:Array, lineWidth:Int):String\n\t{\n\t\tvar result:String = \"\";\n\t\tvar lineBreaker:Int = lineWidth;\n\t\tfor each(var entry:uint in input)\n\t\t{\n\t\t\tresult += entry+\",\";\n\t\t\tif(--lineBreaker == 0)\n\t\t\t{\n\t\t\t\tresult += \"\\n\";\n\t\t\t\tlineBreaker = lineWidth;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t*/\n\t\n\tprivate static function csvToArray(input:String):Array<Array<Int>>\n\t{\n\t\tvar result:Array<Array<Int>> = new Array<Array<Int>>();\n\t\tvar rows:Array<String> = input.split(\"\\n\");\n\t\tvar row:String;\n\t\tfor (row in rows)\n\t\t{\n\t\t\tif (row == \"\") continue;\n\t\t\tvar resultRow:Array<Int> = new Array<Int>();\n\t\t\tvar entries:Array<String> = row.split(\",\");\n\t\t\tvar entry:String;\n\t\t\tfor (entry in entries)\n\t\t\t\tresultRow.push(Std.parseInt(entry)); //convert to int\n\t\t\tresult.push(resultRow);\n\t\t}\n\t\treturn result;\n\t}\n\n\t// public function addTileType(index:Int,x:Int,y:Int) {\n //        var v:Float = 0xFF << 24 | 0 << 16 | y << 8 | x;\n //        tiles.set(index,v);\n //    }\n\n //    public function toTexture():Array2D {\n //        var textureData = new ds.Array2D(mapData.w,mapData.h);\n //        for (xp in 0...mapData.w) {\n //             for (yp in 0...mapData.h) {\n //                var source = mapData.get(xp,yp);\n //                if (source>0) {\n //                    textureData.set(xp,yp,tiles.get(source));\n //                } else {\n //                    textureData.set(xp,yp,0xFFFFFFFF);\n //                }\n //             }\n //        }\n //        return textureData;\n //    }\n\t\n\tpublic static function layerToCoordTexture(layer:TmxLayer):Array2D {\n\t\t//Assumes all tiles are from same set...function\n\t\tvar tileSet:TmxTileSet = null;\n\t\tvar textureData = new Array2D(layer.width,layer.height);\n\n\n        for (xp in 0...layer.width) {\n             for (yp in 0...layer.height) {\n                var source = layer.tileGIDs.get(xp,yp);\n// js.Lib.debug();\n                if (source>0) {\n                    if (tileSet==null) {\n                        tileSet = layer.map.getGidOwner(source);\n                    }\n                    var relativeID = source-tileSet.firstGID;\n                    var y = Math.floor(relativeID/tileSet.numCols);\n                    var x = relativeID-(tileSet.numCols*y);\n                    var v:Float = 0xFF << 24 | 0 << 16 | y << 8 | x;\n                    textureData.set(xp,yp,v);\n                } else {\n                    textureData.set(xp,yp,0xFFFFFFFF);\n                }\n             }\n        }\t\t\n        return textureData;\n\t}\n\n\tpublic static function layerToCollisionMap(layer:TmxLayer):Array2D {\n\t\t//Assumes all tiles are from same set...function\n\t\tvar tileSet:TmxTileSet = null;\n\t\tvar collisionMap = new Array2D(layer.width,layer.height);\n\n        for (xp in 0...layer.width) {\n             for (yp in 0...layer.height) {\n                var source = layer.tileGIDs.get(xp,yp);\n                if (source>0) {\n                    if (tileSet==null) {\n                        tileSet = layer.map.getGidOwner(source);\n                    }\n                    // js.Lib.debug();\n                    var relativeID = source-tileSet.firstGID;\n                    var props = tileSet.getPropertiesByGid(source);\n                    // trace(xp,yp);\n                    if (props!=null) {\n                    \tvar collision = props.resolve(\"collision\");\n                    \tif (collision!=null) {\n                    \t\t\tcollisionMap.set(xp,yp,collision);\n                    \t\t} else {\n                    \t\t\tcollisionMap.set(xp,yp,0);\n                    \t\t}\n                    } else {\n                    \tcollisionMap.set(xp,yp,0);\n                    }   \n                } else {\n                    collisionMap.set(xp,yp,0);\n                }\n             }\n        }\t\t\n        return collisionMap;\n\t}\n\n\t// private static function base64ToArray(chunk:String, lineWidth:Int, compressed:Bool):Array2D //Array<Array<Int>>\n\t// {\n\t// \treturn \n\t\t// var result:Array<Array<Int>> = new Array<Array<Int>>();\n\t\t// var data:ByteArray = base64ToByteArray(chunk);\n\t\t// if(compressed)\n\t\t// {\n\t\t// \t#if (js && !format)\n\t\t// \tthrow \"Need the format library to use compressed map on html5\";\n\t\t// \t#else \n\t\t// \tdata.uncompress();\n\t\t// \t#end\n\t\t// }\n\t\t\t\n\t\t// data.endian = Endian.LITTLE_ENDIAN;\n\t\t// while(data.position < data.length)\n\t\t// {\n\t\t// \tvar resultRow:Array<Int> = new Array<Int>();\n\t\t// \tvar i:Int;\n\t\t// \tfor (i in 0...lineWidth)\n\t\t// \t\tresultRow.push(data.readInt());\n\t\t// \tresult.push(resultRow);\n\t\t// }\n\t\t// return result;\n\t// }\n\t\n\tprivate static inline var BASE64_CHARS:String = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\t\n\t// private static function base64ToByteArray(data:String):ByteArray \n\t// {\n\t// \tvar output:ByteArray = new ByteArray();\n\t// \t//initialize lookup table\n\t// \tvar lookup:Array<Int> = new Array<Int>();\n\t// \tvar c:Int;\n\t// \tfor (c in 0...BASE64_CHARS.length)\n\t// \t{\n\t// \t\tlookup[BASE64_CHARS.charCodeAt(c)] = c;\n\t// \t}\n\t\t\n\t// \tvar i:Int = 0;\n\t// \twhile (i < data.length - 3) \n\t// \t{\n\t// \t\t// Ignore whitespace\n\t// \t\tif (data.charAt(i) == \" \" || data.charAt(i) == \"\\n\")\n\t// \t\t{\n\t// \t\t\ti++; continue;\n\t// \t\t}\n\t\t\t\n\t// \t\t//read 4 bytes and look them up in the table\n\t// \t\tvar a0:Int = lookup[data.charCodeAt(i)];\n\t// \t\tvar a1:Int = lookup[data.charCodeAt(i + 1)];\n\t// \t\tvar a2:Int = lookup[data.charCodeAt(i + 2)];\n\t// \t\tvar a3:Int = lookup[data.charCodeAt(i + 3)];\n\t\t\t\n\t// \t\t// convert to and write 3 bytes\n\t// \t\tif(a1 < 64)\n\t// \t\t\toutput.writeByte((a0 << 2) + ((a1 & 0x30) >> 4));\n\t// \t\tif(a2 < 64)\n\t// \t\t\toutput.writeByte(((a1 & 0x0f) << 4) + ((a2 & 0x3c) >> 2));\n\t// \t\tif(a3 < 64)\n\t// \t\t\toutput.writeByte(((a2 & 0x03) << 6) + a3);\n\t\t\t\n\t// \t\ti += 4;\n\t// \t}\n\t\t\n\t// \t// Rewind & return decoded data\n\t// \toutput.position = 0;\n\t// \treturn output;\n\t// }\n}\n","package engine.map.tmx;\n\nimport haxe.xml.Fast;\n\nclass TmxMap\n{\n\tpublic var version:String;\n\tpublic var orientation:String;\n\n\tpublic var width:Int;\n\tpublic var height:Int;\n\tpublic var tileWidth:Int;\n\tpublic var tileHeight:Int;\n\tpublic var fullWidth:Int;\n\tpublic var fullHeight:Int;\n\n\tpublic var properties(default, null):TmxPropertySet;\n\tpublic var tilesets:Array<TmxTileSet>;\n\tpublic var layers:TmxOrderedHash<TmxLayer>;\n\tpublic var objectGroups:TmxOrderedHash<TmxObjectGroup>;\n\n\tpublic function new(data:Dynamic)\n\t{\n\t\tproperties = new TmxPropertySet();\n\t\tvar source:Fast = null;\n\t\tvar node:Fast = null;\n\n\t\tif (Std.is(data, String)) source = new Fast(Xml.parse(data));\n\t\t// else if (Std.is(data, Xml)) source = new Fast(data);\n\t\t// else if (Std.is(data, ByteArray)) source = new Fast(Xml.parse(data.toString()));\n\t\telse throw \"Unknown TMX map format\";\n\n\t\ttilesets = new Array<TmxTileSet>();\n\t\tlayers = new TmxOrderedHash<TmxLayer>();\n\t\tobjectGroups = new TmxOrderedHash<TmxObjectGroup>();\n\n\t\tsource = source.node.map;\n\n\t\t//map header\n\t\tversion = source.att.version;\n\t\tif (version == null) version = \"unknown\";\n\n\t\torientation = source.att.orientation;\n\t\tif (orientation == null) orientation = \"orthogonal\";\n\n\t\twidth = Std.parseInt(source.att.width);\n\t\theight = Std.parseInt(source.att.height);\n\t\ttileWidth = Std.parseInt(source.att.tilewidth);\n\t\ttileHeight = Std.parseInt(source.att.tileheight);\n\t\t// Calculate the entire size\n\t\tfullWidth = width * tileWidth;\n\t\tfullHeight = height * tileHeight;\n\n\t\t//read properties\n\t\tfor (node in source.nodes.properties)\n\t\t\tproperties.extend(node);\n\n\t\t//load tilesets\n\t\tfor (node in source.nodes.tileset)\n\t\t\ttilesets.push(new TmxTileSet(node));\n\n\t\t//load layer\n\t\tfor (node in source.nodes.layer)\n\t\t\tlayers.set(node.att.name, new TmxLayer(node, this));\n\n\t\t//load object group\n\t\tfor (node in source.nodes.objectgroup)\n\t\t\tobjectGroups.set(node.att.name, new TmxObjectGroup(node, this));\n\n\t\t// for (node in source.nodes.imagelayer)\n\t\t// \timageLayers.set(node.att.name, new TmxImageLayer(node));\n\t}\n\t\n\tpublic function getLayer(name:String):TmxLayer\n\t{\n\t\treturn layers.get(name);\n\t}\n\n\tpublic function getObjectGroup(name:String):TmxObjectGroup\n\t{\n\t\treturn objectGroups.get(name);\n\t}\n\n\t//works only after TmxTileSet has been initialized with an image...\n\tpublic function getGidOwner(gid:Int):TmxTileSet\n\t{\n\t\tvar last:TmxTileSet = null;\n\t\tvar set:TmxTileSet;\n\t\tfor (set in tilesets)\n\t\t{\n\t\t\tif(set.hasGid(gid))\n\t\t\t\treturn set;\n\t\t}\n\t\treturn null;\n\t}\n}\n","package engine.map.tmx;\nimport haxe.xml.Fast;\n\nclass TmxObject\n{\n\tpublic var group:TmxObjectGroup;\n\tpublic var name:String;\n\tpublic var type:String;\n\tpublic var x:Int;\n\tpublic var y:Int;\n\tpublic var width:Int;\n\tpublic var height:Int;\n\tpublic var gid:Int;\n\tpublic var custom:TmxPropertySet;\n\tpublic var shared:TmxPropertySet;\n\t\n\tpublic function new(source:Fast, parent:TmxObjectGroup)\n\t{\n\t\tgroup = parent;\n\t\tname = (source.has.name) ? source.att.name : \"[object]\";\n\t\ttype = (source.has.type) ? source.att.type : \"\";\n\t\tx = Std.parseInt(source.att.x);\n\t\ty = Std.parseInt(source.att.y);\n\t\twidth = (source.has.width) ? Std.parseInt(source.att.width) : 0;\n\t\theight = (source.has.height) ? Std.parseInt(source.att.height) : 0;\n\t\t//resolve inheritence\n\t\tshared = null;\n\t\tgid = -1;\n\t\tif(source.has.gid && source.att.gid.length != 0) //object with tile association?\n\t\t{\n\t\t\tgid = Std.parseInt(source.att.gid);\n\t\t\tvar set:TmxTileSet;\n\t\t\tfor (set in group.map.tilesets)\n\t\t\t{\n\t\t\t\tshared = set.getPropertiesByGid(gid);\n\t\t\t\tif(shared != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//load properties\n\t\tvar node:Xml;\n\t\tcustom = new TmxPropertySet();\n\t\tfor (node in source.nodes.properties)\n\t\t\tcustom.extend(node);\n\t}\n}","package engine.map.tmx;\nimport haxe.xml.Fast;\n\nclass TmxObjectGroup\n{\n\tpublic var map:TmxMap;\n\tpublic var name:String;\n\tpublic var x:Int;\n\tpublic var y:Int;\n\tpublic var width:Int;\n\tpublic var height:Int;\n\tpublic var opacity:Float;\n\tpublic var visible:Bool;\n\tpublic var properties:TmxPropertySet;\n\tpublic var objects:Array<TmxObject>;\n\t\n\tpublic function new(source:Fast, parent:TmxMap)\n\t{\n\t\tproperties = new TmxPropertySet();\n\t\tobjects = new Array<TmxObject>();\n\t\t\n\t\tmap = parent;\n\t\tname = source.att.name;\n\t\tx = (source.has.x) ? Std.parseInt(source.att.x) : 0;\n\t\ty = (source.has.y) ? Std.parseInt(source.att.y) : 0;\n\t\twidth = (source.has.width) ? Std.parseInt(source.att.width) : 0;\n\t\theight = (source.has.height) ? Std.parseInt(source.att.height) : 0;\n\t\tvisible = (source.has.visible && source.att.visible == \"1\") ? true : false;\n\t\topacity = (source.has.opacity) ? Std.parseFloat(source.att.opacity) : 0;\n\t\t\n\t\t//load properties\n\t\tvar node:Fast;\n\t\tfor (node in source.nodes.properties)\n\t\t\tproperties.extend(node);\n\t\t\t\n\t\t//load objects\n\t\tfor (node in source.nodes.object)\n\t\t\tobjects.push(new TmxObject(node, this));\n\t}\n}","package engine.map.tmx;\n\nclass TmxOrderedHash<T>\n{\n\tvar _keys:Array<String>;\n#if haxe3\n\tvar _map:Map<String,T>;\n#else\n\tvar _map:Hash<T>;\n#end\n\n\tpublic function new()\n\t{\n\t\t_keys = new Array<String>();\n#if haxe3\n\t\t_map = new Map<String,T>();\n#else\n\t\t_map = new Hash<T>();\n#end\n\t}\n\n\tpublic inline function set(key:String, value:T)\n\t{\n\t\tif (!_map.exists(key)) _keys.push(key);\n\t\t_map.set(key,value);\n\t}\n\n\tpublic inline function remove(key:String) : Bool\n\t{\n\t\t_keys.remove(key);\n\t\treturn _map.remove(key);\n\t}\n\n\tpublic inline function exists(key:String) { return _map.exists(key); }\n\tpublic inline function get(key:String) { return _map.get(key); }\n\n\tpublic function iterator():Iterator<T>\n\t{\n\t\tvar _keys_itr = _keys.iterator();\n\t\tvar __map = _map;\n\t\treturn {\n\t\t\tnext: function() { return __map.get(_keys_itr.next()); },\n\t\t\thasNext: _keys_itr.hasNext\n\t\t}\n\t}\n\n\tpublic function keys()\n\t{\n\t\treturn _keys.iterator();\n\t}\n\n\tpublic function toString()\n\t{\n\t\tvar __map = _map;\n\t\tvar pairs = Lambda.map(_keys, function(x:String) { return x + ' => ' + __map.get(x); });\n\t\treturn  \"{\"+ pairs.join(', ') + \"}\";\n\t}\n}\n","package engine.map.tmx;\n\nimport haxe.xml.Fast;\n\nclass TmxPropertySet implements Dynamic<String>\n{\n\n\tpublic function new()\n\t{\n\t\tkeys = new Map<String,String>();\n\t}\n\n\tpublic function resolve(name:String):String\n\t{\n\t\treturn keys.get(name);\n\t}\n\n\tpublic function extend(source:Fast)\n\t{\n\t\tvar prop:Fast;\n\t\tfor (prop in source.nodes.property)\n\t\t{\n\t\t\tkeys.set(prop.att.name, prop.att.value);\n\t\t}\n\t}\n\n\tprivate var keys:Map<String,String>;\n\t\n}\n","package engine.map.tmx;\n\nimport haxe.xml.Fast;\nimport js.html.Image;\nimport wgr.geom.Rectangle;\n\nclass TmxTileSet\n{\n\tprivate var _tileProps:Array<TmxPropertySet>;\n\tprivate var _image:Image;\n\n\tpublic var firstGID:Int;\n\tpublic var name:String;\n\tpublic var tileWidth:Int;\n\tpublic var tileHeight:Int;\n\tpublic var spacing:Int;\n\tpublic var margin:Int;\n\tpublic var imageSource:String;\n\n\t//available only after immage has been assigned:\n\tpublic var numTiles:Int;\n\tpublic var numRows:Int;\n\tpublic var numCols:Int;\n\n\tpublic function new(data:Dynamic)\n\t{\n\t\tvar node:Fast, source:Fast;\n\t\tnumTiles = 0xFFFFFF;\n\t\tnumRows = numCols = 1;\n\n\t\t// Use the correct data format\n\t\tif (Std.is(data, Fast))\n\t\t{\n\t\t\tsource = data;\n\t\t}\n\t\t// else if (Std.is(data, ByteArray))\n\t\t// {\n\t\t// \tsource = new Fast(Xml.parse(data.toString()));\n\t\t// \tsource = source.node.tileset;\n\t\t// }\n\t\telse throw \"Unknown TMX tileset format\";\n\n\t\tfirstGID = (source.has.firstgid) ? Std.parseInt(source.att.firstgid) : 1;\n\n\t\t// check for external source\n\t\tif (source.has.source)\n\t\t{\n\n\t\t}\n\t\telse // internal\n\t\t{\n\t\t\tvar node:Fast = source.node.image;\n\t\t\timageSource = node.att.source;\n\n\t\t\tname = source.att.name;\n\t\t\tif (source.has.tilewidth) tileWidth = Std.parseInt(source.att.tilewidth);\n\t\t\tif (source.has.tileheight) tileHeight = Std.parseInt(source.att.tileheight);\n\t\t\tif (source.has.spacing) spacing = Std.parseInt(source.att.spacing);\n\t\t\tif (source.has.margin) margin = Std.parseInt(source.att.margin);\n\n\t\t\t//read properties\n\t\t\t_tileProps = new Array<TmxPropertySet>();\n\t\t\tfor (node in source.nodes.tile)\n\t\t\t{\n\t\t\t\tif (node.has.id)\n\t\t\t\t{\n\t\t\t\t\tvar id:Int = Std.parseInt(node.att.id);\n\t\t\t\t\t_tileProps[id] = new TmxPropertySet();\n\t\t\t\t\tfor (prop in node.nodes.properties)\n\t\t\t\t\t\t_tileProps[id].extend(prop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic var image(get_image, set_image):Image;\n\tprivate function get_image():Image\n\t{\n\t\treturn _image;\n\t}\n\tpublic function set_image(v:Image):Image\n\t{\n\t\t_image = v;\n\t\t//TODO: consider spacing & margin\n\t\tnumCols = Math.floor(v.width / tileWidth);\n\t\tnumRows = Math.floor(v.height / tileHeight);\n\t\tnumTiles = numRows * numCols;\n\t\treturn _image;\n\t}\n\n\tpublic function hasGid(gid:Int):Bool\n\t{\n\t\treturn (gid >= firstGID) && (gid < firstGID + numTiles);\n\t}\n\n\tpublic function fromGid(gid:Int):Int\n\t{\n\t\treturn gid - firstGID;\n\t}\n\n\tpublic function toGid(id:Int):Int\n\t{\n\t\treturn firstGID + id;\n\t}\n\n\tpublic function getPropertiesByGid(gid:Int):TmxPropertySet\n\t{\n\t\tif (_tileProps != null)\n\t\t\treturn _tileProps[gid - firstGID];\n\t\treturn null;\n\t}\n\n\tpublic function getProperties(id:Int):TmxPropertySet\n\t{\n\t\treturn _tileProps[id];\n\t}\n\n\tpublic function getRect(id:Int):Rectangle\n\t{\n\t\t//TODO: consider spacing & margin\n\t\treturn new Rectangle(0,0,(id % numCols) * tileWidth, (id / numCols) * tileHeight);\n\t}\n}","\npackage engine.systems;\n\nimport eco.core.Component;\nimport eco.core.Entity;\nimport eco.core.System;\nimport engine.components.Controls;\nimport engine.input.DigitalInput;\nimport wgr.display.Camera;\n\nclass InputSystem extends System\n{\n\n    public var digitalInput:DigitalInput;\n    public var camera:Camera;\n\n    public function new(digitalInput:DigitalInput,camera:Camera) {\n        super();\n        this.digitalInput = digitalInput;\n        this.camera = camera;\n    }\n\n    override public function get_registeredComponents ():Array<Class<Component>> {\n        return [Controls];\n    }\n\n    override public function componentAdded(e:Entity,c:Class<Component>) {\n        var controls:Controls = cast e.getComponentByClass(c);\n        controls.digitalInput = digitalInput;\n    }\n\n    override public function componentRemoved(e:Entity,c:Class<Component>) {\n        trace(\"TODO removed controls\");\n    }\n\n    override public function update(time:Float) {\n        digitalInput.Update(-camera.position.x,-camera.position.y);\n    }\n\n}","\npackage engine.systems;\n\nimport eco.core.Component;\nimport eco.core.Entity;\nimport eco.core.System;\nimport engine.components.ParticleEmitters;\nimport wgr.particle.IParticleEngine;\n\nclass ParticleSystem extends System\n{\n\n    public var particleEngine:IParticleEngine;\n\n    public function new(particleEngine:IParticleEngine) {\n        super();\n        this.particleEngine = particleEngine;\n    }\n\n    override public function get_registeredComponents ():Array<Class<Component>> {\n        return [ParticleEmitters];\n    } \n\n    override public function componentAdded(e:Entity,c:Class<Component>) {\n        var particleEmitters:ParticleEmitters = cast e.getComponentByClass(c);\n        particleEmitters.particleEngine = particleEngine;\n    }\n\n    override public function update(time:Float) {\n        particleEngine.Update();\n    }\n\n\n}","\npackage engine.systems;\n\nimport eco.core.Component;\nimport eco.core.Entity;\nimport eco.core.System;\nimport engine.components.Physics;\nimport physics.PhysicsEngine;\nimport worldEngine.WorldData;\nimport worldEngine.WorldPhysicsEngine;\n\nclass PhysicsSystem extends System\n{\n\n    public var physicsEngine:PhysicsEngine;\n\n    public function new(worldData:WorldData) {\n        super();\n        physicsEngine = new WorldPhysicsEngine(60,60,new physics.collision.narrowphase.sat.SAT(),worldData);\n        physicsEngine.masslessForces.setTo(0,9);\n    }\n\n    override public function get_registeredComponents ():Array<Class<Component>> {\n        return [Physics];\n    }\n\n    override public function componentAdded(e:Entity,c:Class<Component>) {\n        var physics:engine.components.Physics = cast e.getComponentByClass(c);\n        physicsEngine.AddBody(physics.body);\n    }\n\n    override public function componentRemoved(e:Entity,c:Class<Component>) {\n        var physics:engine.components.Physics = cast e.getComponentByClass(c);\n        physicsEngine.RemoveBody(physics.body);\n    }\n\n    override public function update(time:Float) {\n        physicsEngine.Step();\n    }\n\n}","\npackage engine.systems;\n\nimport eco.core.Component;\nimport eco.core.Entity;\nimport eco.core.System;\nimport engine.components.CameraController;\nimport engine.components.Display;\nimport engine.components.Position;\nimport wgr.display.Camera;\nimport wgr.display.DisplayObjectContainer;\nimport wgr.display.Sprite;\nimport wgr.texture.TextureManager;\n\nclass RenderSystem extends System\n{\n\n    public var container:DisplayObjectContainer;\n    public var camera:Camera;\n    public var cameraPosition:Position;\n    public var textureManager:TextureManager;\n\n    public function new(camera:Camera,container:DisplayObjectContainer,textureManager:TextureManager) {\n        super();\n        this.camera = camera;\n        this.container = container;\n        this.textureManager = textureManager;\n    }\n\n    override public function get_registeredComponents ():Array<Class<Component>> {\n        return [Display,CameraController];\n    }\n\n    override public function componentAdded(e:Entity,c:Class<Component>) {\n        if (c==Display) {\n            var display:engine.components.Display = cast e.getComponentByClass(c);\n            display.displayObject = createSprite(display.id,display.tid);\n            container.addChild(display.displayObject);\n        } else if (c==CameraController) {\n            var camera:CameraController = cast e.getComponent(\"CameraController\");\n            cameraPosition = camera.getPosition();\n        }\n    }\n\n    override public function componentRemoved(e:Entity,c:Class<Component>) {\n        if (c==Display) {\n            var display:engine.components.Display = cast e.getComponentByClass(c);\n            container.removeChild(display.displayObject);\n        }\n    }\n\n    override public function update(time:Float) {\n        camera.Focus(cameraPosition.position.x,cameraPosition.position.y);\n    }\n\n    private function createSprite(id:String,tid:String) {\n        var s = new Sprite();\n        s.id = id;\n        s.texture = textureManager.textures.get(tid);\n        s.position.x = 0;\n        s.position.y = 0;\n        s.pivot.x = s.texture.frame.width * s.texture.pivot.x;\n        s.pivot.y = s.texture.frame.height * s.texture.pivot.y;\n        return s;\n    }\n\n}","\npackage engine.view;\n\nimport js.Browser;\nimport js.html.CanvasElement;\nimport wgr.display.Camera;\nimport wgr.display.Stage;\nimport wgr.renderers.canvas.CanvasDebugView;\nimport wgr.renderers.webgl.WebGLRenderer;\n\nclass View \n{\n    public var stage:Stage;\n    public var camera:Camera;\n    public var renderer:WebGLRenderer;\n    public var canvasView:CanvasElement;\n    public var debugView:CanvasElement;\n    public var debugRenderer:CanvasDebugView;\n\n    public function new(width:Int,height:Int,camera:Camera,debug:Bool) {\n        this.stage = new Stage();\n        this.camera = camera;\n        this.stage.addChild(camera);\n\n        this.canvasView = cast(Browser.document.getElementById(\"view\"),CanvasElement);\n        this.renderer = new WebGLRenderer(stage,camera,canvasView,width,height);\n\n        this.debugView = cast(Browser.document.getElementById(\"viewDebug\"),CanvasElement);\n        this.debugRenderer = new CanvasDebugView(debugView,camera,width,height);\n\n        camera.Resize(renderer.width,renderer.height);\n    }\n\n    \n\n}","\npackage game.exile;\n\nimport ds.Array2D;\nimport eco.core.Engine;\nimport eco.core.Entity.Create;\nimport eco.systems.EntityUpdater;\nimport engine.core.BaseGame;\nimport engine.graphics.StaticLayerDisplayManager;\nimport engine.input.DigitalInput;\nimport engine.map.tmx.TmxLayer;\nimport engine.map.tmx.TmxMap;\nimport engine.systems.InputSystem;\nimport engine.systems.ParticleSystem;\nimport engine.systems.PhysicsSystem;\nimport engine.systems.RenderSystem;\nimport engine.view.View;\nimport game.exile.components.GunTurret;\nimport game.exile.entities.EntityFactory;\nimport js.Browser;\nimport physics.geometry.Polygon;\nimport physics.geometry.Vector2D;\nimport utils.AssetLoader;\nimport wgr.display.Camera;\nimport wgr.display.DisplayObjectContainer;\nimport wgr.display.Sprite;\nimport wgr.particle.BlockSpriteParticleEngine;\nimport wgr.particle.PointSpriteParticleEngine;\nimport wgr.renderers.webgl.SpriteRenderer;\nimport wgr.renderers.webgl.TileMap;\nimport wgr.texture.TextureManager;\nimport worldEngine.WorldData;\n\nclass Exile extends BaseGame\n{\n\n    public static inline var TEXTURE_CONFIG:String = \"data/sprites.json\";\n    public static inline var TEXTURE_DATA:String = \"data/sprites.png\";\n    public static inline var MAP_DATA:String = \"data/testMap.tmx\";\n    public static inline var TILE_SPRITE_SHEET:String = \"data/spelunky-tiles.png\";\n    public static inline var TILE_MAP_DATA_1:String = \"data/spelunky0.png\";\n    public static inline var TILE_MAP_DATA_2:String = \"data/spelunky1.png\";\n\n\n    public var tmxMap:TmxMap; \n    public var mapData:Array2D;\n\n    public var view:View;\n    public var tm:TextureManager;\n\n    public var digitalInput:DigitalInput;\n\n    public var tileMap:TileMap;\n\n    public var spriteRender:SpriteRenderer;\n\n    public var pointParticleEngine:PointSpriteParticleEngine;\n    public var blockParticleEngine:BlockSpriteParticleEngine;\n\n    public var itemContainer:DisplayObjectContainer;\n\n    public var factory:EntityFactory;\n\n    public var mainEngine:Engine;\n\n    public var worldData:WorldData;\n\n    public var camera:Camera;\n\n    public function new() {\n        super();\n        loadAssets( [TEXTURE_CONFIG,TEXTURE_DATA,MAP_DATA,TILE_MAP_DATA_1,TILE_MAP_DATA_2,TILE_SPRITE_SHEET] );\n    }\n\n    override public function prepareEngine() {\n\n        mainEngine = new Engine();\n\n        // factory = new EntityFactory(tm);\n\n        EntityFactory.instance = new EntityFactory();\n\n        mainEngine.registerComponent(engine.components.Physics,5);\n        mainEngine.registerComponent(engine.components.Display,2);\n        mainEngine.registerComponent(engine.components.CameraController,1);\n\n        mainEngine.addSystem(new PhysicsSystem(worldData));\n        mainEngine.addSystem(new EntityUpdater(mainEngine.entities));\n        mainEngine.addSystem(new InputSystem(digitalInput,camera));\n        mainEngine.addSystem(new ParticleSystem(blockParticleEngine));\n        mainEngine.addSystem(new RenderSystem(camera,itemContainer,tm));\n\n        // mainEngine.addSystem(new PhysicsSystem(worldData),0);  \n        // mainEngine.addSystem(new MotionControlSystem(digitalInput),1);\n        // mainEngine.addSystem(new PlayerSystem(digitalInput,factory),1);\n        // mainEngine.addSystem(new CameraControlSystem(view.camera), 4);\n        // mainEngine.addSystem(new RenderSystem( itemContainer ), 5);\n        // mainEngine.addSystem(new ParticleSystem( blockParticleEngine ), 6);\n\n        // mainEngine.addSystem(new DebugRenderSystem( view.debugRenderer ), 6);\n\n        createEntities();\n\n        gameLoop.updateFunc = tick;\n        gameLoop.start();\n\n    }\n\n    public function createEntities() {\n        mainEngine.addEntity(EntityFactory.instance.create(\"player\",50,50));\n        mainEngine.addEntity(Create([new GunTurret(new Vector2D(200,100))]));\n        // mainEngine.addEntity(factory.create(\"enemy\",400,100));\n    }\n\n\n    public function tick(time:Float) {\n        //digitalInput.Update(-camera.position.x,-camera.position.y);\n        mainEngine.update(time);\n\n        // blockParticleEngine.EmitParticle(100,100,utils.Random.RandomFloat(-100,100),utils.Random.RandomFloat(-100,100),0,0,800,0.95,true,false,null,4,255,255,255,255);\n        // blockParticleEngine.Update();\n        //pointParticleEngine.EmitParticle(100,100,0,0,0,0,10000,1,false,false,null,0,64,64,0,0);\n        // pointParticleEngine.EmitParticle(100,100,utils.Random.RandomFloat(-10,10),utils.Random.RandomFloat(-10,10),0,0,10000,1,false,false,null,0,64,64);\n        //pointParticleEngine.Update();\n\n        view.renderer.Render(view.camera.viewPortAABB);\n        // lightGrid.renderLightGrid();\n        // lightGrid.draw();\n    }\n\n    override public function preInit() {\n\n        digitalInput = new DigitalInput();\n        digitalInput.InputTarget(Browser.document);\n\n        tmxMap = new TmxMap(assets.assets.get(MAP_DATA));\n        tmxMap.tilesets[0].set_image(assets.assets.get(TILE_SPRITE_SHEET));\n        worldData = new WorldData(32,tmxMap,\"Tile Layer 1\");\n\n        camera = new Camera();\n        camera.worldExtentsAABB = new wgr.geom.AABB( worldData.worldBounds.t , worldData.worldBounds.r , worldData.worldBounds.b , worldData.worldBounds.l );\n        camera.worldExtentsAABB.shrink(worldData.tileSize);\n\n        view = new View(800,600,camera,false);\n    }\n\n    override public function prepareRenderer() {\n\n        mapData = engine.map.tmx.TmxLayer.layerToCoordTexture(tmxMap.getLayer(\"Tile Layer 1\"));\n\n        tm  = new TextureManager(view.renderer.gl);\n        tm.AddTexture(TEXTURE_DATA, assets.assets.get(TEXTURE_DATA) );\n        tm.ParseTexturePackerJSON( assets.assets.get(TEXTURE_CONFIG) , TEXTURE_DATA );\n\n        tileMap = new TileMap();\n            view.renderer.AddRenderer(tileMap);\n            tileMap.SetSpriteSheet(assets.assets.get(TILE_SPRITE_SHEET));\n            tileMap.SetTileLayerFromData(mapData,\"base\",1,1);\n            tileMap.SetTileLayer(assets.assets.get(TILE_MAP_DATA_2),\"bg\",0.6,0.6);\n            tileMap.tileSize = 16;\n            tileMap.TileScale(2);\n\n        spriteRender = new SpriteRenderer();\n            spriteRender.AddStage(view.stage);\n            view.renderer.AddRenderer(spriteRender);\n\n        // pointParticleEngine = new PointSpriteParticleEngine(14000,1000/60);\n        //     pointParticleEngine.renderer.SetSpriteSheet(tileMap.spriteSheet,16,8,8);\n        //     view.renderer.AddRenderer(pointParticleEngine.renderer);\n\n        blockParticleEngine = new BlockSpriteParticleEngine(4000,1000/60);\n            view.renderer.AddRenderer(blockParticleEngine.renderer);\n\n        itemContainer = new DisplayObjectContainer();\n            itemContainer.id = \"itemContainer\";\n            view.camera.addChild(itemContainer);\n    }\n\n}","\npackage game.exile.components;\n\nimport eco.core.Component;\nimport engine.ai.behaviors.actions.Delay;\nimport engine.ai.behaviors.actions.GetLocalEntities;\nimport engine.components.Display;\nimport engine.components.Physics;\nimport engine.components.Position;\nimport engine.components.Script;\nimport physics.geometry.Circle;\nimport physics.geometry.Vector2D;\n\nclass GunTurret extends Component\n{\n\n    private var startPosition:physics.geometry.Vector2D;\n    private var physics:Physics;\n\n    public function new(startPosition:Vector2D) {\n        this.startPosition = startPosition;\n    }\n\n    override public function onStarted() {\n        var script = new Script();\n        script.bt.addChild(new Delay(1000));\n        script.bt.addChild(new GetLocalEntities(100));\n        owner.add(script);\n    }\n\n    override public function onAdded() {\n        owner.name = \"GunTurret\";\n        var shape = new Circle(30,new Vector2D(0,0));\n        physics = new Physics(startPosition.x,startPosition.y,0,0,[shape]);\n        physics.body.MakeStatic();\n\n        owner\n            .add(new Position())\n            .add(physics)\n            .add(new Display(\"turret\",\"turretA.png\"));\n\n    }\n\n}","\npackage game.exile.components;\n\nimport eco.core.Component;\nimport eco.core.Entity;\nimport engine.components.Controls;\nimport engine.components.Physics;\nimport engine.components.Position;\nimport engine.components.Script;\nimport engine.input.DigitalInput;\nimport game.exile.components.ProjectileA;\nimport game.exile.entities.EntityFactory;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\n\nclass Player extends Component\n{\n\n    private var left:Bool;\n    private var right:Bool;\n    private var up:Bool;\n    private var down:Bool;\n    private var trigger:Bool;\n\n    private var movementForce:Vector2D;\n\n    private var position:Position;\n    private var controls:Controls;\n    private var physics:Physics;\n\n    private var force:Vector2D;\n\n    public function new() {\n        force = new Vector2D();\n    }\n\n    override public function onStarted() {\n        position = cast owner.getComponentByClass(Position);\n        controls = cast owner.getComponentByClass(Controls);\n        physics = cast owner.getComponentByClass(Physics);\n    }\n\n    override public function update(time:Float) {\n        processInputs();\n    }\n\n    private function processInputs() {\n        left = controls.digitalInput.Pressed(65);\n        right = controls.digitalInput.Pressed(68);\n        up = controls.digitalInput.Pressed(87);\n        down = controls.digitalInput.Pressed(83);\n\n        force.setTo(0,0);\n\n        force.x -= left ? 10 : 0;\n        force.x += right ? 10 : 0;\n\n        force.y -= up ? 50 : 0;\n        force.y += down ? 10 : 0;\n\n        physics.body.AddForce( force );\n\n        if (controls.digitalInput.JustPressed(200)) {\n\n            var viewPos = controls.digitalInput.mousePosition.plus(controls.digitalInput.mouseOffset);\n            var startVelocity = viewPos.minusEquals(position.position).unitEquals().multEquals(15);\n\n            // var projectile = new Entity();\n            // projectile.add(new ProjectileA( position.position , startVelocity ));\n            // owner.engine.addEntity(projectile);\n\n            owner.engine.addEntity(Entity.Create([new ProjectileA( position.position , startVelocity)]));\n        }\n    }\n\n}","\npackage game.exile.components;\n\nimport eco.core.Component;\nimport engine.components.Display;\nimport engine.components.Lifecycle;\nimport engine.components.ParticleEmitters;\nimport engine.components.Physics;\nimport engine.components.Position;\nimport engine.components.Script;\nimport engine.components.Steering;\nimport physics.dynamics.Arbiter;\nimport physics.geometry.Circle;\nimport physics.geometry.Polygon;\nimport physics.geometry.Vector2D;\nimport wgr.particle.emitter.Explosion;\nimport wgr.particle.emitter.RandomSpray;\n\nclass ProjectileA extends Component \n{\n\n    private var startPosition:Vector2D;\n    private var startVelocity:Vector2D;\n    private var physics:Physics;\n\n    private var script:Script;\n\n    private var totalContactCount:Int = 0;\n\n    public function new(startPosition:Vector2D,startVelocity:Vector2D) {\n        this.startPosition = startPosition;\n        this.startVelocity = startVelocity;\n    }\n\n    override public function onAdded() {\n        owner.name = \"ProjectileA\";\n        var shape = new Circle(6,new Vector2D(0,0));\n        physics = new Physics(startPosition.x,startPosition.y,0,0,[shape]);\n        physics.body.SetMass(0.1);\n        physics.body.group = 1;\n        physics.body.features[0].contactCallback = OnContact;\n        physics.body.SetVelocity(startVelocity);\n\n        owner\n            .add(new Position())\n            .add(physics)\n            .add(new Display(\"character\",\"projectile1.png\"))\n            .add(new Lifecycle(utils.Random.RandomInteger(1000,1500)))\n            .add(new ParticleEmitters([new RandomSpray(60,60)]));\n            // .add(new Steering());\n\n\n        owner.events.add(function(type:String,data:Dynamic){\n            if (type==\"lc\")\n                destroy();\n        });\n\n    }\n\n    function OnContact(arbiter:Arbiter):Void {\n        if (arbiter.isSensor)\n            return;\n        totalContactCount++;\n        // trace(totalContactCount);\n        // intraStepContactCount++;\n        if (totalContactCount>1 || arbiter.OpposingBody(physics.body).id > 0) {\n            //destroy();\n        }\n    }\n\n    public function destroy() {\n        var pm:ParticleEmitters = cast owner.getComponentByClass(ParticleEmitters);\n        pm.AddEmitter(new Explosion(10,100),true);\n        owner.engine.removeEntity(owner);\n    }\n\n}\n            ","\npackage game.exile.entities;\n\nimport eco.core.Entity;\nimport engine.components.CameraController;\nimport engine.components.Controls;\nimport engine.components.Display;\nimport engine.components.Lifecycle;\nimport engine.components.Physics;\nimport engine.components.Position;\nimport game.exile.components.Player;\nimport game.exile.entities.EntityFactory;\nimport physics.geometry.Polygon;\nimport physics.geometry.Vector2D;\nimport wgr.display.Sprite;\nimport wgr.texture.TextureManager;\n\nclass EntityFactory \n{\n\n    public static var instance:EntityFactory;\n\n    public function new() {\n    }\n\n    public function create(name:String,x:Float,y:Float):Entity {\n        switch (name) {\n            case \"player\":                \n                var player = new Entity()\n                .add(new Position(100,100,0))\n                .add(new Physics(x,y,0,0,[new Polygon(Polygon.CreateRectangle(30,72),new Vector2D(0,0))]))\n                .add(new Display(\"character\",\"character1.png\"))\n                .add(new CameraController())\n                .add(new Lifecycle(1000))\n                .add(new Controls())\n                .add(new Player());\n\n                player.events.add(function(type:String,data:Dynamic){\n                    trace(data);\n                });\n                var physics:Physics = cast player.getComponentByClass(Physics);\n                physics.body.group = 1;\n                // spr.scale.x = -1;\n                // var player = new Entity()\n                //     .add(new Player())\n                //     .add(new Position(0,0,0))\n                //     .add(new Physics(x,y,1,1,[new Polygon(Polygon.CreateRectangle(30,72),new Vector2D(0,0))]))\n                //     .add(new Display(spr))\n                //     .add(new DebugDisplay())\n                //     .add(new MotionControls())\n                //     .add(new Camera());\n                // var physics:Physics = player.components.get(Physics);\n                //     physics.body.group = 1;\n                return player;\n            // case \"enemy\":\n            //     var spr = createSprite(\"character\",\"character2.png\");\n            //     spr.scale.x = -1;\n            //     var enemy = new Entity()\n            //         .add(new Position(0,0,0))\n            //         .add(new Physics(x,y,1,1,[new Polygon(Polygon.CreateRectangle(30,72),new Vector2D(0,0))]))\n            //         .add(new Display(spr))\n            //         .add(new DebugDisplay());\n            //     return enemy;\n            case \"turret\":\n                // spr.scale.x = 2;\n                // spr.scale.y = 2;\n                var turret = new Entity()\n                    .add(new Position(0,0,0))\n                    .add(new Physics(x,y,0,0,[new Polygon(Polygon.CreateRectangle(16,16),new Vector2D(0,0))]))\n                    .add(new Display(\"character\",\"projectile1.png\"));\n                    //.add(new Particle());\n                return turret;\n\n        }\n        return null;\n    }\n\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class IntMap<T> implements Map.IMap<Int,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : Int, value : T ) : Void {\n\t\tuntyped h[key] = value;\n\t}\n\n\tpublic function get( key : Int ) : Null<T> {\n\t\treturn untyped h[key];\n\t}\n\n\tpublic function exists( key : Int ) : Bool {\n\t\treturn untyped h.hasOwnProperty(key);\n\t}\n\n\tpublic function remove( key : Int ) : Bool {\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped  __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<Int> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key|0);\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.ds;\n\n@:coreApi class StringMap<T> implements Map.IMap<String,T> {\n\n\tprivate var h : Dynamic;\n\n\tpublic function new() : Void {\n\t\th = {};\n\t}\n\n\tpublic function set( key : String, value : T ) : Void {\n\t\tuntyped h[\"$\"+key] = value;\n\t}\n\n\tpublic function get( key : String ) : Null<T> {\n\t\treturn untyped h[\"$\"+key];\n\t}\n\n\tpublic function exists( key : String ) : Bool {\n\t\treturn untyped h.hasOwnProperty(\"$\"+key);\n\t}\n\n\tpublic function remove( key : String ) : Bool {\n\t\tkey = \"$\"+key;\n\t\tif( untyped !h.hasOwnProperty(key) ) return false;\n\t\tuntyped __js__(\"delete\")(h[key]);\n\t\treturn true;\n\t}\n\n\tpublic function keys() : Iterator<String> {\n\t\tvar a = [];\n\t\tuntyped {\n\t\t\t__js__(\"for( var key in this.h ) {\");\n\t\t\t\tif( h.hasOwnProperty(key) )\n\t\t\t\t\ta.push(key.substr(1));\n\t\t\t__js__(\"}\");\n\t\t}\n\t\treturn a.iterator();\n\t}\n\n\tpublic function iterator() : Iterator<T> {\n\t\treturn untyped {\n\t\t\tref : h,\n\t\t\tit : keys(),\n\t\t\thasNext : function() { return __this__.it.hasNext(); },\n\t\t\tnext : function() { var i = __this__.it.next(); return __this__.ref[\"$\"+i]; }\n\t\t};\n\t}\n\n\tpublic function toString() : String {\n\t\tvar s = new StringBuf();\n\t\ts.add(\"{\");\n\t\tvar it = keys();\n\t\tfor( i in it ) {\n\t\t\ts.add(i);\n\t\t\ts.add(\" => \");\n\t\t\ts.add(Std.string(get(i)));\n\t\t\tif( it.hasNext() )\n\t\t\t\ts.add(\", \");\n\t\t}\n\t\ts.add(\"}\");\n\t\treturn s.toString();\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.xml;\n\nprivate class NodeAccess implements Dynamic<Fast> {\n\n\tvar __x : Xml;\n\n\tpublic function new( x : Xml ) {\n\t\t__x = x;\n\t}\n\n\tpublic function resolve( name : String ) : Fast {\n\t\tvar x = __x.elementsNamed(name).next();\n\t\tif( x == null ) {\n\t\t\tvar xname = if( __x.nodeType == Xml.Document ) \"Document\" else __x.nodeName;\n\t\t\tthrow xname+\" is missing element \"+name;\n\t\t}\n\t\treturn new Fast(x);\n\t}\n\n}\n\nprivate class AttribAccess implements Dynamic<String> {\n\n\tvar __x : Xml;\n\n\tpublic function new( x : Xml ) {\n\t\t__x = x;\n\t}\n\n\tpublic function resolve( name : String ) : String {\n\t\tif( __x.nodeType == Xml.Document )\n\t\t\tthrow \"Cannot access document attribute \"+name;\n\t\tvar v = __x.get(name);\n\t\tif( v == null )\n\t\t\tthrow __x.nodeName+\" is missing attribute \"+name;\n\t\treturn v;\n\t}\n\n}\n\nprivate class HasAttribAccess implements Dynamic<Bool> {\n\n\tvar __x : Xml;\n\n\tpublic function new( x : Xml ) {\n\t\t__x = x;\n\t}\n\n\tpublic function resolve( name : String ) : Bool {\n\t\tif( __x.nodeType == Xml.Document )\n\t\t\tthrow \"Cannot access document attribute \"+name;\n\t\treturn __x.exists(name);\n\t}\n\n}\n\nprivate class HasNodeAccess implements Dynamic<Bool> {\n\n\tvar __x : Xml;\n\n\tpublic function new( x : Xml ) {\n\t\t__x = x;\n\t}\n\n\tpublic function resolve( name : String ) : Bool {\n\t\treturn __x.elementsNamed(name).hasNext();\n\t}\n\n}\n\nprivate class NodeListAccess implements Dynamic<List<Fast>> {\n\n\tvar __x : Xml;\n\n\tpublic function new( x : Xml ) {\n\t\t__x = x;\n\t}\n\n\tpublic function resolve( name : String ) : List<Fast> {\n\t\tvar l = new List();\n\t\tfor( x in __x.elementsNamed(name) )\n\t\t\tl.add(new Fast(x));\n\t\treturn l;\n\t}\n\n}\n\nclass Fast {\n\n\tpublic var x(default,null) : Xml;\n\tpublic var name(get,null) : String;\n\tpublic var innerData(get,null) : String;\n\tpublic var innerHTML(get,null) : String;\n\tpublic var node(default,null) : NodeAccess;\n\tpublic var nodes(default,null) : NodeListAccess;\n\tpublic var att(default,null) : AttribAccess;\n\tpublic var has(default,null) : HasAttribAccess;\n\tpublic var hasNode(default,null) : HasNodeAccess;\n\tpublic var elements(get,null) : Iterator<Fast>;\n\n\tpublic function new( x : Xml ) {\n\t\tif( x.nodeType != Xml.Document && x.nodeType != Xml.Element )\n\t\t\tthrow \"Invalid nodeType \"+x.nodeType;\n\t\tthis.x = x;\n\t\tnode = new NodeAccess(x);\n\t\tnodes = new NodeListAccess(x);\n\t\tatt = new AttribAccess(x);\n\t\thas = new HasAttribAccess(x);\n\t\thasNode = new HasNodeAccess(x);\n\t}\n\n\tfunction get_name() {\n\t\treturn if( x.nodeType == Xml.Document ) \"Document\" else x.nodeName;\n\t}\n\n\tfunction get_innerData() {\n\t\tvar it = x.iterator();\n\t\tif( !it.hasNext() )\n\t\t\tthrow name+\" does not have data\";\n\t\tvar v = it.next();\n\t\tvar n = it.next();\n\t\tif( n != null ) {\n\t\t\t// handle <spaces>CDATA<spaces>\n\t\t\tif( v.nodeType == Xml.PCData && n.nodeType == Xml.CData && StringTools.trim(v.nodeValue) == \"\" ) {\n\t\t\t\tvar n2 = it.next();\n\t\t\t\tif( n2 == null || (n2.nodeType == Xml.PCData && StringTools.trim(n2.nodeValue) == \"\" && it.next() == null) )\n\t\t\t\t\treturn n.nodeValue;\n\t\t\t}\n\t\t\tthrow name+\" does not only have data\";\n\t\t}\n\t\tif( v.nodeType != Xml.PCData && v.nodeType != Xml.CData )\n\t\t\tthrow name+\" does not have data\";\n\t\treturn v.nodeValue;\n\t}\n\n\tfunction get_innerHTML() {\n\t\tvar s = new StringBuf();\n\t\tfor( x in x )\n\t\t\ts.add(x.toString());\n\t\treturn s.toString();\n\t}\n\n\tfunction get_elements() {\n\t\tvar it = x.elements();\n\t\treturn {\n\t\t\thasNext : it.hasNext,\n\t\t\tnext : function() {\n\t\t\t\tvar x = it.next();\n\t\t\t\tif( x == null )\n\t\t\t\t\treturn null;\n\t\t\t\treturn new Fast(x);\n\t\t\t}\n\t\t};\n\t}\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage haxe.xml;\n\nusing StringTools;\n\n/* poor'man enum : reduce code size + a bit faster since inlined */\nextern private class S {\n\tpublic static inline var IGNORE_SPACES \t= 0;\n\tpublic static inline var BEGIN\t\t\t= 1;\n\tpublic static inline var BEGIN_NODE\t\t= 2;\n\tpublic static inline var TAG_NAME\t\t= 3;\n\tpublic static inline var BODY\t\t\t= 4;\n\tpublic static inline var ATTRIB_NAME\t= 5;\n\tpublic static inline var EQUALS\t\t\t= 6;\n\tpublic static inline var ATTVAL_BEGIN\t= 7;\n\tpublic static inline var ATTRIB_VAL\t\t= 8;\n\tpublic static inline var CHILDS\t\t\t= 9;\n\tpublic static inline var CLOSE\t\t\t= 10;\n\tpublic static inline var WAIT_END\t\t= 11;\n\tpublic static inline var WAIT_END_RET\t= 12;\n\tpublic static inline var PCDATA\t\t\t= 13;\n\tpublic static inline var HEADER\t\t\t= 14;\n\tpublic static inline var COMMENT\t\t= 15;\n\tpublic static inline var DOCTYPE\t\t= 16;\n\tpublic static inline var CDATA\t\t\t= 17;\n\tpublic static inline var ESCAPE\t\t\t= 18;\n}\n\nclass Parser\n{\n\tstatic var escapes = {\n\t\tvar h = new haxe.ds.StringMap();\n\t\th.set(\"lt\", \"<\");\n\t\th.set(\"gt\", \">\");\n\t\th.set(\"amp\", \"&\");\n\t\th.set(\"quot\", '\"');\n\t\th.set(\"apos\", \"'\");\n\t\th.set(\"nbsp\", String.fromCharCode(160));\n\t\th;\n\t}\n\n\tstatic public function parse(str:String)\n\t{\n\t\tvar doc = Xml.createDocument();\n\t\tdoParse(str, 0, doc);\n\t\treturn doc;\n\t}\n\n\tstatic function doParse(str:String, p:Int = 0, ?parent:Xml):Int\n\t{\n\t\tvar xml:Xml = null;\n\t\tvar state = S.BEGIN;\n\t\tvar next = S.BEGIN;\n\t\tvar aname = null;\n\t\tvar start = 0;\n\t\tvar nsubs = 0;\n\t\tvar nbrackets = 0;\n\t\tvar c = str.fastCodeAt(p);\n\t\tvar buf = new StringBuf();\n\t\twhile (!StringTools.isEof(c))\n\t\t{\n\t\t\tswitch(state)\n\t\t\t{\n\t\t\t\tcase S.IGNORE_SPACES:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase\n\t\t\t\t\t\t\t'\\n'.code,\n\t\t\t\t\t\t\t'\\r'.code,\n\t\t\t\t\t\t\t'\\t'.code,\n\t\t\t\t\t\t\t' '.code:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstate = next;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.BEGIN:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '<'.code:\n\t\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\t\tnext = S.BEGIN_NODE;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\t\tstate = S.PCDATA;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.PCDATA:\n\t\t\t\t\tif (c == '<'.code)\n\t\t\t\t\t{\n\t\t\t\t\t\t#if php\n\t\t\t\t\t\tvar child = Xml.createPCDataFromCustomParser(buf.toString() + str.substr(start, p - start));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\tvar child = Xml.createPCData(buf.toString() + str.substr(start, p - start));\n\t\t\t\t\t\t#end\n\t\t\t\t\t\tbuf = new StringBuf();\n\t\t\t\t\t\tparent.addChild(child);\n\t\t\t\t\t\tnsubs++;\n\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\tnext = S.BEGIN_NODE;\n\t\t\t\t\t}\n\t\t\t\t\t#if !flash9\n\t\t\t\t\telse if (c == '&'.code) {\n\t\t\t\t\t\tbuf.addSub(str, start, p - start);\n\t\t\t\t\t\tstate = S.ESCAPE;\n\t\t\t\t\t\tnext = S.PCDATA;\n\t\t\t\t\t\tstart = p + 1;\n\t\t\t\t\t}\n\t\t\t\t\t#end\n\t\t\t\tcase S.CDATA:\n\t\t\t\t\tif (c == ']'.code && str.fastCodeAt(p + 1) == ']'.code && str.fastCodeAt(p + 2) == '>'.code)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar child = Xml.createCData(str.substr(start, p - start));\n\t\t\t\t\t\tparent.addChild(child);\n\t\t\t\t\t\tnsubs++;\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\tstate = S.BEGIN;\n\t\t\t\t\t}\n\t\t\t\tcase S.BEGIN_NODE:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '!'.code:\n\t\t\t\t\t\t\tif (str.fastCodeAt(p + 1) == '['.code)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t\t\tif (str.substr(p, 6).toUpperCase() != \"CDATA[\")\n\t\t\t\t\t\t\t\t\tthrow(\"Expected <![CDATA[\");\n\t\t\t\t\t\t\t\tp += 5;\n\t\t\t\t\t\t\t\tstate = S.CDATA;\n\t\t\t\t\t\t\t\tstart = p + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (str.fastCodeAt(p + 1) == 'D'.code || str.fastCodeAt(p + 1) == 'd'.code)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(str.substr(p + 2, 6).toUpperCase() != \"OCTYPE\")\n\t\t\t\t\t\t\t\t\tthrow(\"Expected <!DOCTYPE\");\n\t\t\t\t\t\t\t\tp += 8;\n\t\t\t\t\t\t\t\tstate = S.DOCTYPE;\n\t\t\t\t\t\t\t\tstart = p + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if( str.fastCodeAt(p + 1) != '-'.code || str.fastCodeAt(p + 2) != '-'.code )\n\t\t\t\t\t\t\t\tthrow(\"Expected <!--\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\t\t\tstate = S.COMMENT;\n\t\t\t\t\t\t\t\tstart = p + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase '?'.code:\n\t\t\t\t\t\t\tstate = S.HEADER;\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\tcase '/'.code:\n\t\t\t\t\t\t\tif( parent == null )\n\t\t\t\t\t\t\t\tthrow(\"Expected node name\");\n\t\t\t\t\t\t\tstart = p + 1;\n\t\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\t\tnext = S.CLOSE;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstate = S.TAG_NAME;\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.TAG_NAME:\n\t\t\t\t\tif (!isValidChar(c))\n\t\t\t\t\t{\n\t\t\t\t\t\tif( p == start )\n\t\t\t\t\t\t\tthrow(\"Expected node name\");\n\t\t\t\t\t\txml = Xml.createElement(str.substr(start, p - start));\n\t\t\t\t\t\tparent.addChild(xml);\n\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\tnext = S.BODY;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.BODY:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '/'.code:\n\t\t\t\t\t\t\tstate = S.WAIT_END;\n\t\t\t\t\t\t\tnsubs++;\n\t\t\t\t\t\tcase '>'.code:\n\t\t\t\t\t\t\tstate = S.CHILDS;\n\t\t\t\t\t\t\tnsubs++;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tstate = S.ATTRIB_NAME;\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.ATTRIB_NAME:\n\t\t\t\t\tif (!isValidChar(c))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp;\n\t\t\t\t\t\tif( start == p )\n\t\t\t\t\t\t\tthrow(\"Expected attribute name\");\n\t\t\t\t\t\ttmp = str.substr(start,p-start);\n\t\t\t\t\t\taname = tmp;\n\t\t\t\t\t\tif( xml.exists(aname) )\n\t\t\t\t\t\t\tthrow(\"Duplicate attribute\");\n\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\tnext = S.EQUALS;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.EQUALS:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '='.code:\n\t\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\t\tnext = S.ATTVAL_BEGIN;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow(\"Expected =\");\n\t\t\t\t\t}\n\t\t\t\tcase S.ATTVAL_BEGIN:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '\"'.code, '\\''.code:\n\t\t\t\t\t\t\tstate = S.ATTRIB_VAL;\n\t\t\t\t\t\t\tstart = p;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow(\"Expected \\\"\");\n\t\t\t\t\t}\n\t\t\t\tcase S.ATTRIB_VAL:\n\t\t\t\t\tif (c == str.fastCodeAt(start))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar val = str.substr(start+1,p-start-1);\n\t\t\t\t\t\txml.set(aname, val);\n\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\tnext = S.BODY;\n\t\t\t\t\t}\n\t\t\t\tcase S.CHILDS:\n\t\t\t\t\tp = doParse(str, p, xml);\n\t\t\t\t\tstart = p;\n\t\t\t\t\tstate = S.BEGIN;\n\t\t\t\tcase S.WAIT_END:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '>'.code:\n\t\t\t\t\t\t\tstate = S.BEGIN;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\tthrow(\"Expected >\");\n\t\t\t\t\t}\n\t\t\t\tcase S.WAIT_END_RET:\n\t\t\t\t\tswitch(c)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase '>'.code:\n\t\t\t\t\t\t\tif( nsubs == 0 )\n\t\t\t\t\t\t\t\tparent.addChild(Xml.createPCData(\"\"));\n\t\t\t\t\t\t\treturn p;\n\t\t\t\t\t\tdefault :\n\t\t\t\t\t\t\tthrow(\"Expected >\");\n\t\t\t\t\t}\n\t\t\t\tcase S.CLOSE:\n\t\t\t\t\tif (!isValidChar(c))\n\t\t\t\t\t{\n\t\t\t\t\t\tif( start == p )\n\t\t\t\t\t\t\tthrow(\"Expected node name\");\n\n\t\t\t\t\t\tvar v = str.substr(start,p - start);\n\t\t\t\t\t\tif (v != parent.nodeName)\n\t\t\t\t\t\t\tthrow \"Expected </\" +parent.nodeName + \">\";\n\n\t\t\t\t\t\tstate = S.IGNORE_SPACES;\n\t\t\t\t\t\tnext = S.WAIT_END_RET;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\tcase S.COMMENT:\n\t\t\t\t\tif (c == '-'.code && str.fastCodeAt(p +1) == '-'.code && str.fastCodeAt(p + 2) == '>'.code)\n\t\t\t\t\t{\n\t\t\t\t\t\tparent.addChild(Xml.createComment(str.substr(start, p - start)));\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\tstate = S.BEGIN;\n\t\t\t\t\t}\n\t\t\t\tcase S.DOCTYPE:\n\t\t\t\t\tif(c == '['.code)\n\t\t\t\t\t\tnbrackets++;\n\t\t\t\t\telse if(c == ']'.code)\n\t\t\t\t\t\tnbrackets--;\n\t\t\t\t\telse if (c == '>'.code && nbrackets == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tparent.addChild(Xml.createDocType(str.substr(start, p - start)));\n\t\t\t\t\t\tstate = S.BEGIN;\n\t\t\t\t\t}\n\t\t\t\tcase S.HEADER:\n\t\t\t\t\tif (c == '?'.code && str.fastCodeAt(p + 1) == '>'.code)\n\t\t\t\t\t{\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tvar str = str.substr(start + 1, p - start - 2);\n\t\t\t\t\t\tparent.addChild(Xml.createProcessingInstruction(str));\n\t\t\t\t\t\tstate = S.BEGIN;\n\t\t\t\t\t}\n\t\t\t\tcase S.ESCAPE:\n\t\t\t\t\tif (c == ';'.code)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar s = str.substr(start, p - start);\n\t\t\t\t\t\tif (s.fastCodeAt(0) == '#'.code) {\n\t\t\t\t\t\t\tvar i = s.fastCodeAt(1) == 'x'.code\n\t\t\t\t\t\t\t\t? Std.parseInt(\"0\" +s.substr(1, s.length - 1))\n\t\t\t\t\t\t\t\t: Std.parseInt(s.substr(1, s.length - 1));\n\t\t\t\t\t\t\tbuf.add(String.fromCharCode(i));\n\t\t\t\t\t\t} else if (!escapes.exists(s))\n\t\t\t\t\t\t\tbuf.add('&$s;');\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbuf.add(escapes.get(s));\n\t\t\t\t\t\tstart = p + 1;\n\t\t\t\t\t\tstate = next;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tc = str.fastCodeAt(++p);\n\t\t}\n\n\t\tif (state == S.BEGIN)\n\t\t{\n\t\t\tstart = p;\n\t\t\tstate = S.PCDATA;\n\t\t}\n\n\t\tif (state == S.PCDATA)\n\t\t{\n\t\t\tif (p != start || nsubs == 0)\n\t\t\t\tparent.addChild(Xml.createPCData(buf.toString() + str.substr(start, p - start)));\n\t\t\treturn p;\n\t\t}\n\n\t\tthrow \"Unexpected end\";\n\t}\n\n\tstatic inline function isValidChar(c) {\n\t\treturn (c >= 'a'.code && c <= 'z'.code) || (c >= 'A'.code && c <= 'Z'.code) || (c >= '0'.code && c <= '9'.code) || c == ':'.code || c == '.'.code || c == '_'.code || c == '-'.code;\n\t}\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nclass Boot {\n\n\tprivate static function __unhtml(s : String) {\n\t\treturn s.split(\"&\").join(\"&amp;\").split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\");\n\t}\n\n\tprivate static function __trace(v,i : haxe.PosInfos) {\n\t\tuntyped {\n\t\t\tvar msg = if( i != null ) i.fileName+\":\"+i.lineNumber+\": \" else \"\";\n\t\t\t#if jsfl\n\t\t\tmsg += __string_rec(v,\"\");\n\t\t\tfl.trace(msg);\n\t\t\t#else\n\t\t\tmsg += __string_rec(v, \"\");\n\t\t\tif( i != null && i.customParams != null )\n\t\t\t\tfor( v in i.customParams )\n\t\t\t\t\tmsg += \",\" + __string_rec(v, \"\");\n\t\t\tvar d;\n\t\t\tif( __js__(\"typeof\")(document) != \"undefined\" && (d = document.getElementById(\"haxe:trace\")) != null )\n\t\t\t\td.innerHTML += __unhtml(msg)+\"<br/>\";\n\t\t\telse if( __js__(\"typeof console\") != \"undefined\" && __js__(\"console\").log != null )\n\t\t\t\t__js__(\"console\").log(msg);\n\t\t\t#end\n\t\t}\n\t}\n\n\tprivate static function __clear_trace() {\n\t\tuntyped {\n\t\t\t#if jsfl\n\t\t\tfl.outputPanel.clear();\n\t\t\t#else\n\t\t\tvar d = document.getElementById(\"haxe:trace\");\n\t\t\tif( d != null )\n\t\t\t\td.innerHTML = \"\";\n\t\t\t#end\n\t\t}\n\t}\n\n\tstatic inline function isClass(o:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isClass\", o.__name__);\n\t}\n\n\tstatic inline function isEnum(e:Dynamic) : Bool {\n\t\treturn untyped __define_feature__(\"js.Boot.isEnum\", e.__ename__);\n\t}\n\n\tstatic inline function getClass(o:Dynamic) : Dynamic {\n\t\tif (Std.is(o, Array))\n\t\t\treturn Array;\n\t\telse\n\t\t\treturn untyped __define_feature__(\"js.Boot.getClass\", o.__class__);\n\t}\n\n\t@:ifFeature(\"may_print_enum\")\n\tprivate static function __string_rec(o,s:String) {\n\t\tuntyped {\n\t\t\tif( o == null )\n\t\t\t    return \"null\";\n\t\t\tif( s.length >= 5 )\n\t\t\t\treturn \"<...>\"; // too much deep recursion\n\t\t\tvar t = __js__(\"typeof(o)\");\n\t\t\tif( t == \"function\" && (isClass(o) || isEnum(o)) )\n\t\t\t\tt = \"object\";\n\t\t\tswitch( t ) {\n\t\t\tcase \"object\":\n\t\t\t\tif( __js__(\"o instanceof Array\") ) {\n\t\t\t\t\tif( o.__enum__ ) {\n\t\t\t\t\t\tif( o.length == 2 )\n\t\t\t\t\t\t\treturn o[0];\n\t\t\t\t\t\tvar str = o[0]+\"(\";\n\t\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\t\tfor( i in 2...o.length ) {\n\t\t\t\t\t\t\tif( i != 2 )\n\t\t\t\t\t\t\t\tstr += \",\" + __string_rec(o[i],s);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tstr += __string_rec(o[i],s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn str + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tvar l = o.length;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar str = \"[\";\n\t\t\t\t\ts += \"\\t\";\n\t\t\t\t\tfor( i in 0...l )\n\t\t\t\t\t\tstr += (if (i > 0) \",\" else \"\")+__string_rec(o[i],s);\n\t\t\t\t\tstr += \"]\";\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tvar tostr;\n\t\t\t\ttry {\n\t\t\t\t\ttostr = untyped o.toString;\n\t\t\t\t} catch( e : Dynamic ) {\n\t\t\t\t\t// strange error on IE\n\t\t\t\t\treturn \"???\";\n\t\t\t\t}\n\t\t\t\tif( tostr != null && tostr != __js__(\"Object.toString\") ) {\n\t\t\t\t\tvar s2 = o.toString();\n\t\t\t\t\tif( s2 != \"[object Object]\")\n\t\t\t\t\t\treturn s2;\n\t\t\t\t}\n\t\t\t\tvar k : String = null;\n\t\t\t\tvar str = \"{\\n\";\n\t\t\t\ts += \"\\t\";\n\t\t\t\tvar hasp = (o.hasOwnProperty != null);\n\t\t\t\t__js__(\"for( var k in o ) {\");\n\t\t\t\t\tif( hasp && !o.hasOwnProperty(k) )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( k == \"prototype\" || k == \"__class__\" || k == \"__super__\" || k == \"__interfaces__\" || k == \"__properties__\" )\n\t\t\t\t\t\t__js__(\"continue\");\n\t\t\t\t\tif( str.length != 2 )\n\t\t\t\t\t\tstr += \", \\n\";\n\t\t\t\t\tstr += s + k + \" : \"+__string_rec(o[k],s);\n\t\t\t\t__js__(\"}\");\n\t\t\t\ts = s.substring(1);\n\t\t\t\tstr += \"\\n\" + s + \"}\";\n\t\t\t\treturn str;\n\t\t\tcase \"function\":\n\t\t\t\treturn \"<function>\";\n\t\t\tcase \"string\":\n\t\t\t\treturn o;\n\t\t\tdefault:\n\t\t\t\treturn String(o);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static function __interfLoop(cc : Dynamic,cl : Dynamic) {\n\t\tif( cc == null )\n\t\t\treturn false;\n\t\tif( cc == cl )\n\t\t\treturn true;\n\t\tvar intf : Dynamic = cc.__interfaces__;\n\t\tif( intf != null )\n\t\t\tfor( i in 0...intf.length ) {\n\t\t\t\tvar i : Dynamic = intf[i];\n\t\t\t\tif( i == cl || __interfLoop(i,cl) )\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\treturn __interfLoop(cc.__super__,cl);\n\t}\n\n\t@:ifFeature(\"typed_catch\") private static function __instanceof(o : Dynamic,cl : Dynamic) {\n\t\tif( cl == null )\n\t\t\treturn false;\n\t\tswitch( cl ) {\n\t\tcase Int:\n\t\t\treturn (untyped __js__(\"(o|0) === o\"));\n\t\tcase Float:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"number\";\n\t\tcase Bool:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"boolean\";\n\t\tcase String:\n\t\t\treturn (untyped __js__(\"typeof\"))(o) == \"string\";\n\t\tcase Array:\n\t\t\treturn (untyped __js__(\"(o instanceof Array)\")) && o.__enum__ == null;\n\t\tcase Dynamic:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tif( o != null ) {\n\t\t\t\t// Check if o is an instance of a Haxe class\n\t\t\t\tif( (untyped __js__(\"typeof\"))(cl) == \"function\" ) {\n\t\t\t\t\tif( untyped __js__(\"o instanceof cl\") ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif( __interfLoop(getClass(o),cl) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// do not use isClass/isEnum here\n\t\t\tuntyped __feature__(\"Class.*\",if( cl == Class && o.__name__ != null ) return true);\n\t\t\tuntyped __feature__(\"Enum.*\",if( cl == Enum && o.__ename__ != null ) return true);\n\t\t\treturn o.__enum__ == cl;\n\t\t}\n\t}\n\n\t@:ifFeature(\"typed_cast\") private static function __cast(o : Dynamic, t : Dynamic) {\n\t\tif (__instanceof(o, t)) return o;\n\t\telse throw \"Cannot cast \" +Std.string(o) + \" to \" +Std.string(t);\n\t}\n\n}\n","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\npackage js;\n\nclass Lib {\n\n\t/**\n\t\tInserts a 'debugger' statement that will make a breakpoint if a debugger is available.\n\t**/\n\tpublic static inline function debug() {\n\t\tuntyped __js__(\"debugger\");\n\t}\n\n\t/**\n\t\tDisplay an alert message box containing the given message\n\t**/\n\tpublic static function alert( v : Dynamic ) {\n\t\tuntyped __js__(\"alert\")(js.Boot.__string_rec(v,\"\"));\n\t}\n\n\tpublic static inline function eval( code : String ) : Dynamic {\n\t\treturn untyped __js__(\"eval\")(code);\n\t}\n\n}\n","/*\n * Copyright (C)2005-2014 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n\n// This file is generated, do not edit!\npackage js.html;\n\n/** DOM&nbsp;canvas elements expose the <code><a class=\"external\" href=\"http://www.w3.org/TR/html5/the-canvas-element.html#htmlcanvaselement\" rel=\"external nofollow\" target=\"_blank\" title=\"http://www.w3.org/TR/html5/the-canvas-element.html#htmlcanvaselement\">HTMLCanvasElement</a></code> interface, which provides properties and methods for manipulating the layout and presentation of canvas elements. The <code>HTMLCanvasElement</code> interface inherits the properties and methods of the <code><a rel=\"custom\" href=\"/api/js/html/Element\">element</a></code>\n object interface.<br><br>\nDocumentation for this class was provided by <a href=\"https://developer.mozilla.org/en/DOM/HTMLCanvasElement\">MDN</a>. */\n@:native(\"HTMLCanvasElement\")\nextern class CanvasElement extends Element\n{\n\t/** Reflects the \n\n<code><a rel=\"custom\" href=\"https://developer.mozilla.org/en/HTML/Element/canvas#attr-height\">height</a></code>\n HTML attribute, specifying the height of the coordinate space in CSS pixels. */\n\tvar height : Int;\n\n\t/** Reflects the \n\n<code><a rel=\"custom\" href=\"https://developer.mozilla.org/en/HTML/Element/canvas#attr-width\">width</a></code>\n HTML attribute, specifying the width of the coordinate space in CSS pixels. */\n\tvar width : Int;\n\n\tfunction getContext( contextId : String ) : Dynamic;\n\n\tfunction toDataURL( ?type : String ) : String;\n\n\t/** A typed shortcut for <code>getContext(\"2d\")</code>. */\n\tpublic inline function getContext2d() : CanvasRenderingContext2D { return cast getContext(\"2d\"); }\n\n\tpublic inline function getContextWebGL( ?attribs :js.html.webgl.ContextAttributes ) :js.html.webgl.RenderingContext {\n\t\treturn CanvasUtil.getContextWebGL(this, attribs);\n\t}\n}\n\nprivate class CanvasUtil {\n\tpublic static function getContextWebGL( canvas :CanvasElement, attribs :Dynamic ) {\n\t\tfor (name in [\"webgl\", \"experimental-webgl\"]) {\n\t\t\tvar ctx = (untyped canvas).getContext(name, attribs);\n\t\t\tif (ctx != null) return ctx;\n\t\t}\n\t\treturn null;\n\t}\n}","package physics;\nimport haxe.Timer;\nimport physics.collision.narrowphase.INarrowphase;\nimport physics.collision.narrowphase.sat.SAT;\nimport physics.dynamics.Body;\nimport physics.dynamics.BodyContactManager;\nimport physics.geometry.AABB;\nimport physics.geometry.Circle;\nimport physics.geometry.GeometricShape;\nimport physics.geometry.Polygon;\nimport physics.geometry.Ray;\nimport physics.geometry.Shapes;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass PhysicsEngine \n{\n\tpublic var fps : Float;\n\tpublic var pps : Float;\n\tpublic var physicsDeltaTime : Float;\n\t\n\tpublic var currTime : Float;\n\tpublic var deltaTime : Float;\n\t\n\tpublic var msPerFrame : Float;\n\tpublic var msPerPhysics : Float;\n\tprivate var accumulator : Float;\n\t\n\tpublic var step : Int;\n\tpublic var update : Int;\n\t\n\tpublic var forces : Vector2D;\n\tpublic var masslessForces : Vector2D;\n\t\n\tpublic var damping:Float;\n\n\tpublic var narrowphase : INarrowphase;\n\t\n\tpublic var contactManager : BodyContactManager;\n\t\t\n\tpublic function new(fps : Float, pps : Float, narrowphase:INarrowphase) \n\t{\n\t\tthis.fps = fps;\n\t\tthis.pps = pps;\n\t\tthis.narrowphase = narrowphase;\n\n\t\tInitalize();\n\t}\n\t\n\tfunction Initalize():Void {\n\n\t\t//contactManager = new BodyContactManager(this);\n\t\t\n\t\tthis.narrowphase.bodyContactManager = contactManager;\n\t\t\n\t\taccumulator = 0.0;\n\t\tcurrTime = 0.0;\n\t\tmsPerFrame = 1000 / fps;\n\t\tmsPerPhysics = 1000 / pps;\n\t\tphysicsDeltaTime = 1 / pps;\n\t\tstep = 0;\n\t\t\n\t\tforces = new Vector2D();\n\t\tmasslessForces = new Vector2D();\n\n\t\tdamping = 0.995;\n\n\t}\n\n\tpublic function Step() : Void {\n\t\tstep++;\n\t\tvar newTime : Float = Date.now().getTime();\n\t\tdeltaTime = newTime - currTime;\n\t\tcurrTime = newTime;\n\n\t\t// Run onStep updates for all bodies\n\t\tProcessOnStep(step);\n\t\t\n\t\tif (deltaTime > 100) deltaTime = 100;\n\t\t// Run the physics\n\t\taccumulator += deltaTime;\n\t\t\n\t\twhile (accumulator >= msPerPhysics) {\n\t\t\taccumulator -= msPerPhysics;\n\t\t\tupdate++;\n\t\t\tUpdate();\n\t\t\tCollide();\n\t\t}\n\n\t\t// Process Body contacts\n\t\tif (contactManager!=null)\n\t\t\tcontactManager.ProcessBodyContacts();\n\n\t}\n\t\n\tpublic function Update():Void {\t\t\n\t}\n\t\n\tpublic function Collide():Void {\n\t}\n\t\n\tpublic function StartStaticUpdate(body:Body):Void {\n\t\t\n\t}\n\t\n\tpublic function EndStaticUpdate(body:Body):Void {\n\t\t\n\t}\n\t\n\tpublic function ProcessOnStep(step:Int):Void {\n\t\t\n\t}\n\t\t\n\tpublic function AddBody(body : Body) : Void {\n\t\tbody.OnAddedToEngine(this);\n\t}\n\n\tpublic function RemoveBody(body : Body) : Void {\n\t}\n\t\n\tpublic function SleepItem(body:Body):Bool {\n\t\treturn true;\n\t}\n\t\n\tpublic function WakeItem(body:Body):Bool {\n\t\treturn true;\n\t}\n\t\n\tpublic function CastRay(ray : Ray)  : Vector2D {\n\t\treturn null;\n\t}\n\t\n\tpublic function Search(position:Vector2D,radius:Float,result:Body->Float->Void):Void {\n\t\treturn null;\n\t}\n\n\t// public function ProcessAction(action : IBroadphaseAction) : Void {\n\t\t\n\t// }\n\t\n\tpublic function ProcessShapes(position:Vector2D, range:Float, action:GeometricShape -> Vector2D -> Void ) {\n\n\t}\n\t\t\n}","\npackage physics.collision.broadphase.managedgrid;\n \nimport physics.dynamics.Body;\nimport physics.geometry.AABB;\nimport physics.geometry.Vector2D;\n\n\nclass Cell \n{\n\n    public var index:Int;\n    public var x:Float;\n    public var y:Float;\n\n    public var aabb:AABB;\n    public var width:Float;\n    public var height:Float;\n\n    public var dynamicItems:Array<Body>;\n    public var sleepingItems:Array<Body>;\n    public var staticItems:Array<Body>;\n\n    public var adjacentCells:Array<Cell>;\n\n    public function new(index:Int, x:Float, y:Float, w:Float, h:Float) {\n        this.index = index;\n        this.x = x;\n        this.y = y;\n        this.width = w;\n        this.height = h;\n        aabb = new AABB(x, y + h, x + w, y);\n\n        dynamicItems = new Array<Body>();\n        sleepingItems = new Array<Body>();\n        staticItems = new Array<Body>();\n\n        adjacentCells = new Array<Cell>();\n    }\n\n    public function AddBody(body:Body) {\n        body.broadphaseData1 = index;\n        if (body.isStatic) {\n            staticItems.push(body);\n        } else {\n            dynamicItems.push(body);\n        }\n    }\n\n    public function RemoveBody(body:Body) {\n        if (body.isStatic) {\n            staticItems.remove(body);\n        } else {\n            dynamicItems.remove(body);\n        }\n        body.broadphaseData1 = -1;\n    }\n\n    function SearchList(list:Array<Body>, position:Vector2D,radius:Float, result:Body->Float->Void):Void {\n        var radiusSqrd = radius*radius;\n        for (body in list) {\n                var dX : Float = position.x - body.averageCenter.x;\n                var dY : Float = position.y - body.averageCenter.y;\n                var dSqrd : Float = dX * dX + dY * dY;\n                if (dSqrd <= (radiusSqrd - body.radiusSqrd)) {\n                    result(body,dSqrd);\n                    //actionResultCollection.AddResult(body,dSqrd);\n                }\n        }\n    }\n    public function SearchCell(position:Vector2D,radius:Float,result:Body->Float->Void):Void {\n        SearchList(dynamicItems,position,radius,result);\n        //SearchList(sleepingItems, action, actionResultCollection);\n        //SearchList(staticItems, action, actionResultCollection);\n    }\n\n}   ","\npackage physics.collision.broadphase.managedgrid;\n\nimport ds.AABBTree;\nimport ds.Grid2D;\nimport physics.collision.broadphase.managedgrid.Cell;\nimport physics.collision.narrowphase.INarrowphase;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\nimport physics.PhysicsEngine;\n\nclass ManagedGrid extends PhysicsEngine\n{\n\n    public var grid:Grid2D<Cell>;\n    public var worldExtents:physics.geometry.AABB;\n\n    // public var tree:AABBTree<Body>;\n\n    public function new(fps : Int, pps : Int, narrowphase:INarrowphase, worldGridWidth:Int, worldGridHeight:Int, cellSize:Int) \n    {\n        super(fps, pps, narrowphase);\n        \n        grid = new Grid2D<Cell>(worldGridWidth, worldGridHeight, cellSize);\n\n        // tree = new ds.AABBTree<Body>(10, new ds.aabbtree.InsertStrategyArea());\n\n        init();\n    }\n\n\n    function init():Void {    \n        var index = 0;\n        for (y in 0...grid.gridWidth) {\n            for (x in 0...grid.gridHeight) {\n                grid.data.push(new Cell(index++,x*grid.cellSize,y*grid.cellSize,grid.cellSize,grid.cellSize));\n            }\n        }\n        for (y in 0...grid.gridWidth) {\n            for (x in 0...grid.gridHeight) {\n                var cell = grid.GetGridSafe(x, y);\n                cell.adjacentCells.push(grid.GetGridSafe(x-1, y));\n                cell.adjacentCells.push(grid.GetGridSafe(x-1, y-1));\n                cell.adjacentCells.push(grid.GetGridSafe(x, y - 1));\n                cell.adjacentCells.push(grid.GetGridSafe(x+1, y - 1));\n                cell.adjacentCells.push(grid.GetGridSafe(x+1, y));\n                cell.adjacentCells.push(grid.GetGridSafe(x+1, y+1));\n                cell.adjacentCells.push(grid.GetGridSafe(x, y + 1));\n                cell.adjacentCells.push(grid.GetGridSafe(x - 1, y + 1));\n            }\n        }\n    }\n\n    override public function Update() {\n        for (cell in grid.data) {        \n            for (body in cell.dynamicItems) {\n                body.Update(step);\n                if (!cell.aabb.containtsPoint(body.position)) {\n                    cell.RemoveBody(body);\n                    AddBodyToCell(body);\n                }\n            }\n        }\n        // var ids = tree.getLeavesIds();\n        // for (id in ids) {\n        //     var e = tree.getData(id);\n        //     tree.updateLeaf(id, e.position.x,e.position.y,e.aabb.width(),e.aabb.height() );\n        // }\n    }\n\n   override public function Collide() {\n        for (cell in grid.data) {        \n            for (i in 0...cell.dynamicItems.length) {\n                var bodyA = cell.dynamicItems[i];\n                for (j in i+1...cell.dynamicItems.length) {\n                    var bodyB = cell.dynamicItems[j];\n                    narrowphase.CollideBodies(bodyA,bodyB);\n                }\n            }\n        }\n    }\n\n    override public function AddBody(body : Body) : Void {\n        super.AddBody(body);\n        AddBodyToCell(body);\n        // tree.insertLeaf(body,body.position.x,body.position.y,body.aabb.width(),body.aabb.height());\n    }\n\n    public function AddBodyToCell(body:Body) {\n        var x = grid.Index(body.position.x);\n        var y = grid.Index(body.position.y);\n        var cell = grid.GetGridSafe(x,y);\n        if (cell!=null)\n            cell.AddBody(body);\n    }\n\n    override public function RemoveBody(body : Body) : Void {\n        var cell = grid.data[body.broadphaseData1];       \n        var index = cell.dynamicItems.indexOf(body);\n        if (index>=0) {\n            cell.dynamicItems.splice(index,1);\n            return;\n        }\n    }\n\n    override public function Search(position:Vector2D,radius:Float,result:Body->Float->Void):Void {\n        for (cell in grid.data) {        \n            cell.SearchCell(position,radius,result);\n        }\n    }\n\n}","package physics.collision.narrowphase.sat;\nimport physics.collision.narrowphase.INarrowphase;\nimport physics.Constants;\nimport physics.dynamics.Arbiter;\nimport physics.dynamics.Body;\nimport physics.dynamics.BodyContact;\nimport physics.dynamics.BodyContactManager;\nimport physics.dynamics.Feature;\nimport physics.geometry.AABB;\nimport physics.geometry.Axis;\nimport physics.geometry.Circle;\nimport physics.geometry.GeometricShape;\nimport physics.geometry.Polygon;\nimport physics.geometry.Segment;\nimport physics.geometry.Shapes;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass SAT implements INarrowphase\n{\n\t\n\tpublic var result : Arbiter; \n\n\tpublic var bodyContactManager:BodyContactManager;\n\t\n\tpublic function new() \n\t{\n\t\tresult = new Arbiter();\n\t}\n\t\n\tinline public function CollideBodies(body1:Body, body2:Body, n:Vector2D = null):Void {\n\t\t// if (body1.features.length == 1 && body2.features.length == 1) {\n\t\t// \t//bypass AABB comparison\n\t\t// \tCollideFeatures(body1.features[0], body2.features[0], n);\n\t\t// } else {\n\t\t\tfor (feature1 in body1.features) {\n\t\t\t\tfor (feature2 in body2.features) {\n\t\t\t\t\tif (AABB.intersects(feature1.shape.aabb, feature1.body.position, feature2.shape.aabb, feature2.body.position))\n\t\t\t\t\t\tCollideFeatures(feature1, feature2, n);\n\t\t\t\t}\n\t\t\t}\n\t\t// }\n\t}\n\t\n\tpublic function CollideFeatures(feature1 : Feature, feature2 : Feature , n:Vector2D = null) : Bool {\n\t\t\n\t\tif (feature1.body == feature2.body) return false;\n\t\t// Shapes are on the same layer? exit...\n\t\tif (feature1.body.layers & feature2.body.layers == 0) return false;\n\t\t// Shapes are in the same group? exit...\n\t\tif ((feature1.body.group > 0 && feature2.body.group > 0 && feature1.body.group == feature2.body.group)) return false;\n\n\t\t//if ((feature1.group && feature2.group && feature1.group == feature2.group)) return false;\n\n\t\t// if (!(feature1.shape.aabb.intersects(feature2.shape.aabb))) return false;\n\n\t\tvar s1 : GeometricShape = feature1.shape;\n\t\tvar s2 : GeometricShape = feature2.shape;\n\n\t\t// var result : Arbiter = new Arbiter();\n\t\tresult.contactCount = 0;\n\t\tif (s1.typeID > s2.typeID) {\n\t\t\tvar tempShape2 : GeometricShape = s1;\n\t\t\ts1 = s2;\n\t\t\ts2 = tempShape2;\n\t\t\tresult.feature1 = feature2;\n\t\t\tresult.feature2 = feature1;\n\t\t} else {\n\t\t\tresult.feature1 = feature1;\n\t\t\tresult.feature2 = feature2;\n\t\t}\n\t\tvar collided : Bool = false;\n\t\t// Choose and call the correct collision function based on the two shapes.\n\t\t\n\t\tif (s1.typeID == Shapes.AXIS_ALIGNED_BOX_SHAPE)\n\t\t// I can also assume that the broadphase already did this...\n\t\t// collided = s1.aabb.intersects(s2.aabb);\n\t\t\tcollided = true;\n\t\telse {\n\t\t\t\n\t\t\tswitch (s1.typeID | s2.typeID) {\n\t\t\t\tcase (Shapes.POLYGON_POLYGON) :\n\t\t\t\t\tcollided = SAT.poly2poly(cast s1, result.feature1.position, cast s2, result.feature2.position, result);\n\t\t\t\tcase (Shapes.CIRCLE_POLYGON) :\n\t\t\t\t\tcollided = SAT.circle2poly(cast s1, result.feature1.position, cast s2, result.feature2.position, result);\n\t\t\t\tcase (Shapes.CIRCLE_CIRCLE) :\n\t\t\t\t\tcollided = SAT.circle2circle(cast s1, result.feature1.position, cast s2, result.feature2.position, result);\n\t\t\t\tcase (Shapes.CIRCLE_SEGMENT) :\n\t\t\t\t\tcollided = SAT.circle2segment(cast s1, result.feature1.position, cast s2, result.feature2.position, result);\n\t\t\t\t/*case (Shapes.SEGMENT_POLYGON) :\n\t\t\t\t\tcollided = SAT.segment2poly(Segment(s1), Polygon(s2), result);\n\t\t\t\t\tbreak;*/\n\t\t\t}\n\t\t}\n\t\t// trace(\"c=\"+collided);\n\t\t// The narrow phase reported a collision.\n\t\tif (collided) {\n\t\t\tfeature1.body.Wake();// broadphase.WakeBody(feature1.body);\n\t\t\tfeature2.body.Wake();\n\t\t\t//FIXME\n\t\t\t//Collision normal override...yikes\n\t\t\t//if (n) result.contacts[0].n.copy(n);\n\t\t\t\n\t\t\tif (result.Resolve()) {\n\t\t\t\tif (bodyContactManager != null)\n\t\t\t\t\tbodyContactManager.UpdateContacts(feature1.body, feature2.body);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tstatic public function poly2poly( shape1:Polygon ,shape1Pos:Vector2D, shape2:Polygon ,shape2Pos:Vector2D , arbiter:Arbiter ):Bool {\n\t\t\t\n\t\tvar vertValOnAxis:Float;\n\t\tvar minValOnAxis:Float;\n\n\t\tvar minPen1:Float = -Constants.FMAX;\n\t\tvar minAxis1:Axis = null;\n\t\t\n\t\t//First, project shape 2 vertices onto shape 1 axes & find MSA\n\t\t//var a:Axis;\n\t\t//for (i in 0...shape1.vertexCount) {\n\t\tfor (a in shape1.transformedAxes) {\n\t\t\t//a = shape1.transformedAxes[i];\n\t\t\tminValOnAxis = shape2.ValueOnAxis(a,shape1Pos,shape2Pos);\n\t\t\t//No penetration on this axis, early out\n\t\t\tif (minValOnAxis > 0) return false; \n\t\t\tif (minValOnAxis > minPen1) {\n\t\t\t\tminPen1 = minValOnAxis;\n\t\t\t\tminAxis1 = a;\n\t\t\t}\n\t\t}\n\n\t\tvar minPen2:Float = -Constants.FMAX;\n\t\tvar minAxis2:Axis = null;\n\n\t\t//Second, project shape 1 vertices onto shape 2 axes & find MSA\n\t\t//for (i in 0...shape2.vertexCount) {\n\t\tfor (a in shape2.transformedAxes) {\n\t\t\t//a = shape2.transformedAxes[i];\n\t\t\tminValOnAxis = shape1.ValueOnAxis(a,shape2Pos,shape1Pos);\n\t\t\t//No penetration on this axis, early out\n\t\t\tif (minValOnAxis > 0) return false;\n\t\t\tif (minValOnAxis > minPen2) {\n\t\t\t\tminPen2 = minValOnAxis;\n\t\t\t\tminAxis2 = a;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar minAxis:Axis;\n\t\tvar nCoef:Float;\n\t\tvar dist:Float;\n\t\t\n\t\tif (minPen1 > minPen2) {\n\t\t\tminAxis = minAxis1;\n\t\t\tnCoef = 1;\n\t\t\tdist = minPen1;\n\t\t} else {\n\t\t\tminAxis = minAxis2;\n\t\t\tnCoef = -1;\n\t\t\tdist = minPen2;\t\t\t\t\n\t\t}\n\t\t//FIXME Add correct points\n\t\tarbiter.AddContact(0, 0, minAxis.n.x, minAxis.n.y, nCoef, dist );\n\t\t\n\t\treturn true;\n\t}\n\t\n\tstatic public function circle2circle( circle1:Circle , circle1Pos:Vector2D, circle2:Circle, circle2Pos:Vector2D , arbiter:Arbiter ):Bool {\n\t\treturn circle2circleQuery(circle1.transformedCentre.x + circle1Pos.x, circle1.transformedCentre.y + circle1Pos.y, circle2.transformedCentre.x + circle2Pos.x, circle2.transformedCentre.y + circle2Pos.y, circle1.radius, circle2.radius, arbiter);\n\t}\n\t\n\tinline static function circle2circleQuery( p1x:Float, p1y:Float , p2x:Float, p2y:Float , r1:Float , r2:Float, arbiter:Arbiter ):Bool {\n\t\tvar minDist = r1+r2;\n\t\tvar x = p2x - p1x;\n\t\tvar y = p2y - p1y;\n\t\tvar distSqr = x * x + y * y;\n\t\tvar result = false;\n\t\tif (distSqr < (minDist * minDist) ) {\n\t\t\tvar dist = Math.sqrt(distSqr) + 0.0000001;\n\t\t\tvar invDist = 1 / dist;\n\t\t\tvar deltaFact = 0.5 + (r1 - 0.5 * minDist) / dist;\t\t\t\n\t\t\tarbiter.AddContact( p1x + x * deltaFact , \n\t\t\t\t\t\t\t\tp1y + y * deltaFact ,\n\t\t\t\t\t\t\t\tx * invDist,\n\t\t\t\t\t\t\t\ty * invDist,\n\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\tdist - minDist);\n\t\t\tresult = true;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tstatic public function circle2poly( circle:Circle , circlePos:Vector2D, poly:Polygon , polyPos:Vector2D, arbiter:Arbiter):Bool {\n\t\t\n\t\tvar miniA:Axis = null;\n\t\t\n\t\tvar min = -Constants.FMAX;\n\n\t\tvar tCx = circle.transformedCentre.x+circlePos.x;\n\t\tvar tCy = circle.transformedCentre.y+circlePos.y;\n\t\t\n\t\tvar miniVindex:Int = 0;\n\t\tfor (i in 0...poly.vertexCount) {\n\t\t\tvar tA = poly.transformedAxes[i];\n\t\t\tvar dist = (tA.n.x * tCx + tA.n.y * tCy) - ((polyPos.x * tA.n.x + polyPos.y * tA.n.y) + tA.d) - circle.radius;//tA.d - circle.r;\n\t\t\tif (dist > 0)\n\t\t\t\treturn false;\n\t\t\tif (dist > min) {\n\t\t\t\tmin = dist;\n\t\t\t\tminiA = tA;\n\t\t\t\tminiVindex = i;\n\t\t\t}\n\t\t}\n\t\tvar miniV = poly.transformedVertices[miniVindex];\n\t\t\n\t\tvar n = miniA.n;\n\t\tvar ax = miniV.x + polyPos.x;\n\t\tvar ay = miniV.y + polyPos.y;\n\t\tminiVindex++;\n\t\t\n\t\tvar b = poly.transformedVertices[miniVindex % poly.vertexCount];\n\t\tvar bx = b.x + polyPos.x;\n\t\tvar by = b.y + polyPos.y;\n\t\t\n\t\tvar dtb = n.x * by - n.y * bx;\n\t\tvar dt  = n.x * tCy - n.y * tCx;\n\t\t\n\t\tif (dt < dtb) \n\t\t\treturn circle2circleQuery(tCx,tCy, bx, by, circle.radius, 0,arbiter);\n\t\t\n\t\tvar dta = n.x * ay - n.y * ax;\t\n\t\t\t\n\t\tif (dt < dta) {\n\t\t\tvar factor = circle.radius + ( min / 2);\n\t\t\tarbiter.AddContact( tCx - (n.x * factor), tCy - (n.y * factor), n.x, n.y , -1, min) ;\t\t\t\t\n\t\t\treturn true;\n\t\t} \n\t\t\t\n\t\treturn circle2circleQuery(tCx, tCy, ax, ay, circle.radius, 0,arbiter);\n\t}\n\n\tstatic public function circle2segment( circle:Circle , circlePos:Vector2D, segment:Segment , segmentPos:Vector2D, arbiter:Arbiter):Bool {\n\t\tvar tAP = segment.tA.plus(segmentPos);\n\t\tvar tCP = circle.transformedCentre.plus(circlePos);\n\t\t\n\t\tvar closest_t = segment.delta.dot(tCP.minus(tAP)) / segment.delta.lengthSqr();\n\t\tif (closest_t < 0)\n\t\t\tclosest_t = 0;\n\t\tif (closest_t > 1)\n\t\t\tclosest_t = 1;\n\t\tvar closest = tAP.plus(segment.delta.mult(closest_t));\n\t\t\n\t\treturn circle2circleQuery(tCP.x, tCP.y, closest.x, closest.y, circle.radius, segment.radius, arbiter);\n\t}\n\t\n}","package physics.constraints;\nimport physics.dynamics.Body;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Constraint \n{\n\n\tpublic var body1 : Body;\n\tpublic var offset1 : Vector2D;\n\tpublic var body2 : Body;\n\tpublic var offset2 : Vector2D;\n\t//public var next : Constraint;\n\t//public var prev : Constraint;\n\tpublic var remove : Bool;\n\t\n\tpublic var destroyCallback :  Constraint -> Void;\n\t\n\tpublic function new() \n\t{\n\t\t\n\t}\n\n\tpublic function resolve() : Bool {\n\t\treturn false;\n\t}\n\t\n\tpublic function Destroy():Void {\n\t\tif (destroyCallback != null)\n\t\t\tdestroyCallback(this);\n\t\tbody1.RemoveConstraint(this);\n\t\tbody2.RemoveConstraint(this);\n\t}\n\t\n}","package physics.dynamics;\nimport physics.geometry.Vector2D;\nimport utils.Maths;\n\n/**\n * ...\n * @author rje\n */\n\nclass Arbiter \n{\n\n\tpublic var contacts : Array<Contact>;\n\tpublic var contactCount : Int;\n\tpublic var feature1 : Feature;\n\tpublic var feature2 : Feature;\n\tpublic var isSensor : Bool;\n\t\n\tprivate var mtdA : Vector2D; \n\tprivate var mtdB : Vector2D; \n\tprivate var vnA : Vector2D;\n\tprivate var vnB : Vector2D;\n\t\n\tpublic function new() \n\t{\n\t\tcontacts = new Array<Contact>();\n\t\tfor (i in 0...2) { \n\t\t\tcontacts.push(new Contact());\n\t\t}\n\t\tcontactCount = 0;\n\t\t\n\t\tmtdA = new Vector2D();\n\t\tmtdB = new Vector2D();\n\t\tvnA = new Vector2D();\n\t\tvnB = new Vector2D();\n\t}\n\t\n\tinline public function Reset():Void {\n\t\tcontactCount = 0;\n\t}\n\t\n\tinline public function AddContact(pX : Float, pY : Float, nX : Float, nY : Float, nCoef : Float, dist : Float) : Void {\n\t\tvar contact : Contact = contacts[contactCount];\n\n\t\tcontact.point.x = pX;\n\t\tcontact.point.y = pY;\n\t\tcontact.normal.x = nX * nCoef;\n\t\tcontact.normal.y = nY * nCoef;\n\t\tcontact.penDist = dist;\n\t}\n\t\n\tinline public function OpposingBody(thiz:Body):Body {\n\t\treturn thiz.id == feature1.body.id ? feature2.body : feature1.body;\n\t}\n\t\n\tinline public function Resolve():Bool {\n\t\tvar bodyA:Body = feature1.body;\n\t\tvar bodyB:Body = feature2.body;\n\n\t\tisSensor = feature1.isSensor || feature2.isSensor;\n\t\t\n\t\tif (!isSensor) {\n\t\t\tvar normal:Vector2D = contacts[0].normal;\n\t\t\t//normal.setTo(0, 1);\n\t\t\tvar depth:Float = contacts[0].penDist;\n\t\t\t\n\t\t\tvar mtd:Vector2D = normal.mult(depth);\n\t\t\t\t//Inline\n\t\t\t\t//var mtdX:Float = normal.x * depth;\n\t\t\t\t//var mtdY:Float = normal.x * depth;\n\t\t\t\t\t   \n\t\t\tvar te:Float = feature1.material.elasticity + feature2.material.elasticity;\n\t\t\tvar sumInvMass:Float = feature1.body.invMass + feature2.body.invMass;\n\n\t\t\t// the total friction in a collision is combined but clamped to [0,1]\n\t\t\tvar tf:Float = Maths.Clamp(1 - (feature1.material.friction + feature2.material.friction), 0, 1);\n\t\t\t\n\t\t\t// get the collision components, vn and vt\n\t\t\t//var ca:Collision = pa.getComponents(normal);\n\t\t\t\n\t\t\t//var ca_vel:Vector2D = bodyA.velocity;\n\t\t\t\t//Inline\n\t\t\t\tvar ca_velX:Float = bodyA.position.x - bodyA.prevPosition.x;\n\t\t\t\tvar ca_velY:Float = bodyA.position.y - bodyA.prevPosition.y;\n\n\t\t\t//var ca_vdotn:Float = normal.dot(ca_vel);\n\t\t\t\t//Inline x * v.x + y * v.y\n\t\t\t\tvar ca_vdotn:Float = normal.x * ca_velX + normal.y * ca_velY;\n\t\t\t\n\t\t\t//var ca_vn:Vector2D  = normal.mult(ca_vdotn);\n\t\t\t\t//Inline\n\t\t\t\tvar ca_vnX:Float  = normal.x * ca_vdotn;\n\t\t\t\tvar ca_vnY:Float  = normal.y * ca_vdotn;\n\t\t\t\t\n\t\t\t//var ca_vt:Vector2D  = ca_vel.minus(ca_vn);\n\t\t\t\t//Inline\t\n\t\t\t\tvar ca_vtX:Float  = ca_velX - ca_vnX;\n\t\t\t\tvar ca_vtY:Float  = ca_velY - ca_vnY;\n\t\t\t\n\t\t\t//var cb:Collision = pb.getComponents(normal);\n\t\t\t\n\t\t\t//var cb_vel:Vector2D = bodyB.velocity;\n\t\t\t\t//Inline\n\t\t\t\tvar cb_velX:Float = bodyB.position.x - bodyB.prevPosition.x;\n\t\t\t\tvar cb_velY:Float = bodyB.position.y - bodyB.prevPosition.y;\n\t\t\t\t\n\t\t\t//var cb_vdotn:Float = normal.dot(cb_vel);\n\t\t\t\t//Inline x * v.x + y * v.y\n\t\t\t\tvar cb_vdotn:Float = normal.x * cb_velX + normal.y * cb_velY;\n\t\t\t\n\t\t\t//var cb_vn:Vector2D  = normal.mult(cb_vdotn);\n\t\t\t\t//Inline\n\t\t\t\tvar cb_vnX:Float  = normal.x * cb_vdotn;\n\t\t\t\tvar cb_vnY:Float  = normal.y * cb_vdotn;\n\t\t\t\t\t\t\t\t\n\t\t\t//var cb_vt:Vector2D  = cb_vel.minus(cb_vn);\t\n\t\t\t\t//Inline\n\t\t\t\tvar cb_vtX:Float  = cb_velX - cb_vnX;\n\t\t\t\tvar cb_vtY:Float  = cb_velY - cb_vnY;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t // calculate the coefficient of restitution as the normal component\n\t\t\t//var vnA:Vector2D = (cb_vn.mult((te + 1) * bodyA.invMass).plus(ca_vn.mult(bodyB.invMass - te * bodyA.invMass))).divEquals(sumInvMass);\n\t\t\t\t//Inline\n\t\t\t\tvar vnAX:Float = ((cb_vnX * ((te + 1) * bodyA.invMass)) + (ca_vnX * (bodyB.invMass - te * bodyA.invMass)))/sumInvMass;\n\t\t\t\tvar vnAY:Float = ((cb_vnY * ((te + 1) * bodyA.invMass)) + (ca_vnY * (bodyB.invMass - te * bodyA.invMass)))/sumInvMass;\n\t\t\t\n\t\t\t\n\t\t\t//var vnB:Vector2D = (ca_vn.mult((te + 1) * bodyB.invMass).plus(cb_vn.mult(bodyA.invMass - te * bodyB.invMass))).divEquals(sumInvMass);\n\t\t\t\t//Inline\n\t\t\t\tvar vnBX:Float = ((ca_vnX * ((te + 1) * bodyB.invMass)) + (cb_vnX * (bodyA.invMass - te * bodyB.invMass)))/sumInvMass;\n\t\t\t\tvar vnBY:Float = ((ca_vnY * ((te + 1) * bodyB.invMass)) + (cb_vnY * (bodyA.invMass - te * bodyB.invMass)))/sumInvMass;            \n\t\t\t\n\t\t\t\n\t\t\t// apply friction to the tangental component\n\t\t\t//ca_vt.multEquals(tf);\n\t\t\t\t//Inline\n\t\t\t\tca_vtX *= tf;\n\t\t\t\tca_vtY *= tf;\n\t\t\t//cb_vt.multEquals(tf);\n\t\t\t\t//Inline\n\t\t\t\tcb_vtX *= tf;\n\t\t\t\tcb_vtY *= tf;\n\t\t\t\n\t\t\t\n\t\t\t// scale the mtd by the ratio of the masses. heavier particles move less \n\t\t\t//mtdA = mtd.mult( bodyA.invMass / sumInvMass); \n\t\t\tvar aMassRatio:Float = bodyA.invMass / sumInvMass;\n\t\t\tmtdA.x = mtd.x*aMassRatio;\n\t\t\tmtdA.y = mtd.y*aMassRatio;\n\t\t\t\n\t\t\t//mtdB = mtd.mult(-bodyB.invMass / sumInvMass);\n\t\t\tvar bMassRatio:Float = -bodyB.invMass / sumInvMass;\n\t\t\tmtdB.x = mtd.x*bMassRatio;\n\t\t\tmtdB.y = mtd.y*bMassRatio;\n\t\t\t\t\t\t\n\t\t\t// add the tangental component to the normal component for the new velocity \n\t\t\t//vnA.plusEquals(ca_vt);\n\t\t\t//vnB.plusEquals(cb_vt);\n\n\t\t\t//bodyA.RespondToCollision(this,mtdA, vnA, normal, depth, -1);\n\t\t\t//bodyB.RespondToCollision(this,mtdB, vnB, normal, depth,  1);\n\t\t\t\n\t\t\t\n\t\t\t//vnA = new Vector2D(vnAX+ca_vtX,vnAY+ca_vtY);    \n\t\t\tvnA.x = vnAX+ca_vtX;    \n\t\t\tvnA.y = vnAY+ca_vtY;\n\t\t\t \n\t\t\t//vnB = new Vector2D(vnBX+cb_vtX,vnBY+cb_vtY);\n\t\t\tvnB.x = vnBX+cb_vtX;    \n\t\t\tvnB.y = vnBY+cb_vtY;\n\t\t\t\t\t\t\t\t   \n\t\t\tbodyA.RespondToCollision(this,mtdA, vnA, normal, depth, -1);\n\t\t\tbodyB.RespondToCollision(this,mtdB, vnB, normal, depth,  1);\n\t\t\t\n\t\t}\n\t\t\n\t\tif (feature1.contactCallback!=null) feature1.contactCallback(this);\n\t\tif (feature2.contactCallback != null) feature2.contactCallback(this);\n\t\t\n\t\treturn !isSensor;\n\t\t\n\t}\n\t\n}","package physics.dynamics;\n\nimport physics.constraints.Constraint;\nimport physics.geometry.AABB;\nimport physics.geometry.GeometricShape;\nimport physics.geometry.Vector2D;\nimport physics.geometry.VertexList;\nimport physics.PhysicsEngine;\nimport ds.IDManager;\n\n/**\n * ...\n * @author rje\n */\n\nclass Body\n{\n\n\tprivate static var nextBodyID : Int = 0;\n\t\t\n\tpublic var id : Int;\n\tpublic var transient : Bool;\n\t\n\tpublic var next:Body;\n\tpublic var prev:Body;\n\n\tpublic var position:Vector2D;\n\tpublic var prevPosition : Vector2D; \n\tpublic var tempPosition : Vector2D; \n\t\n\tprivate var accumulatedForces : Vector2D;\n\t\n\tpublic var angle:Float;\n\tpublic var rotation:Vector2D;\n\t\n\tpublic var mass : Float;\n\tpublic var invMass : Float;\n\t\n\tpublic var motion : Float;\n\t\n\tpublic var features : Array<Feature>;\n\tpublic var constraints : Array<Constraint>;\n\t\n\tpublic var aabb:AABB;\n\tpublic var radius : Float;\n\tpublic var radiusSqrd : Float;\n\t\n\tprivate var averageCenterOffset : Vector2D;\n\tpublic var averageCenter : Vector2D;\n\t\n\tpublic var maxAcceleration : Float;\n\tpublic var maxVelocityScalar : Float;\n\tpublic var maxVelocityScalarSqrd : Float;\t\n\n\tpublic var damping : Float;\n\tpublic var masslessForcesFactor:Float;\n\t\t\n\tpublic var group : Int;\n\tpublic var layers : Int;\n\tpublic var collisionProcessingMask : Int;\n\tpublic var bodyTypeMask : Int;\n\t\n\tpublic var canKeepAlive:Bool;\n\tpublic var allowedToSleep:Bool;\n\tpublic var canSleep:Bool;\n\tpublic var isSleeping:Bool;\n\t\n\tpublic var isStatic:Bool;\n\tpublic var isKinematic:Bool;\n\tpublic var isOpaque:Bool;\n\t\n\tpublic var engine:PhysicsEngine;\n\t\n\tpublic var broadphaseData1:Int;\n\tpublic var broadphaseData2:Int;\n\t\n\tpublic var userData1:Dynamic;\n\tpublic var userData2:Dynamic;\n\n\tpublic var relativePoints:VertexList;\n\t\n\tpublic var createdMS:Float;\n\tpublic var lastStep:Int;\n\t\n\tpublic function new() \n\t{\n\t\tid = transient ? IDManager.GetTransientID() : IDManager.GetPersistentID();\n\t\t//transient = false;\n\t\t//id = nextBodyID++;\n\t\tthis.aabb = new AABB();\n\t\taverageCenterOffset = new Vector2D();\n\t\taverageCenter = new Vector2D();\n\t\t\n\t\tposition = new Vector2D();\n\t\tprevPosition = new Vector2D();\n\t\ttempPosition = new Vector2D();\n\t\taccumulatedForces = new Vector2D();\n\t\trotation = new Vector2D();\n\t\tfeatures = new Array<Feature>();\n\t\tconstraints = new Array<Constraint>();\n\t\tSetAngle(0);\n\t\tSetMass(1);\n\t\tSetMaximumScalarVelocity(20);\n\t\tmaxAcceleration = 50;\n\t\tmotion = Constants.WAKE_MOTION;\n\t\t\n\t\tdamping = 1;\n\t\tmasslessForcesFactor = 1;\n\t\t\n\t\tradius = radiusSqrd = 0;\n\t\t\n\t\tgroup = 0;\n\t\tlayers = 0xFFFF;\n\t\t\n\t\tcanKeepAlive = true;\n\t\tallowedToSleep = true;\n\t\tcanSleep = true;\n\t\tisSleeping = false;\n\t\tisStatic = false;\n\t\tisKinematic = false;\n\t\tisOpaque = false;\n\t\t\n\t\tcollisionProcessingMask = 0;\n\n\t\tlastStep = -1;\n\t\t\n\t\tInitalize();\n\t}\n\t\n\tpublic function Initalize():Void {\n\t\t\n\t}\n\t\n\tpublic function Update(step:Int):Void {\n\t\tif (isStatic || isSleeping)\n\t\t\treturn;\n\t\tif (step==lastStep)\n\t\t\treturn;\n\t\tlastStep = step;\n\t\t// AddMasslessForce(masslessForces);\n\t\taccumulatedForces.x += engine.masslessForces.x*masslessForcesFactor;\n\t\taccumulatedForces.y += engine.masslessForces.y*masslessForcesFactor;\n\n\t\t// AddForce(forces);\n\t\taccumulatedForces.x += engine.forces.x * invMass;\n\t\taccumulatedForces.y += engine.forces.y * invMass;\n\n\t\t// tempPosition.copy(position);\n\t\ttempPosition.x = position.x;\n\t\ttempPosition.y = position.y;\n\n\t\t// var nv : Vector2D = velocity.plus(accumulatedForces.multEquals(deltaTime));\n\t\tvar nvX : Float = (position.x - prevPosition.x) + (accumulatedForces.x * engine.physicsDeltaTime);\n\t\tvar nvY : Float = (position.y - prevPosition.y) + (accumulatedForces.y * engine.physicsDeltaTime);\n\n\t\t// nv.multEquals(damping);\n\t\tnvX *= (damping * engine.damping);\n\t\tnvY *= (damping * engine.damping);\n\n\t\tif (maxVelocityScalarSqrd > 0) {\n\t\t\tvar scalarVelocitySqr = nvX * nvX + nvY * nvY;\n\t\t\tif (scalarVelocitySqr > maxVelocityScalarSqrd) {\n\t\t\t\tvar factor = maxVelocityScalar / Math.sqrt(scalarVelocitySqr);\n\t\t\t\tnvX *= factor;\n\t\t\t\tnvY *= factor;\n\t\t\t}\n\t\t}\n\n\t\t// .clampMax(maxSpeed);//0.0625\n\n\t\t// position.plusEquals(nv);\n\t\tposition.x += nvX;\n\t\tposition.y += nvY;\n\n\t\t// prevPosition.copy(tempPosition);\n\t\tprevPosition.x = tempPosition.x;\n\t\tprevPosition.y = tempPosition.y;\n\n\t\taccumulatedForces.x = accumulatedForces.y = 0;\n\t\tdamping = 1;\n\n\t\tmotion = (Constants.SLEEP_BIAS * motion) + ((1 - Constants.SLEEP_BIAS) * (nvX * nvX + nvY * nvY));\n\n\t\tif (motion > (10 * Constants.SLEEP_EPSILON)) motion = 10 * Constants.SLEEP_EPSILON;\n\n\t\tcanSleep = false;\n\t\tif (motion < Constants.SLEEP_EPSILON) \n\t\t\tcanSleep = true;\n\n\t\tfor (constraint in constraints) {\n\t\t\tif (!constraint.resolve()) {\n\t\t\t\tconstraint.Destroy();\n\t\t\t}\n\t\t}\n\t\t\t\n\t\taverageCenter.x = position.x + averageCenterOffset.x;\n\t\taverageCenter.y = position.y + averageCenterOffset.y;\t\t\n\t}\n\t\n\tpublic function OnStep(step:Int):Bool {\n\t\treturn true;\n\t}\n\t\n\tpublic function OnPause():Bool {\n\t\treturn true;\n\t}\n\t\n\tpublic function Sleep():Bool {\n\t\tif (isSleeping||!allowedToSleep)\n\t\t\treturn false;\n\t\t\t\n\t\tif (engine.SleepItem(this)) {\n\t\t\tmotion = 0;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic function Wake():Bool {\n\t\tif (!isSleeping)\n\t\t\treturn false;\n\t\t\t\n\t\tif (engine.WakeItem(this)) {\n\t\t\tmotion = Constants.WAKE_MOTION;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tinline public function GetVelocity() : Vector2D {\n\t\treturn position.minus(prevPosition);\n\t}\n\n\tinline public function SetVelocity(value : Vector2D) : Void {\n\t\tprevPosition.x = position.x - value.x;\n\t\tprevPosition.y = position.y - value.y;\n\t\tif (isSleeping) Wake();\n\t}\n\t\n\tpublic function AddForce(force:Vector2D):Void {\n\t\taccumulatedForces.plusEquals(force.mult(invMass));\n\t\tif (isSleeping) Wake();\n\t}\n\t\n\tpublic function AddMasslessForce(force : Vector2D) : Void {\n\t\taccumulatedForces.plusEquals(force);\n\t\tif (isSleeping) Wake();\n\t}\t\n\t\n\tpublic function RespondToCollision(collision : Arbiter, mtd : Vector2D, newVelocity : Vector2D, normal : Vector2D, depth : Float, o : Int) : Void {\n\t\tif (isStatic) return;\n\t\tposition.x += mtd.x*1.001;\n\t\tposition.y += mtd.y*1.001;\n\t\tSetVelocity(newVelocity);\n\t\tif (isSleeping)\n\t\t\tWake();\n\t}\n\t\n\tpublic function SetAngle(angle : Float) : Void {\n\t\tthis.angle = angle % 6.28318530717; //2*PI\n\t\trotation.x = Math.cos(this.angle);\n\t\trotation.y = Math.sin(this.angle);\n\t\tUpdateFeatures();\n\t}\n\t\n\tpublic function SetMass(mass : Float) : Void {\n\t\tthis.mass = mass;\n\t\tthis.invMass = 1 / mass;\n\t}\n\t\n\tpublic function MakeStatic() : Void {\n\t\tisStatic = true;\n\t\tisOpaque = true;\n\t\tSetMass(Math.POSITIVE_INFINITY);\n\t}\n\t\n\tpublic function SetMaximumScalarVelocity(maxVelocity : Float) : Void {\n\t\tmaxVelocityScalar = maxVelocity;\n\t\tmaxVelocityScalarSqrd = maxVelocityScalar * maxVelocityScalar;\n\t}\n\n\tpublic function SetStaticPosition(position : Vector2D) : Void {\n\t\tthis.position.copy(position);\n\t\tprevPosition.copy(position);\n\t\taverageCenter.x = position.x + averageCenterOffset.x;\n\t\taverageCenter.y = position.y + averageCenterOffset.y;\n\t\tif (isSleeping) Wake();\n\t}\n\n\tpublic function Skew(delta : Vector2D) : Void {\n\t\tposition.plusEquals(delta);\n\t\tprevPosition.plusEquals(delta);\n\t\tif (isSleeping) Wake();\n\t}\n\n\tpublic function SetRadius(r : Float) : Void {\n\t\tradius = r;\n\t\tradiusSqrd = r * r;\n\t}\n\n\tpublic function AddFeature(shape:GeometricShape,material:Material):Feature  {\n\t\tvar feature = new Feature(this, shape, material);\n\t\tfeatures.push(feature);\n\t\tfeature.shape.Update(rotation);\n\t\taabb.expand(feature.shape.aabb);\n\t\t\n\t\taabb.setToCenter(averageCenterOffset);\n\t\t\n\t\tvar rX : Float = averageCenterOffset.x - aabb.r;\n\t\tvar rY : Float = averageCenterOffset.y - aabb.t;\n\t\tradiusSqrd = rX * rX + rY * rY;\n\t\tradius = Math.sqrt(radiusSqrd);\n\t\t\t\t\n\t\treturn feature;\n\t}\n\t\n\tpublic function UpdateFeatures() : Void {\n\t\taabb.reset();\n\t\tfor (feature in features) {\n\t\t\tfeature.shape.Update(rotation);\n\t\t\taabb.expand(feature.shape.aabb);\n\t\t}\n\t\taabb.setToCenter(averageCenterOffset);\n\t\t\n\t\tvar rX : Float = averageCenterOffset.x - aabb.r;\n\t\tvar rY : Float = averageCenterOffset.y - aabb.t;\n\t\tradiusSqrd = rX * rX + rY * rY;\n\t\tradius = Math.sqrt(radiusSqrd);\n\t\t\n\t\tif (relativePoints != null)\n\t\t\trelativePoints.Update(rotation, false);\n\t}\n\n\tpublic function AddConstraint(constraint:Constraint):Void {\n\t\tconstraints.push(constraint);\n\t}\n\n\tpublic function RemoveConstraint(constraint:Constraint):Void {\n\t\tconstraints.remove(constraint);\n\t}\n\t\n\tpublic function OnAddedToEngine(engine:PhysicsEngine):Void {\n\t\tthis.engine = engine;\n\t\tcreatedMS = engine.currTime;\n\t}\n\t\n\tpublic function OnStartCollision(contact:BodyContact):Void {\n\t\ttrace(\"Start \" + contact.hash);\n\t}\t\n\t\n\tpublic function OnCollision(contact:BodyContact):Void {\n\t\ttrace(\"hit\");\n\t}\t\n\t\n\tpublic function OnEndCollision(contact:BodyContact):Void {\n\t\t\n\t}\n\t\n\tpublic function Destroy():Void {\n\t\tengine.RemoveBody(this);\n\t\t\n\t\tfor (constraint in constraints)\n\t\t\tconstraint.Destroy();\n\t\t\n\t\tif (transient)\n\t\t\tIDManager.ReleaseTransientID(id);\n\t}\n\t\t\n\tinline public static function HashBodyIDs(body1ID:Int, body2ID:Int):Int {\n\t\treturn (body1ID < body2ID) ? (body1ID << 16) | body2ID : (body2ID << 16) | body1ID;\n\t}\n\t\n}","package physics.dynamics;\n\n/**\n * ...\n * @author rje\n */\n\nclass BodyContact \n{\n\n\tpublic var bodyA:Body;\n\tpublic var bodyB:Body;\n\t\n\tpublic var hash:Int;\n\t\n\tpublic var stamp:Int;\n\t\n\tpublic var startContact:Bool;\n\tpublic var endContact:Bool;\n\t\n\tpublic var contactCount : Int;\n\t\n\tpublic function new() \n\t{\n\t\t\n\t}\n\t\n}","package physics.dynamics;\nimport haxe.ds.IntMap;\nimport physics.PhysicsEngine;\n\n/**\n * ...\n * @author rje\n */\n\nclass BodyContactManager \n{\n\tpublic var engine:PhysicsEngine;\n\tpublic var contacts:IntMap<BodyContact>;\n\t\n\tpublic function new(engine:PhysicsEngine) \n\t{\n\t\tthis.engine = engine;\n\t\tcontacts = new IntMap<BodyContact>();\n\t}\n\t\n\tpublic function UpdateContacts(body1:Body, body2:Body):Bool {\n\t\t\n\t\tif (body1.collisionProcessingMask == 0 && body2.collisionProcessingMask == 0) return false;\n\t\t\n\t\tvar bodyHash:Int = Body.HashBodyIDs(body1.id, body2.id);\n\t\t\n\t\tvar bodyContact : BodyContact = contacts.get(bodyHash);\n\t\t\n\t\tif (bodyContact!=null) {\n\t\t\tif (bodyContact.stamp < engine.update) {\n\t\t\t\tbodyContact.contactCount = 0;\n\t\t\t\tbodyContact.stamp = engine.update;\n\t\t\t}\n\t\t\tbodyContact.contactCount++;\n\t\t} else {\n\t\t\tbodyContact = new BodyContact();\n\t\t\tbodyContact.hash = bodyHash;\n\t\t\tbodyContact.stamp = engine.update;\n\t\t\tbodyContact.contactCount = 1;\n\t\t\tbodyContact.startContact = true;\n\t\t\tbodyContact.endContact = false;\n\t\t\tbodyContact.bodyA = body1;\n\t\t\tbodyContact.bodyB = body2;\n\t\t\tcontacts.set(bodyHash, bodyContact);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic function ProcessBodyContacts() : Void {\n\t\tvar contactIter = contacts.iterator();\n\t\tvar count = 0;\n\t\tfor (bodyContact in contactIter) {\n\t\t\tcount++;\n\t\t\tif (bodyContact.stamp < engine.update)\n\t\t\t\tbodyContact.endContact = true;\n\n\t\t\tif (bodyContact.bodyA.collisionProcessingMask>0) {\n\t\t\t\tif (( bodyContact.bodyA.collisionProcessingMask & 1 > 0 ) && (bodyContact.startContact)) bodyContact.bodyA.OnStartCollision(bodyContact);\n\t\t\t\tif ( bodyContact.bodyA.collisionProcessingMask & 2 > 0 ) bodyContact.bodyA.OnCollision(bodyContact);\n\t\t\t\tif (( bodyContact.bodyA.collisionProcessingMask & 4 > 0 ) && (bodyContact.endContact)) bodyContact.bodyA.OnEndCollision(bodyContact);\n\t\t\t}\n\t\t\tif (bodyContact.bodyB.collisionProcessingMask>0) {\n\t\t\t\tif (( bodyContact.bodyB.collisionProcessingMask & 1 > 0 ) && (bodyContact.startContact)) bodyContact.bodyB.OnStartCollision(bodyContact);\n\t\t\t\tif ( bodyContact.bodyB.collisionProcessingMask & 2 > 0 ) bodyContact.bodyB.OnCollision(bodyContact);\n\t\t\t\tif (( bodyContact.bodyB.collisionProcessingMask & 4 > 0 ) && (bodyContact.endContact)) bodyContact.bodyB.OnEndCollision(bodyContact);\n\t\t\t}\n\n\t\t\tbodyContact.startContact = false;\n\n\t\t\tif (bodyContact.endContact) {\n\t\t\t\tcontacts.remove(bodyContact.hash);\n\t\t\t}\n\t\t}\n\t\ttrace(\"Count=\" + count);\n\t}\n\t\n}","package physics.dynamics;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Contact \n{\n\n\tpublic var point : Vector2D;\n\n\tpublic var normal : Vector2D;\n\n\tpublic var penDist : Float;\n\t\n\tpublic function new() \n\t{\n\t\tpoint = new Vector2D();\n\t\tnormal = new Vector2D();\n\t\tpenDist = 0;\n\t}\n\t\n}","package physics.dynamics;\nimport physics.geometry.GeometricShape;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Feature \n{\n\t\n\tpublic var body : Body;\n\tpublic var shape : GeometricShape;\n\tpublic var material : Material;\n\t\n\tpublic var position : Vector2D;\n\t\n\tpublic var isSensor : Bool;\n\tpublic var isCollidable : Bool;\n\t\n\tpublic var contactCallback :  Arbiter -> Void;\n\t\n\tpublic function new( body:Body, shape:GeometricShape, material:Material ) \n\t{\n\t\tthis.body = body;\n\t\tthis.shape = shape;\n\t\tthis.material = material;\n\t\tthis.isSensor = false;\n\t\tthis.isCollidable = false;\n\t\tthis.position = body.position;\n\t}\n\t\n\tpublic inline function copy(feature:Feature):Void {\n\t\tthis.body = feature.body;\n\t\tthis.shape = feature.shape;\n\t\tthis.material = feature.material;\n\t\tthis.position = feature.position;\n\t}\n\t\n}","package physics.dynamics;\n\n/**\n * ...\n * @author rje\n */\n\nclass Material \n{\t\n\tpublic var density : Float;\n\tpublic var elasticity : Float;\n\tpublic var friction : Float;\n\n\tpublic function new(density : Float = 1, elasticity : Float = 0.3, friction : Float = 0.0) {\n\t\tthis.density = density;\n\t\tthis.elasticity = elasticity;\n\t\tthis.friction = friction;\n\t}\n\t\n}","package physics.geometry;\nimport physics.Constants;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass AABB \n{\n\n\tpublic var l : Float; //minX\n\tpublic var b : Float; //minY\n\tpublic var r : Float; //maxX\n\tpublic var t : Float; //maxY\n\t\n\tpublic function new(?l=.0,?b=.0,?r=.0,?t=.0) \n\t{\n\t\tthis.l = l;\n\t\tthis.b = b;\n\t\tthis.r = r;\n\t\tthis.t = t;\n\t}\n\t\n\tinline public static function intersects(aabb1:AABB, position1:Vector2D, aabb2:AABB, position2:Vector2D):Bool {\n\t\tif (aabb1.l + position1.x > aabb2.r + position2.x)\n\t\t\treturn false;\n\t\telse if (aabb1.r + position1.x < aabb2.l + position2.x)\n\t\t\treturn false;\n\t\telse if (aabb1.t + position1.y > aabb2.b + position2.y)\n\t\t\treturn false;\n\t\telse if (aabb1.b + position1.y < aabb2.t + position2.y)\n\t\t\treturn false;\n\t\telse return true;\n\t}\n\n\tinline public function containtsPoint(point:Vector2D) {\n\t\treturn ( point.x >= l && point.x < r && point.y >= t && point.y < b ); \n\t}\n\n\tinline public function expand(aabb : AABB) : Void {\n\t\tif (aabb.l < this.l) this.l = aabb.l;\n\t\tif (aabb.r > this.r) this.r = aabb.r;\n\t\tif (aabb.t < this.t) this.t = aabb.t;\n\t\tif (aabb.b > this.b) this.b = aabb.b;\n\t}\n\n\tinline public function reset() : Void {\n\t\tl = Constants.FMAX; \n\t\tr = -Constants.FMAX; \n\t\tt = Constants.FMAX; \n\t\tb = -Constants.FMAX; \n\t}\n\t\n\tinline public function width():Float {\n\t\treturn r - l;\n\t}\t\n\t\n\tinline public function height():Float {\n\t\treturn b - t;\n\t}\n\t\n\tinline public function area():Float {\n\t\treturn width()*height();\n\t}\n\t\n\tinline public function setToCenter(c:Vector2D):Void {\n\t\tc.x = (r + l) / 2;\n\t\tc.y = (b + t) / 2;\n\t}\n\n\tinline public function Union(position:Vector2D, aabb:AABB, aabbPosition:Vector2D):AABB {\n\t\treturn new AABB(\n\t\t\tMath.max(this.l+position.x, aabb.l+aabbPosition.x),\n\t\t\tMath.min(this.b+position.y, aabb.b+aabbPosition.y),\n\t\t\tMath.min(this.r+position.x, aabb.r+aabbPosition.x),\n\t\t\tMath.max(this.t+position.y, aabb.t+aabbPosition.y));\n\t}\n\n\tpublic function clone():physics.geometry.AABB {\n\t\treturn new physics.geometry.AABB(l,b,r,t);\n\t}\n\t\n}","package physics.geometry;\n\n/**\n * ...\n * @author rje\n */\n\nclass Axis \n{\n\n\tpublic var n:Vector2D;\n\t\n\tpublic var d:Float;\n\t\n\tpublic function new(n,d) \n\t{\n\t\tthis.n = n;\n\t\tthis.d = d;\n\t}\n\t\n\tpublic function clone() : Axis {\n\t\treturn new Axis(n.clone(), d);\n\t}\n\t\n}","package physics.geometry;\nimport physics.dynamics.Feature;\n\n/**\n * ...\n * @author rje\n */\n\nclass GeometricShape \n{\n\n\tpublic static var nextUID:Int = 0;\n\t\n\tpublic var typeID:Int;\n\t\n\tpublic var offset:Vector2D;\n\t\n\tpublic var aabb:AABB;\n\t\n\tpublic var area : Float;\n\t\n\tpublic var UID:Int;\n\t\n\tpublic function new(typeID:Int, offset:Vector2D) \n\t{\n\t\tthis.typeID = typeID;\n\t\tthis.offset = offset;\n\t\taabb = new AABB();\n\t\tUID = nextUID++;\n\t}\n\t\n\tpublic function Update(rotation : Vector2D) : Void {\n\t}\n\t\n\tpublic function ContainsPoint(point : Vector2D, shapePosition:Vector2D) : Bool {\n\t\treturn false;\n\t}\n\t\n\tpublic function IntersectRay(ray : Ray, feature:Feature) : Bool {\n\t\treturn false;\n\t}\n\t\n\tpublic function IntersectSegment(a:Vector2D, b:Vector2D, feature:Feature) {\n\t\t\n\t}\n\t\n}","package physics.geometry;\nimport physics.dynamics.Feature;\n\n/**\n * ...\n * @author rje\n */\n\nclass Circle extends GeometricShape\n{\n\n\tpublic var centre : Vector2D;\n\tpublic var transformedCentre : Vector2D;\n\tpublic var radius : Float;\n\t\n\tpublic function new(radius:Float, offset:Vector2D) \n\t{\n\t\tsuper(Shapes.CIRCLE_SHAPE,offset);\n\t\tthis.radius = radius;\n\t\tInitShape();\n\t}\n\t\n\tfunction InitShape():Void {\n\t\tcentre = offset.clone();\n\t\ttransformedCentre = centre.clone();\n\t\tarea = Math.PI * (radius * radius);\n\t}\n\t\n\tpublic override function Update(rotation : Vector2D) : Void {\n\t\ttransformedCentre.x = (centre.x * rotation.x - centre.y * rotation.y);\n\t\t//tC.x = p.x + (c.x * rot.x - c.y * rot.y);\n\t\ttransformedCentre.y = (centre.x * rotation.y + centre.y * rotation.x);\n\t\t//tC.y = p.y + (c.x * rot.y + c.y * rot.x);\n\t\taabb.l = transformedCentre.x - radius;\n\t\taabb.r = transformedCentre.x + radius;\n\t\taabb.t = transformedCentre.y - radius;\n\t\taabb.b = transformedCentre.y + radius;\n\t}\n\t\n\tpublic override function ContainsPoint(point : Vector2D, shapePosition:Vector2D) : Bool {\n\t\tvar x = transformedCentre.x + shapePosition.x - point.x;\n\t\tvar y = transformedCentre.y + shapePosition.y - point.y;\n\t\treturn (x * x + y * y) <= (radius * radius);\n\t}\n\t\n\tpublic override function IntersectRay(ray : Ray, feature:Feature) : Bool {\n\t\t// var dist : Vector2D = ray.origin.minus(tC);\n\t\tvar distX : Float = ray.origin.x - (transformedCentre.x + feature.position.x);\n\t\tvar distY : Float = ray.origin.y - (transformedCentre.y + feature.position.y);\n\t\t// var b : Number = dist.dot(ray.direction);\n\t\tvar b : Float = distX * ray.direction.x + distY * ray.direction.y;\n\t\tif (b > 0) \n\t\t\treturn false;\n\t\t// Circle is behind the origin\n\t\t// var d : Number = (r * r) - (dist.dot(dist) - (b * b));\n\t\tvar d : Float = (radius * radius) - (distX * distX + distY * distY - (b * b));\n\t\tif (d < 0) \n\t\t\treturn false;\n\t\t// Ray is not pointing towards the origin\n\t\td = -b - Math.sqrt(d);\n\t\treturn ray.ReportResult(feature, d, ray.returnNormal ? new Vector2D((ray.origin.x + (ray.direction.x * d)) - (transformedCentre.x + feature.position.x), (ray.origin.y + (ray.direction.y * d)) - (transformedCentre.y + feature.position.y)).unitEquals() : null);\n\t\t//return ray.ReportResult(feature, t, nnear.n);\n\t}\n\t\n\tpublic override function IntersectSegment(a:Vector2D, b:Vector2D, feature:Feature) {\n\t\t// offset the line to be relative to the circle\n\t\t//a = cpvsub(a, center);\n\t\tvar tA = a.minus(transformedCentre).minus(feature.position);\n\t\t//b = cpvsub(b, center);\n\t\tvar tB = b.minus(transformedCentre).minus(feature.position);\n\t\t\n\t\t//cpFloat qa = cpvdot(a, a) - 2.0f*cpvdot(a, b) + cpvdot(b, b);\n\t\tvar qa = a.dot(a) - 2 * a.dot(b) + b.dot(b);\n\t\t\n\t\t//cpFloat qb = -2.0f*cpvdot(a, a) + 2.0f*cpvdot(a, b);\n\t\tvar qb = -2 * a.dot(a) + 2 * a.dot(b);\n\t\t\n\t\t//cpFloat qc = cpvdot(a, a) - r*r;\n\t\tvar qc = a.dot(a) - radius * radius;\n\t\t\n\t\t//cpFloat det = qb*qb - 4.0f*qa*qc;\n\t\tvar det = qb * qb - 4 * qa * qc;\n\t\t\n\t\tif(det >= 0.0){\n\t\t\t//cpFloat t = (-qb - cpfsqrt(det))/(2.0f*qa);\n\t\t\tvar t = ( -qb - Math.sqrt(det)) / (2 * qa);\n\t\t\tif(0.0<= t && t <= 1.0){\n\t\t\t\t//info->shape = shape;\n\t\t\t\t//info->t = t;\n\t\t\t\t//info->n = cpvnormalize(cpvlerp(a, b, t));\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n}","package physics.geometry;\nimport physics.dynamics.Feature;\n\n/**\n * ...\n * @author rje\n */\n\nclass Polygon extends GeometricShape\n{\n\n\tpublic var vertices : Array<Vector2D>;\n\tpublic var transformedVertices : Array<Vector2D>;\n\t\n\tpublic var axes : Array<Axis>;\n\tpublic var transformedAxes : Array<Axis>;\n\t\n\tpublic var vertexCount : Int;\n\t\n\tpublic function new(vertices:Array<Vector2D>, offset:Vector2D) \n\t{\n\t\tsuper(Shapes.POLYGON_SHAPE,offset);\n\t\tInitShape(vertices);\n\t}\n\t\n\tfunction InitShape(originalVertices:Array<Vector2D>):Void {\n\t\tvar v0 : Vector2D; \n\t\tvar v1 : Vector2D;\n\t\tvar v2 : Vector2D;\n\t\tvar a : Vector2D;\n\t\tvar b : Vector2D;\n\t\tvar n : Vector2D;\n\t\tvar axis : Axis;\n\n\t\tvertices = new Array<Vector2D>();\n\t\ttransformedVertices = new Array<Vector2D>();\n\t\taxes = new Array<Axis>();\n\t\ttransformedAxes = new Array<Axis>();\n\t\t\n\t\tvertexCount = originalVertices.length;\n\n\t\tarea = 0;\n\t\t\n\t\tfor (i in 0...vertexCount) {\n\t\t\tv0 = originalVertices[i];\n\t\t\tv1 = originalVertices[(i + 1) % vertexCount];\n\t\t\tv2 = originalVertices[(i + 2) % vertexCount];\n\n\t\t\ta = new Vector2D(v0.x+offset.x,v0.y+offset.y);\n\t\t\tb = new Vector2D(v1.x+offset.x,v1.y+offset.y);\n\t\t\tn = b.minus(a).rightHandNormal().unit();\n\n\t\t\tvertices.push(a);\n\t\t\ttransformedVertices.push(a.clone());\n\t\t\t\n\t\t\taxis = new Axis(n, n.dot(a));\n\t\t\taxes.push(axis);\n\t\t\ttransformedAxes.push(axis.clone());\n\t\t\t\n\t\t\tarea += v1.x * (v2.y - v0.y);\n\t\t}\n\t\tarea /= -2;\n\t\t\n\t\toriginalVertices = null;\n\t}\n\t\n\tpublic override function Update( rotation : Vector2D) : Void {\n\t\tvar v : Vector2D;\n\t\tvar tv : Vector2D;\n\n\t\taabb.l = aabb.t = 4294967296;\n\t\taabb.r = aabb.b = -4294967296;\n\n\t\tfor (i in 0...vertexCount) {\n\t\t\tv = vertices[i];\n\t\t\ttv = transformedVertices[i];\n\t\t\ttv.x = (v.x * rotation.x - v.y * rotation.y);\n\t\t\ttv.y = (v.x * rotation.y + v.y * rotation.x);\n\t\t\tif (tv.x < aabb.l) aabb.l = tv.x;\n\t\t\tif (tv.x > aabb.r) aabb.r = tv.x;\n\t\t\tif (tv.y < aabb.t) aabb.t = tv.y;\n\t\t\tif (tv.y > aabb.b) aabb.b = tv.y;\n\t\t}\n\n\t\tvar a : Axis;\n\t\tvar ta : Axis;\n\t\t\n\t\tfor (i in 0...vertexCount) {\n\t\t\ta = axes[i];\n\t\t\tta = transformedAxes[i];\n\t\t\tta.n.x = a.n.x * rotation.x - a.n.y * rotation.y;\n\t\t\tta.n.y = a.n.x * rotation.y + a.n.y * rotation.x;\n\t\t\tta.d = a.d;//(p.x * ta.n.x + p.y * ta.n.y) + a.d;\n\t\t}\n\t}\n\t\n\tpublic override function ContainsPoint(point : Vector2D, shapePosition:Vector2D) : Bool {\n\t\tfor (a in transformedAxes) {\n\t\t\tif (((a.n.x * point.x + a.n.y * point.y) - ((shapePosition.x * a.n.x + shapePosition.y * a.n.y) + a.d) ) > 0 )\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic override function IntersectRay(ray : Ray, feature:Feature) : Bool {\n\t\tvar tfar : Float = ray.range;\n\t\tvar tnear : Float = 0;\n\t\tvar nnear : Axis = null;\n\t\tvar nfar : Axis = null;\n\n\t\tvar ta : Axis;\n\t\tvar tv : Vector2D;\n\n\t\tfor (i in 0...vertexCount) {\n\t\t\tta = transformedAxes[i];\n\t\t\ttv = transformedVertices[i];\n\t\t\t// var D:Vector2D = tv.minus(ray.origin);\n\t\t\tvar Dx : Float = (tv.x + feature.position.x) - ray.origin.x;\n\t\t\tvar Dy : Float = (tv.y + feature.position.y) - ray.origin.y;\n\t\t\tvar denom : Float = Dx * ta.n.x + Dy * ta.n.y;\n\t\t\t// D.dot(ta.n);\n\t\t\tvar numer : Float = ray.direction.x * ta.n.x + ray.direction.y * ta.n.y;\n\t\t\t// ray.direction.dot(ta.n);\n\n\t\t\tif ((numer < 0 ? -numer : numer) < 0.000000001) {\n\t\t\t\tif (denom < 0)\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tvar tclip : Float = denom / numer;\n\t\t\t\tif (numer < 0) {\n\t\t\t\t\tif (tclip > tfar)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (tclip > tnear) {\n\t\t\t\t\t\ttnear = tclip;\n\t\t\t\t\t\tnnear = ta;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (tclip < tnear)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (tclip < tfar) {\n\t\t\t\t\t\ttfar = tclip;\n\t\t\t\t\t\tnfar = ta;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (nnear==null) return false;\n\t\t// var t:Float = -(ray.origin.dot(nnear.n) - nnear.d) / (ray.direction.dot(nnear.n));\n\t\t\n\t\t\n//\t\t\tvar t : Float = -((ray.origin.x * nnear.n.x + ray.origin.y * nnear.n.y) - nnear.d) / (ray.direction.x * nnear.n.x + ray.direction.y * nnear.n.y);\n\t\tvar t : Float = -((ray.origin.x * nnear.n.x + ray.origin.y * nnear.n.y) - ( (feature.position.x * nnear.n.x + feature.position.y * nnear.n.y) +  nnear.d)) / (ray.direction.x * nnear.n.x + ray.direction.y * nnear.n.y);\n\t\t\n\t\t\n\t\t// return ray.origin.plus(ray.direction.mult(t));\n\t\t// return new Vector2D(ray.origin.x + (ray.direction.x * t), ray.origin.y + (ray.direction.y * t));\n\t\treturn ray.ReportResult(feature, t, nnear.n);\n\t}\n\n\tpublic override function IntersectSegment(a:Vector2D, b:Vector2D, feature:Feature) {\n\t\t//cpSplittingPlane *axes = poly->tPlanes;\n\t\t//cpVect *verts = poly->tVerts;\n\t\t//int numVerts = poly->numVerts;\n\n\t\tvar ta : Axis;\n\t\t//var tv : Vector2D;\n\n\t\tfor (i in 0...vertexCount) {\n\t\t\tta = transformedAxes[i];\n\t\t\t//tv = transformedVertices[i];\n\t\t\tvar an = a.dot(ta.n);\n\t\t\tvar ad = (feature.position.x * ta.n.x + feature.position.y * ta.n.y) +  ta.d;\n\t\t\tif ( ad > an )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvar bn = b.dot(ta.n);\n\t\t\t\n\t\t\tvar t = (ad - an)/(bn - an);\n\t\t\tif (t < 0.0 || 1.0 < t) \n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tvar point = a.interpolate(b, t);\n\t\t\tvar dt = -ta.n.cross(point);\n\t\t\tvar dtMin = -ta.n.cross(transformedVertices[i]);\n\t\t\tvar dtMax = -ta.n.cross(transformedVertices[(i + 1) % vertexCount]);\n\t\t\tif(dtMin <= dt && dt <= dtMax){\n\t\t\t\t//info->shape = (cpShape *)poly;\n\t\t\t\t//info->t = t;\n\t\t\t\t//info->n = n;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinline public function ValueOnAxis(a:Axis, axisPosition:Vector2D, shapePosition:Vector2D ) : Float {\n\t\tvar min : Float = 4294967296;\n\t\tvar result;\n\t\tfor (vertex in transformedVertices) {\n\t\t\tresult = (a.n.x * (vertex.x + shapePosition.x)  + a.n.y * (vertex.y + shapePosition.y)) - ( (axisPosition.x * a.n.x + axisPosition.y * a.n.y) + a.d);//a.d;\n\t\t\tif (result < min) min = result;\n\t\t}\n\t\treturn min;\n\t}\n\t\n\tpublic static function CreateRectangle(w : Float, h : Float) : Array<Vector2D> {\n\t\tvar rect : Array<Vector2D> = new Array<Vector2D>();\n\t\trect.push(new Vector2D(-w / 2, -h / 2));\n\t\trect.push(new Vector2D(-w / 2, h / 2));\n\t\trect.push(new Vector2D(w / 2, h / 2));\n\t\trect.push(new Vector2D(w / 2, -h / 2));\n\t\treturn rect;\n\t}\n\n\t\n}","package physics.geometry;\nimport physics.dynamics.Feature;\nimport utils.Maths;\n\n/**\n * ...\n * @author rje\n */\n\nclass Ray \n{\n\t\n\tinline public static var MAX_RANGE:Float = 1e100;\n\n\tpublic var origin:Vector2D;\n\tpublic var target:Vector2D;\n\tpublic var direction:Vector2D;\n\tpublic var delta:Vector2D;\n\t\n\tpublic var range:Float;\n\tpublic var rangeSqr:Float;\n\t\n\tpublic var returnNormal:Bool;\n\n\tpublic var lastIntersectResult:Bool;\n\tpublic var lastIntersectDistance:Float;\n\tpublic var lastIntersectFeature:Feature;\n\t\n\tpublic var intersectInRange:Bool;\n\tpublic var closestIntersectDistance:Float;\n\tpublic var closestIntersectNormal:Vector2D;\n\tpublic var closestIntersectFeature:Feature;\n\t\n\tpublic function new() {\n\t}\n\t\n\tpublic function SetParams(origin:Vector2D , target:Vector2D , range:Float):Void {\n\t\tthis.origin = origin;\n\t\tthis.target = target;\n\t\t\n\t\t//direction = target.minus(origin).normalize();\n\t\tdelta = target.minus(origin);\n\t\tvar m : Float = delta.length();\n\t\tif (m == 0) m = 0.0000001;\n\t\tdirection = delta.mult(1 / m);\n\n\t\t\n\t\tlastIntersectResult = false;\n\t\tlastIntersectDistance = 0;\n\t\tlastIntersectFeature = null;\n\t\t\n\t\tintersectInRange = false;\n\t\tclosestIntersectDistance = Math.POSITIVE_INFINITY;\n\t\tclosestIntersectFeature = null;\n\t\t\n\t\tthis.range = (range == 0) ? m : range;\n\t\tthis.rangeSqr = this.range * this.range;\t\t\t\n\t}\n\t\n\tpublic function Seen():Bool {\n\t\treturn (lastIntersectFeature == null) || (lastIntersectDistance >= range);\n\t}\n\t\n\tpublic function Seen2():Bool {\n\t\treturn (lastIntersectDistance >= range);\n\t}\n\t\n\tpublic function TestFeature(feature:Feature):Bool {\n\t\tlastIntersectResult = false;  \n\t\treturn feature.shape.IntersectRay(this, feature);\n\t}\n\t\n\tpublic function ReportResult( feature:Feature , dist:Float , normal:Vector2D = null ):Bool {\n\t\t\n\t\tif (dist>=range) {\n\t\t\tlastIntersectResult = false;\n\t\t\treturn false;\n\t\t}\n\t\tintersectInRange = true;\n\t\tlastIntersectResult = true;\n\t\tlastIntersectDistance = dist;\n\t\tlastIntersectFeature = feature;\n\t\t\n\t\tif (dist < closestIntersectDistance) {\n\t\t\tclosestIntersectDistance = dist;\n\t\t\tclosestIntersectFeature= feature;\n\t\t\tclosestIntersectNormal = normal;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic function LastIntersectPoint():Vector2D {\n\t\treturn new Vector2D(origin.x + (direction.x * lastIntersectDistance), origin.y + (direction.y * lastIntersectDistance));\n\t}\n\t\n\tpublic function ClosestIntersectPoint():Vector2D {\n\t\treturn new Vector2D(origin.x + (direction.x * closestIntersectDistance), origin.y + (direction.y * closestIntersectDistance));\n\t}\n\t\n\tpublic function IntersectBoundingCircle(position:Vector2D,radius:Float) : Bool {\n\t\tvar distX : Float = origin.x - position.x;\n\t\tvar distY : Float = origin.y - position.y;\n\t\t\n\t\tvar b : Float = distX * direction.x + distY * direction.y;\n\t\tif (b > 0) \n\t\t\treturn false;\n\t\t\n\t\tvar d : Float = (radius * radius) - (distX * distX + distY * distY - (b * b));\n\t\tif (d < 0) \n\t\t\treturn false;\n\t\t\n\t\treturn true;\n\t}\n\t\n}","package physics.geometry;\n\n/**\n * ...\n * @author rje\n */\n\nclass Segment extends GeometricShape\n{\n\tpublic var a:Vector2D;\n\tpublic var b:Vector2D;\n\tpublic var n:Vector2D;\n\tpublic var delta:Vector2D;\n\t\n\tpublic var radius:Float;\n\t\n\tpublic var tA:Vector2D;\n\tpublic var tB:Vector2D;\n\tpublic var tN:Vector2D;\n\tpublic var tNneg:Vector2D;\n\tpublic var tNdottA:Float;\n\t\t\t\t\t\n\tpublic function new(a:Vector2D , b:Vector2D, radius:Float) \n\t{\n\t\tsuper(Shapes.SEGMENT_SHAPE, null);\n\t\tthis.a = a.clone();\n\t\tthis.b = b.clone();\n\t\tthis.radius = radius;\n\t\tInitShape();\n\t}\n\n\tfunction InitShape():Void {\n\t\tdelta = b.minus(a);\n\t\tthis.n = delta.unit().rightHandNormal();\n\t\t\n\t\tthis.tA = new Vector2D();\n\t\tthis.tB = new Vector2D();\n\t\tthis.tN = new Vector2D();\n\t\tthis.tNneg = new Vector2D();\n\t}\t\n\n\tpublic override function Update(rotation : Vector2D) : Void {\n\t\ttA.x = (a.x * rotation.x - a.y * rotation.y);\n\t\ttA.y = (a.x * rotation.y + a.y * rotation.x);\n\t\ttB.x = (b.x * rotation.x - b.y * rotation.y);\n\t\ttB.y = (b.x * rotation.y + b.y * rotation.x);\n\t\ttN.x = n.x * rotation.x - n.y * rotation.y;\n\t\ttN.y = n.y * rotation.y + n.y * rotation.x;\n\t\ttNneg.x = -tN.x;\n\t\ttNneg.y = -tN.y;\n\t\ttNdottA = tN.x * tA.x + tN.y * tA.y;\n\t\t\n\t\tif(tA.x < tB.x){\n\t\t\t\taabb.l = tA.x - radius;\n\t\t\t\taabb.r = tB.x + radius;\n\t\t} else {\n\t\t\t\taabb.l = tB.x - radius;\n\t\t\t\taabb.r = tA.x + radius;\n\t\t}\n\t\t\n\t\tif(tA.y < tB.y){\n\t\t\t\taabb.t = tA.y - radius;\n\t\t\t\taabb.b = tB.y + radius;\n\t\t} else {\n\t\t\t\taabb.t = tB.y - radius;\n\t\t\t\taabb.b = tA.y + radius;\n\t\t}\n\t}\t\n\t\n}","package physics.geometry;\n\n/**\n * ...\n * @author rje\n */\n\nclass VertexList \n{\n\n\tpublic var vertices : Array<Vector2D>;\n\tpublic var transformedVertices : Array<Vector2D>;\n\t\n\tpublic function new() \n\t{\n\t\tvertices = new Array<Vector2D>();\n\t\ttransformedVertices = new Array<Vector2D>();\n\t}\n\t\n\tpublic function AddVertex(v:Vector2D):Vector2D {\n\t\tvertices.push(v);\n\t\tvar tV = v.clone();\n\t\ttransformedVertices.push(tV);\n\t\treturn tV;\n\t}\n\t\n\tpublic function RemoveVertex(v:Vector2D):Void {\n\t\tfor (i in 0...transformedVertices.length) {\n\t\t\tif (transformedVertices[i] == v) {\n\t\t\t\tvertices.splice(i, 1);\n\t\t\t\ttransformedVertices.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic function Update( rotation : Vector2D , flipVerticaly:Bool) : Void {\n\t\tvar vertexCount = vertices.length;\n\t\tfor (i in 0...vertexCount) {\n\t\t\tvar v = vertices[i];\n\t\t\tvar tv = transformedVertices[i];\n\t\t\ttv.x = (v.x * rotation.x - v.y * rotation.y);\n\t\t\ttv.y = (v.x * rotation.y + v.y * rotation.x);\n\t\t\t\n\t\t\tif (flipVerticaly) {\n\t\t\t\ttv.x *= -1;\n\t\t\t\ttv.y *= -1;\n\t\t\t}\n\t\t}\t\t\n\t}\n\t\n}","\npackage utils;\n\nimport haxe.ds.StringMap;\n\nclass EventTarget \n{\n\n    public var listeners:StringMap<Array<Dynamic->Void>>;\n\n    public function new() {\n        listeners = new StringMap<Array<Dynamic->Void>>();\n    }\n\n    public function addEventListener(type:String,listener:Dynamic->Void) {\n        if (!listeners.exists(type)) {\n            listeners.set(type,new Array<Dynamic->Void>());\n        }\n        var listenerTypes = listeners.get(type);\n        if (Lambda.indexOf(listenerTypes,listener)<0) {\n            listenerTypes.push(listener);\n        }\n    }\n\n    public function dispatchEvent(event:Dynamic) {\n        var listenerTypes = listeners.get(event.type);\n        if (listenerTypes==null) return;\n        for (listener in listenerTypes) {\n            listener(event);\n        }\n    }\n\n    public function removeEventListener(type:String,listener:Dynamic->Void) {\n\n    }\n\n}","\npackage utils;\n\nimport haxe.ds.StringMap;\nimport js.html.Image;\nimport js.html.XMLHttpRequest;\nimport utils.EventTarget;\n\nclass AssetLoader extends EventTarget\n{\n\n\n    public var assets:StringMap<Dynamic>;\n    public var loaders:Array<ILoader>;\n    public var completeCount:Int;\n    public var running:Bool;\n\n    public function new() {\n        super();\n        assets = new StringMap<Dynamic>();\n        Reset();\n    }\n\n    public function Reset() {\n        running = false;\n        loaders = new Array<ILoader>();       \n    }\n\n    public function SetImagesToLoad(urls:Array<String>) {\n        for (url in urls) {\n            AddAsset(url);\n        }\n    }\n\n    public function AddAsset(url:String):Void {\n        if (running==true)\n            return;\n        var loader = LoaderFactory(url);\n        loader.Init(url);\n        loaders.push(loader);\n    }\n\n    private function LoaderFactory(url:String):ILoader {\n        var extention = url.substring(url.length-3,url.length);\n        if (extention==\"png\")\n            return new ImageAsset(this);\n        if (extention==\"tmx\" || extention==\"xml\" || extention==\"son\")\n            return new BlobAsset(this);\n        return null;\n    }\n\n    public function Load() {\n        if (running==true || loaders.length==0)\n            return;\n        completeCount = loaders.length;\n        running = true;\n        for (loader in loaders)\n            loader.Load();\n    }\n\n    public function onLoad(item:ILoader):Void {\n        completeCount--;\n        assets.set(item.getKey(),item.getValue());\n        if (completeCount==0) {\n            super.dispatchEvent({type:\"loaded\",count:completeCount});\n            running = false;\n        }\n    }\n\n}\n\ninterface ILoader\n{\n    function Init(url:String):Void;\n    function Load():Void;\n    function getKey():String;\n    function getValue():Dynamic;\n}\n\nclass ImageAsset implements ILoader\n{\n    public var mgr:AssetLoader;\n    public var image:Image;\n    public var url:String;\n\n    public function new(mgr:AssetLoader) {\n        this.mgr = mgr;\n    }\n\n    public function Init(url:String) {\n        this.url = url;\n        image = new Image();\n        image.onload = onLoad;\n        image.crossOrigin = \"anonymous\";\n    }\n\n    public function Load():Void {\n        image.src = url;\n        if (image.complete==true) {\n            onLoad(null);\n        } \n    }\n\n    public function onLoad(event:Dynamic):Void {\n        if (mgr!=null) {\n            mgr.onLoad(this);\n        }\n    }\n\n    public function getKey():String {\n        return url;\n    }\n\n    public function getValue():Dynamic {\n        return image;\n    }\n\n}\n\nclass BlobAsset implements ILoader\n{\n    public var mgr:AssetLoader;\n    public var xhr:XMLHttpRequest;\n    public var url:String;\n\n    public function new(mgr:AssetLoader) {\n        this.mgr = mgr;\n    }\n\n    public function Init(url:String) {\n        this.url = url;\n        xhr = new XMLHttpRequest();\n        xhr.open(\"GET\",url,true);\n        xhr.responseType = \"text\";\n        xhr.onload = onLoad;\n    }\n\n    public function Load():Void {\n        xhr.send();\n    }\n\n    public function onLoad(event:Dynamic):Void {\n        if (mgr!=null) {\n            mgr.onLoad(this);\n        }\n    }\n\n    public function getKey():String {\n        return url;\n    }\n\n    public function getValue():Dynamic {\n        return xhr.response;\n    }\n\n}\n","\npackage utils;\n\nimport js.html.ArrayBuffer;\nimport js.html.Uint8Array;\n\nclass Base64 \n{\n\n    public static var keyStr:String = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n    public static function Decode(input:String):ArrayBuffer {\n        var len = (input.length/4)*3;\n\n        var lkey1 = keyStr.indexOf(input.charAt(input.length-1));\n        var lkey2 = keyStr.indexOf(input.charAt(input.length-2));\n\n        if (lkey1 == 64) len--;\n        if (lkey2 == 64) len--;\n\n        var ab = new ArrayBuffer(len);\n        var uarray = new Uint8Array(ab);\n\n        var r = ~/[^A-Za-z0-9\\+\\/=]/g;\n\n        input = r.replace(input,\"\");\n        \n        var i = 0, j = 0;\n        while (i<len) {\n            var enc1 = keyStr.indexOf(input.charAt(j++));\n            var enc2 = keyStr.indexOf(input.charAt(j++));\n            var enc3 = keyStr.indexOf(input.charAt(j++));\n            var enc4 = keyStr.indexOf(input.charAt(j++));\n            var chr1 = (enc1<<2)|(enc2>>4);\n            var chr2 = ((enc2&15)<<4)|(enc3>>2);\n            var chr3 = (enc3&3)<<6|enc4;\n            uarray[i] = chr1;\n            if (enc3!=64) uarray[i+1] = chr2;\n            if (enc4!=64) uarray[i+2] = chr3;\n\n            i+=3;\n        }\n        return ab;\n    }\n\n}","package utils;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Maths \n{\n\n\tinline public static var ZERO_TOLERANCE = 1e-08;\n\n\tinline public static var RAD_DEG = 180 / PI;\n\n\tinline public static var DEG_RAD = PI / 180;\n\n\tinline public static var LN2 = 0.6931471805599453;\n\n\tinline public static var LN10 = 2.302585092994046;\n\n\tinline public static var PIHALF = 1.5707963267948966;\n\n\tinline public static var PI = 3.141592653589793;\n\n\tinline public static var PI2 = 6.283185307179586;\n\n\tinline public static var EPS = 1e-6;\n\n\tinline public static var SQRT2 = 1.414213562373095;\n\n\t\n\tinline public static function toRad(deg:Float):Float\n\t{\n\t\treturn deg * DEG_RAD;\n\t}\n\n\tinline public static function toDeg(rad:Float):Float\n\t{\n\t\treturn rad * RAD_DEG;\n\t}\n\n\t\n\tinline public static function Clamp(input:Float, min:Float, max:Float):Float {\n\t\tif (input > max) \n\t\t\treturn max;\t\n\t\telse if (input < min) \n\t\t\treturn min;\n\t\telse \n\t\t\treturn input;\n\t} \n\t\n\tpublic static function ScaleRectangleWithRatio(containerRect:Vector2D, itemRect:Vector2D):Float {\n\t\t\n\t\t//var sX = itemRect.x / containerRect.x;\n\t\t//var sY = itemRect.y / containerRect.y;\n\t\t\n\t\tvar sX = containerRect.x / itemRect.x;\n\t\tvar sY = containerRect.y / itemRect.y;\n\t\t\n\t\tvar rD = containerRect.x / containerRect.y;\n\t\tvar rR = itemRect.x / itemRect.y;\n\t\t\n\t\treturn rD < rR ? sX : sY;\n\t\t\n\t}\n\t\n}","package utils;\n\n/**\n * ...\n * @author rje\n */\n\nclass Random \n{\n\n\tprivate static var PseudoRandomSeed:Int = 3489752;\n\n\tinline public static function SetPseudoRandomSeed(seed:Int):Void {\n\t\tPseudoRandomSeed = seed;\n\t}\n\n\tinline public static function RandomFloat(min : Float,max : Float) : Float {\n\t\treturn  Math.random() * (max - min) + min;\n\t}\n\n\tinline public static function RandomBoolean(chance : Float = 0.5) : Bool {\n\t\treturn ( Math.random() < chance);\n\t}\n\n\tinline public static function RandomSign(chance : Float = 0.5) : Int {\n\t\treturn ( Math.random() < chance) ? 1 : -1;\n\t}\n\n\tinline public static function RandomInteger(min : Int,max : Int) : Int {\n\t\treturn Math.floor(RandomFloat(min, max));\n\t}\n\t\n\tinline public static function PseudoInteger(n : Int = Limits.INT32_MAX) : Int {\n\t\treturn n > 0 ? Std.int(PseudoFloat() * n) : Std.int(PseudoFloat());\n\t}\n\n\tinline public static function PseudoFloat() : Float {\n\t\tPseudoRandomSeed = (PseudoRandomSeed * 9301 + 49297) % 233280;\n\t\treturn PseudoRandomSeed / 233280.0;\n\t}\t\n\t\n}","\npackage wgr.display;\n\nimport js.html.Float32Array;\nimport wgr.display.DisplayObjectContainer;\nimport wgr.display.Stage;\nimport wgr.geom.Matrix3;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\n\nclass DisplayObject \n{\n    public var id:String;\n    public var position:Point;\n    public var scale:Point;\n    public var pivot:Point;\n    public var rotation(get,set):Float;\n    private var _rotation:Float;\n    private var _rotationComponents:Point;\n    public var alpha:Float;\n    public var visible(get,set):Bool;\n    private var _visible:Bool;\n    public var renderable:Bool;\n\n    public var aabb:AABB;\n\n    public var parent:DisplayObjectContainer;\n    public var stage:Stage;\n\n    public var worldTransform:Float32Array;\n    public var worldAlpha:Float;\n    public var localTransform:Float32Array;\n\n    public var prev:DisplayObject;\n    public var next:DisplayObject;\n\n    public function new() {\n        position = new Point();\n        scale = new Point(1,1);\n        pivot = new Point();\n        _rotationComponents = new Point();\n        rotation = 0;\n        alpha = 1;\n        visible = true;\n        renderable = false;\n        aabb = new AABB();\n        parent = null;\n        worldTransform = Matrix3.Create();\n        localTransform = Matrix3.Create();\n    }\n\n    public inline function get_rotation():Float {  \n        return _rotation;\n    }\n\n    public inline function set_rotation(v:Float):Float {\n        _rotation = v;\n        _rotationComponents.x = Math.cos(_rotation);\n        _rotationComponents.y = Math.sin(_rotation);\n        return _rotation;\n    }\n\n    public inline function get_visible():Bool {  \n        return _visible;\n    }\n\n    public inline function set_visible(v:Bool):Bool {\n        _visible = v;\n        if (stage!=null)\n            stage.dirty = true;\n        return _visible;\n    }\n    public function RoundFunction(v:Float):Float {\n        // return v;\n        // return Math.round(v);\n        return Math.round( v * 10) / 10;\n    }\n\n    public function updateTransform() {\n        //TODO Rounding at the moment...\n        //position.x = Math.round(position.x);\n        //position.y = Math.round(position.y);\n\n        //JS hack, much faster...\n         // var positionx:Int = untyped{(0.5 + position.x) >> 0;};\n         // var positiony:Int = untyped{(0.5 + position.y) >> 0;};\n        //positionx = cast Math.round( position.x * 10) / 10;\n        //positiony = cast Math.round( position.y * 10) / 10;\n\n        //var positionx:Int = Math.round(position.x);\n        //var positiony:Int = Math.round(position.y);\n\n        var positionx:Int = Math.floor(position.x + 0.5);\n        var positiony:Int = Math.floor(position.y + 0.5);\n\n        var sinR = _rotationComponents.y;//Math.sin(rotation);\n        var cosR = _rotationComponents.x;//Math.cos(rotation);\n        \n        localTransform[0] =  cosR * scale.x;\n        localTransform[1] = -sinR * scale.y;\n        localTransform[3] =  sinR * scale.x;\n        localTransform[4] =  cosR * scale.y;\n\n        var px = pivot.x;\n        var py = pivot.y;\n\n        var parentTransform = parent.worldTransform;\n\n        var a00 = localTransform[0];\n        var a01 = localTransform[1];\n        var a02 = positionx - localTransform[0] * px - py * localTransform[1];\n        var a10 = localTransform[3];\n        var a11 = localTransform[4];\n        var a12 = positiony - localTransform[4] * py - px * localTransform[3];\n        var b00 = parentTransform[0];\n        var b01 = parentTransform[1];\n        var b02 = parentTransform[2];\n        var b10 = parentTransform[3];\n        var b11 = parentTransform[4];\n        var b12 = parentTransform[5];\n\n        localTransform[2] = a02;\n        localTransform[5] = a12;\n\n        worldTransform[0] = b00 * a00 + b01 * a10;\n        worldTransform[1] = b00 * a01 + b01 * a11;\n        worldTransform[2] = b00 * a02 + b01 * a12 + b02;\n\n        worldTransform[3] = b10 * a00 + b11 * a10;\n        worldTransform[4] = b10 * a01 + b11 * a11;\n        worldTransform[5] = b10 * a02 + b11 * a12 + b12;\n\n        worldAlpha = alpha*parent.worldAlpha;\n\n    }\n\n    public function calcExtents() {\n        \n    }\n\n    //TODO Probably get rid of this...\n    public function applySlot(slot:DisplayObject->Dynamic->Bool,p:Dynamic=null):Bool {\n        return slot(this,p);    \n    }\n\n\n}","\npackage wgr.display;\n\nimport wgr.geom.AABB;\nimport wgr.display.DisplayObject;\n\nclass DisplayObjectContainer extends DisplayObject\n{\n    public var head:DisplayObject;\n    public var tail:DisplayObject;\n    public var childCount:Int;\n\n    public var subTreeAABB:AABB;\n\n    public function new() { \n        super();\n        subTreeAABB = new AABB();\n        childCount = 0;\n    }\n\n    public function addChild(child:DisplayObject) {\n        if (child.parent!=null)\n            child.parent.removeChild(child);\n        insertEnd(child);\n        childAdded(child);\n    }   \n\n    public function addChildAt(child:DisplayObject,index:Int) {\n        if (index>=childCount) {\n            addChild(child);\n            return;\n        }\n        if (index==0) {\n            insertBeginning(child);\n        } else {\n            insertBefore(findChildByIndex(index),child);\n        }\n        childAdded(child);\n    }\n\n    private inline function childAdded(child:DisplayObject) {\n        childCount++;\n        child.parent = this;\n        child.applySlot(function(target:DisplayObject,p:Dynamic){target.stage=cast p;return true;},stage);\n        if (stage!=null) \n            stage.dirty = true;\n    }\n\n    private function findChildByIndex(index:Int):DisplayObject {\n        var child = head;\n        var count = 0;\n        while (child!=null) {\n            if (count++==index)\n                return child;\n            child = child.next;\n        }\n        return tail;\n    }\n\n    public function removeChild(child:DisplayObject) {\n        if (child.parent==this) {\n            remove(child);\n            childRemoved(child);\n        }\n    }\n\n    public function removeChildAt(index:Int):DisplayObject {\n        var child = findChildByIndex(index);\n        trace(child);\n        removeChild(child);\n        this.debug();\n        return child;\n    }\n\n    private inline function childRemoved(child:DisplayObject) {\n        childCount--;\n        if (stage!=null) \n            stage.dirty = true;\n        child.parent = null;\n        child.applySlot(function(target:DisplayObject,p:Dynamic){target.stage=null;return true;},null);\n    }\n\n    public override function updateTransform() {\n        //Reset AABB\n        aabb.reset();\n        super.updateTransform();\n        calcExtents();\n        subTreeAABB.reset();\n        subTreeAABB.addAABB(aabb);\n        //Expand AAABB to this DisplayObject -> New function required\n        var child = head;\n        while (child!=null) {\n            child.updateTransform();\n            //Inflate this AABB to encapsulate child\n            subTreeAABB.addAABB(child.aabb);\n            child = child.next;\n        }\n    }\n\n    public function apply(slot:DisplayObject->Dynamic->Void,p:Dynamic=null) {\n\n    }\n\n    //TODO Probably get rid of this...\n    public override function applySlot(slot:DisplayObject->Dynamic->Bool,p:Dynamic=null):Bool {\n        if (!super.applySlot(slot,p))\n            return false; \n        var child = head;\n        while (child!=null) {\n            child.applySlot(slot,p);\n            child = child.next;\n        }\n        return true;\n    }\n\n    //Linked List Functions\n    public inline function insertAfter(node:DisplayObject,newNode:DisplayObject) {\n        newNode.prev = node;\n        newNode.next = node.next;\n        if (node.next==null)\n            tail = newNode;\n        else\n            node.next.prev = newNode;\n        node.next = newNode;\n    }\n\n    public inline function insertBefore(node:DisplayObject,newNode:DisplayObject) {\n        newNode.prev = node.prev;\n        newNode.next = node;\n        if (node.prev == null)\n            head = newNode;\n        else\n            node.prev.next = newNode;\n        node.prev = newNode;\n    }\n\n    public inline function insertBeginning(newNode:DisplayObject) {\n        if (head == null) {\n            head = newNode;\n            tail = newNode;\n            newNode.prev = null;\n            newNode.next = null;\n        } else  \n            insertBefore(head, newNode);\n     }\n\n     public inline function insertEnd(newNode:DisplayObject) {\n        if (tail == null)\n            insertBeginning(newNode);\n        else\n            insertAfter(tail, newNode);\n     }\n\n    public inline function remove(node:DisplayObject) {\n        if (node.prev == null)\n            head = node.next;\n        else\n            node.prev.next = node.next;\n        if (node.next == null)\n            tail = node.prev;\n        else\n            node.next.prev = node.prev;\n        node.prev = node.next = null;\n    }\n\n    public function debug() {\n        var child = head;\n        while (child!=null) {\n            trace(child.id);\n            child = child.next;\n        }\n    }\n\n}","\npackage wgr.display;\n\nimport wgr.display.DisplayObjectContainer;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\n\nclass Camera extends DisplayObjectContainer\n{\n\n    public var realPosition:Point;\n    public var viewportSize:Point;\n    public var halfViewportSize:Point;\n    public var viewPortAABB:AABB;\n    public var worldExtentsAABB:AABB;\n    private var cameraExtentsAABB:AABB;\n\n    public function new() {\n        super();\n        id = \"Camera\";\n        realPosition = new Point();\n        viewportSize = new Point();\n        halfViewportSize = new Point();\n        viewPortAABB = new AABB();\n        worldExtentsAABB = new AABB();\n    }\n\n    public function Focus(x:Float,y:Float) {\n        //Need to move the camera container the oposite way to the actual coords\n        realPosition.x = x;\n        realPosition.y = y;\n        //Clamp position inside shrunk camera extents\n        cameraExtentsAABB.fitPoint(realPosition);\n        position.x = -realPosition.x+halfViewportSize.x;\n        position.y = -realPosition.y+halfViewportSize.y;\n    }\n\n    public function Resize(width:Int,height:Int) {\n        viewportSize.x = width;\n        viewportSize.y = height;\n        halfViewportSize.x = width/2;\n        halfViewportSize.y = height/2;\n        viewPortAABB.l = viewPortAABB.t = 0;\n        viewPortAABB.r = viewportSize.x;\n        viewPortAABB.b = viewportSize.y;\n        //Clone the world size, then shrink it around the center by viewport size\n        cameraExtentsAABB = worldExtentsAABB.clone();\n        cameraExtentsAABB.shrinkAroundCenter(width,height);\n    }\n\n\n}","\npackage wgr.display;\n\nimport js.html.Float32Array;\nimport wgr.display.DisplayObjectContainer;\nimport wgr.geom.Point;\nimport wgr.texture.Texture;\n\nclass Sprite extends DisplayObjectContainer\n{\n\n    public var anchor:Point;\n    public var texture:Texture;\n    public var blendMode:Int;\n    // private var width:Float;\n    // private var height:Float;\n\n    public var prevSprite:Sprite;\n    public var nextSprite:Sprite;\n\n    public var transformedVerts:Float32Array;\n\n    public function new() {\n        super();\n        renderable = true;\n        anchor = new Point();\n        transformedVerts = new Float32Array(8);\n    }\n\n    public override function calcExtents() {\n        var width = texture.frame.width;\n        var height = texture.frame.height;\n\n        var aX = anchor.x;\n        var aY = anchor.y;\n        var w0 = width * (1-aX);\n        var w1 = width * -aX;\n\n        var h0 = height * (1-aY);\n        var h1 = height * -aY;\n\n        var a = worldTransform[0];\n        var b = worldTransform[3];\n        var c = worldTransform[1];\n        var d = worldTransform[4];\n        var tx = worldTransform[2];\n        var ty = worldTransform[5];\n\n        transformedVerts[0] = a * w1 + c * h1 + tx; \n        transformedVerts[1] = d * h1 + b * w1 + ty;\n\n        transformedVerts[2] = a * w0 + c * h1 + tx; \n        transformedVerts[3] = d * h1 + b * w0 + ty; \n\n        transformedVerts[4] = a * w0 + c * h0 + tx; \n        transformedVerts[5] = d * h0 + b * w0 + ty; \n\n        transformedVerts[6] =  a * w1 + c * h0 + tx; \n        transformedVerts[7] =  d * h0 + b * w1 + ty;\n\n        for (i in 0...4) { \n            aabb.addPoint(transformedVerts[i*2],transformedVerts[(i*2)+1]);\n        }\n    }\n\n}","\npackage wgr.display;\n\nimport wgr.display.DisplayObject;\nimport wgr.display.DisplayObjectContainer;\nimport wgr.display.Sprite;\n\nclass Stage extends DisplayObjectContainer\n{\n\n    public var renderHead:Sprite;\n    public var renderTail:Sprite;\n    public var renderCount:Int;\n    public var dirty:Bool;\n\n    public function new() {\n        super();\n        id = \"Stage\";\n        worldAlpha = alpha;\n        stage = this;\n    }\n\n    public override function updateTransform() { \n        var child = head;\n        while (child!=null) {\n            child.updateTransform();\n            child = child.next;\n        }\n    }\n\n    public function PreRender() {\n        if (dirty==true) {\n            Flatten();\n            dirty=false;\n        }\n    }\n\n    /*\n     *   Depth-first Pre-order traversal of tree\n     */\n    public function Flatten() {\n        //trace(\"Flatten\");\n        renderHead = null;\n        renderTail = null;\n        renderCount = 0;\n        //Traverse(this);\n    }\n\n    public function Traverse(node:DisplayObject) {\n        //This node not visible? Snip it all off...\n        if (node.visible==false)\n            return;\n        //Is this a Sprite? If so put it in the list\n        if (Std.is(node, Sprite)) {\n            if (renderHead==null) {\n                renderHead = cast node;\n                renderHead.prevSprite = renderHead.nextSprite = null;\n            } else {\n                var sprite:Sprite = cast node;\n                sprite.prevSprite = sprite.nextSprite = null;\n                if (renderTail==null) {\n                    renderTail = sprite;\n                    renderHead.nextSprite = renderTail;\n                    renderTail.prevSprite = renderHead;\n                } else {\n                    renderTail.nextSprite = sprite;\n                    sprite.prevSprite = renderTail;\n                    renderTail = sprite;                    \n                }\n            }\n            renderCount++;\n        }\n        //Parse the other children\n        if (Std.is(node, DisplayObjectContainer)) {\n            var doc:DisplayObjectContainer = cast node;\n            var child = doc.head;\n            while (child!=null) {\n                Traverse(child);\n                child = child.next;\n            }\n        }\n    }\n\n}","package wgr.geom;\n\nimport wgr.geom.Point;\n\nclass AABB \n{\n\n    public var t:Float;\n    public var r:Float;\n    public var b:Float;\n    public var l:Float;\n    public var width(get,never):Float;\n    public var height(get,never):Float;\n\n    public function new(t=.0,r=.0,b=.0,l=.0) {\n        this.t = t;\n        this.r = r;\n        this.b = b;\n        this.l = l;\n    }\n\n    public function clone():AABB {\n        return new AABB(t,r,b,l);\n    }\n\n    public inline function reset() {\n        t = l = Math.POSITIVE_INFINITY;\n        r = b = Math.NEGATIVE_INFINITY;\n    }\n\n    public inline function get_width():Float {  \n        return r-l;\n    }\n\n    public inline function get_height():Float {  \n        return b-t;\n    }\n\n    public inline function intersect(aabb:AABB):Bool {\n        if (l > aabb.r)\n            return false;\n        else if (r < aabb.l)\n            return false;\n        else if (t > aabb.b)\n            return false;\n        else if (b < aabb.t)\n            return false;\n        else return true;\n    }\n\n    public inline function addAABB(aabb:AABB) {\n        if (aabb.t<t) t=aabb.t;\n        if (aabb.r>r) r=aabb.r;\n        if (aabb.b>b) b=aabb.b;\n        if (aabb.l<l) l=aabb.l;\n    }\n\n    public inline function addPoint(x:Float,y:Float) {\n        if (y<t) t=y;\n        if (x>r) r=x;\n        if (y>b) b=y;\n        if (x<l) l=x;\n    }\n\n    public inline function fitPoint(point:Point) {\n        if (point.x<l) point.x=l;\n        if (point.x>r) point.x=r;\n        if (point.y<t) point.y=t;\n        if (point.y>b) point.y=b;\n    }\n\n    public inline function shrinkAroundCenter(deltaWidth:Float,delatHeight:Float) {\n        l += deltaWidth/2;\n        r -= deltaWidth/2;\n        t += delatHeight/2;\n        b -= delatHeight/2;\n    }\n\n    public function shrink(i:Float) {\n        l+=i;\n        r-=i;\n        t+=i;\n        b-=i;\n    }\n\n}","\npackage wgr.geom;\n\nimport js.html.Float32Array;\nimport wgr.geom.Matrix4;\n\nclass Matrix3\n{\n\n    public static function Create():Float32Array {\n        return Identity(new Float32Array(9));\n    }\n\n    public static function Identity(matrix:Float32Array) {\n        matrix[0] = 1;\n        matrix[1] = 0;\n        matrix[2] = 0;\n        matrix[3] = 0;\n        matrix[4] = 1;\n        matrix[5] = 0;\n        matrix[6] = 0;\n        matrix[7] = 0;\n        matrix[8] = 1;\n\n        return matrix;\n    }\n\n    public static function Multiply(mat:Float32Array,mat2:Float32Array,dest:Float32Array) {\n        if (dest!=null) \n            dest = mat;\n\n        var a00 = mat[0], a01 = mat[1], a02 = mat[2],\n        a10 = mat[3], a11 = mat[4], a12 = mat[5],\n        a20 = mat[6], a21 = mat[7], a22 = mat[8],\n\n        b00 = mat2[0], b01 = mat2[1], b02 = mat2[2],\n        b10 = mat2[3], b11 = mat2[4], b12 = mat2[5],\n        b20 = mat2[6], b21 = mat2[7], b22 = mat2[8];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n        dest[3] = b10 * a00 + b11 * a10 + b12 * a20;\n        dest[4] = b10 * a01 + b11 * a11 + b12 * a21;\n        dest[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n        dest[6] = b20 * a00 + b21 * a10 + b22 * a20;\n        dest[7] = b20 * a01 + b21 * a11 + b22 * a21;\n        dest[8] = b20 * a02 + b21 * a12 + b22 * a22;\n\n        return dest;\n    }\n\n    public static function Clone(mat:Float32Array):Float32Array {\n        var matrix = new Float32Array(9);\n        matrix[0] = mat[0];\n        matrix[1] = mat[1];\n        matrix[2] = mat[2];\n        matrix[3] = mat[3];\n        matrix[4] = mat[4];\n        matrix[5] = mat[5];\n        matrix[6] = mat[6];\n        matrix[7] = mat[7];\n        matrix[8] = mat[8];\n\n        return matrix;\n    }\n\n    public static function Transpose(mat:Float32Array,dest:Float32Array):Float32Array {\n        if (dest!=null || mat==dest) {\n            var a01 = mat[1], a02 = mat[2], a12 = mat[5];\n            mat[1] = mat[3];\n            mat[2] = mat[6];\n            mat[3] = a01;\n            mat[5] = mat[7];\n            mat[6] = a02;\n            mat[7] = a12;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = mat[3];\n        dest[2] = mat[6];\n        dest[3] = mat[1];\n        dest[4] = mat[4];\n        dest[5] = mat[7];\n        dest[6] = mat[2];\n        dest[7] = mat[5];\n        dest[8] = mat[8];\n\n        return dest;       \n    }\n\n    public static function ToMatrix4(mat:Float32Array,dest:Float32Array):Float32Array {\n        if (dest==null) { \n            dest = Matrix4.Create();\n        }\n\n        dest[15] = 1;\n        dest[14] = 0;\n        dest[13] = 0;\n        dest[12] = 0;\n\n        dest[11] = 0;\n        dest[10] = mat[8];\n        dest[9] = mat[7];\n        dest[8] = mat[6];\n\n        dest[7] = 0;\n        dest[6] = mat[5];\n        dest[5] = mat[4];\n        dest[4] = mat[3];\n\n        dest[3] = 0;\n        dest[2] = mat[2];\n        dest[1] = mat[1];\n        dest[0] = mat[0];\n\n        return dest;\n    }\n\n}","\npackage wgr.geom;\n\nimport js.html.Float32Array;\n\nclass Matrix4 \n{\n\n    public static function Create():Float32Array {\n        return Identity(new Float32Array(16));\n    }\n\n    public static function Identity(matrix:Float32Array) {\n        matrix[0] = 1;\n        matrix[1] = 0;\n        matrix[2] = 0;\n        matrix[3] = 0;\n        matrix[4] = 0;\n        matrix[5] = 1;\n        matrix[6] = 0;\n        matrix[7] = 0;\n        matrix[8] = 0;\n        matrix[9] = 0;\n        matrix[10] = 1;\n        matrix[11] = 0;\n        matrix[12] = 0;\n        matrix[13] = 0;\n        matrix[14] = 0;\n        matrix[15] = 1;\n\n        return matrix;\n    }\n\n    public static function Transpose(mat:Float32Array,dest:Float32Array):Float32Array {\n        if (dest!=null || mat == dest)  {\n            var a01 = mat[1], a02 = mat[2], a03 = mat[3],\n                a12 = mat[6], a13 = mat[7],\n                a23 = mat[11];\n\n            mat[1] = mat[4];\n            mat[2] = mat[8];\n            mat[3] = mat[12];\n            mat[4] = a01;\n            mat[6] = mat[9];\n            mat[7] = mat[13];\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = mat[14];\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n\n            return mat;\n        }\n\n        dest[0] = mat[0];\n        dest[1] = mat[4];\n        dest[2] = mat[8];\n        dest[3] = mat[12];\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = mat[9];\n        dest[7] = mat[13];\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = mat[14];\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n\n        return dest;\n    }\n\n    public static function Multiply(mat:Float32Array,mat2:Float32Array,dest:Float32Array) {\n        if (dest!=null) { \n            dest = mat; \n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        var a00 = mat[ 0], a01 = mat[ 1], a02 = mat[ 2], a03 = mat[3];\n        var a10 = mat[ 4], a11 = mat[ 5], a12 = mat[ 6], a13 = mat[7];\n        var a20 = mat[ 8], a21 = mat[ 9], a22 = mat[10], a23 = mat[11];\n        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];\n\n        // Cache only the current line of the second matrix\n        var b0  = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];  \n        dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n        dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n        dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n        dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n        b0 = mat2[4];\n        b1 = mat2[5];\n        b2 = mat2[6];\n        b3 = mat2[7];\n        dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n        dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n        dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n        dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n        b0 = mat2[8];\n        b1 = mat2[9];\n        b2 = mat2[10];\n        b3 = mat2[11];\n        dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n        dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n        dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n        dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n        b0 = mat2[12];\n        b1 = mat2[13];\n        b2 = mat2[14];\n        b3 = mat2[15];\n        dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n        dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n        dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n        dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n        return dest;\n    }\n\n}","\npackage wgr.geom;\n\nclass Point \n{\n\n    public var x:Float;\n    public var y:Float;\n\n    public function new(x = 0.,y = 0.) {\n        this.x = x;\n        this.y = y;\n    }\n\n}","\npackage wgr.geom;\n\nclass Rectangle \n{\n\n    public var x:Float;\n    public var y:Float;\n    public var width:Float;\n    public var height:Float;\n\n    public function new(x = 0.,y = 0.,width = 0.,height = 0.) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n}","package wgr.particle;\n\nimport wgr.geom.Point;\n\nclass BlockSpriteParticle\n{\n\n    public static inline var INV_ALPHA:Float = 1/255;\n    \n    public var pX:Float;\n    public var pY:Float;\n\n    public var vX:Float;\n    public var vY:Float;\n    \n    public var fX:Float;\n    public var fY:Float;\n    \n    public var externalForce:Point;\n    \n    public var age:Float;\n    public var ttl:Float;\n    public var damping:Float;\n    \n    public var decay:Float;\n\n    public var size:Int;    \n    public var alpha:Float;\n    public var red:Int;\n    public var green:Int;\n    public var blue:Int;\n\n    public var next:BlockSpriteParticle;\n    public var prev:BlockSpriteParticle;\n\n    public var alphaPerUpdate:Float;\n\n    public function new() \n    {\n    }\n    \n    inline public function Initalize(x:Float, y:Float, vX:Float, vY:Float, fX:Float, fY:Float, ttl:Int, damping:Float, decay:Float, top:Bool, externalForce:Point, data1:Int, data2:Int, data3:Int,data4:Int,data5:Int) {\n        this.pX = x;\n        this.pY = y;\n        this.vX = vX;\n        this.vY = vY;\n        this.fX = fX;\n        this.fY = fY;\n        this.ttl = ttl;\n        this.age = ttl;\n        this.damping = damping;\n        this.decay = decay;\n        this.externalForce = externalForce;\n        this.size = data1;\n        this.alpha = untyped{ data2 * INV_ALPHA; }\n        this.red = data3;\n        this.green = data4;\n        this.blue = data5;\n    }\n    \n    inline public function Update(deltaTime:Float,invDeltaTime:Float):Bool {\n        vX += fX + externalForce.x;\n        vY += fY + externalForce.y;\n        vX *= damping;\n        vY *= damping;\n        pX += vX * invDeltaTime;\n        pY += vY * invDeltaTime;\n        age -= deltaTime;\n        alpha -= decay;\n        //trace(decay);\n        return age > 0;\n    }\n    \n}","\npackage wgr.particle;\n\nimport wgr.geom.Point;\nimport wgr.particle.BlockSpriteParticle;\nimport wgr.renderers.webgl.PointSpriteLightMapRenderer;\nimport wgr.renderers.webgl.PointSpriteRenderer;\n\nclass BlockSpriteParticleEngine implements IParticleEngine\n{\n    public var particleCount:Int;\n    public var deltaTime:Float;\n    public var invDeltaTime:Float;\n    public var activeParticles:BlockSpriteParticle;\n    public var cachedParticles:BlockSpriteParticle;\n        \n    public var renderer:PointSpriteLightMapRenderer;\n    public var ZERO_FORCE:Point;\n\n    public function new(particleCount:Int, deltaTime:Float) \n    {\n        this.particleCount = particleCount;\n        this.deltaTime = deltaTime;\n        this.invDeltaTime = deltaTime / 1000;\n        ZERO_FORCE = new Point();\n        for (i in 0...particleCount) {\n            var p = new BlockSpriteParticle();\n            p.next = cachedParticles;\n            cachedParticles = p;\n        }\n        this.renderer = new PointSpriteLightMapRenderer();\n        this.renderer.ResizeBatch(particleCount);\n    }\n    \n    public function EmitParticle(x:Float, y:Float, vX:Float, vY:Float, fX:Float, fY:Float, ttl:Int, damping:Float, decayable:Bool, top:Bool, externalForce:Point, data1:Int, data2:Int, data3:Int,data4:Int,data5:Int):Bool {\n        if (cachedParticles == null)\n            return false;\n            \n        var particle = cachedParticles;\n        cachedParticles = cachedParticles.next;\n        \n        if (activeParticles == null) {\n            activeParticles = particle;\n            particle.next = particle.prev = null;\n        } else {\n            particle.next = activeParticles;\n            particle.prev = null;\n            activeParticles.prev = particle;\n            activeParticles = particle;\n        }\n        \n        particle.Initalize(x, y, vX, vY, fX, fY, ttl, damping, decayable ? deltaTime/ttl : 0, top, externalForce!=null?externalForce:ZERO_FORCE, data1, data2, data3, data4, data5);\n\n        return true;\n    }\n        \n    public function Update():Void {\n        renderer.ResetBatch();\n        var particle = activeParticles;\n        while (particle != null) {\n            if (!particle.Update(deltaTime,invDeltaTime)) {\n                var next = particle.next;\n                if (particle.prev == null) {\n                    activeParticles =  particle.next;\n                } else {\n                    particle.prev.next = particle.next;\n                }\n                if (particle.next != null) {\n                    particle.next.prev = particle.prev;\n                }\n                particle.next = cachedParticles;\n                cachedParticles = particle;\n                                \n                particle = next;\n            } else {\n                renderer.AddSpriteToBatch(particle.pX,particle.pY,particle.size,Std.int(particle.alpha*255),particle.red,particle.green,particle.blue);\n                particle = particle.next;\n            }\n        }\n    }\n    \n}","\npackage wgr.particle;\n\nimport wgr.geom.Point;\n\nclass PointSpriteParticle\n{\n\n    public static inline var INV_ALPHA:Float = 1/255;\n    \n    public var pX:Float;\n    public var pY:Float;\n\n    public var vX:Float;\n    public var vY:Float;\n    \n    public var fX:Float;\n    public var fY:Float;\n    \n    public var type:Float;\n    public var size:Float;\n\n    public var externalForce:Point;\n    \n    public var age:Float;\n    public var ttl:Float;\n    public var damping:Float;\n    \n    public var decay:Float;\n    public var colour:Float;\n    public var alpha:Float;\n\n    public var next:PointSpriteParticle;\n    public var prev:PointSpriteParticle;\n\n    public function new() \n    {\n    }\n    \n    inline public function Initalize(x:Float, y:Float, vX:Float, vY:Float, fX:Float, fY:Float, ttl:Int, damping:Float, decay:Float, top:Bool, externalForce:Point, data1:Int, data2:Int, data3:Int,data4:Int) {\n        this.pX = x;\n        this.pY = y;\n        this.vX = vX;\n        this.vY = vY;\n        this.fX = fX;\n        this.fY = fY;\n        this.ttl = ttl;\n        this.age = ttl;\n        this.damping = damping;\n        this.decay = decay;\n        this.externalForce = externalForce;\n        this.type = data1;\n        this.size = data2;\n        this.colour = data3;\n        this.alpha = untyped{ (this.colour & 0xFF) * INV_ALPHA; }\n    }\n    \n    inline public function Update(deltaTime:Float,invDeltaTime:Float):Bool {\n        vX += fX + externalForce.x;\n        vY += fY + externalForce.y;\n        vX *= damping;\n        vY *= damping;\n        pX += vX * invDeltaTime;\n        pY += vY * invDeltaTime;\n        age -= deltaTime;\n        alpha -= decay;\n        return age > 0;\n    }\n    \n}","\npackage wgr.particle;\n\nimport wgr.geom.Point;\nimport wgr.particle.PointSpriteParticle;\nimport wgr.renderers.webgl.PointSpriteLightMapRenderer;\nimport wgr.renderers.webgl.PointSpriteRenderer;\n\nclass PointSpriteParticleEngine implements IParticleEngine\n{\n    public var particleCount:Int;\n    public var deltaTime:Float;\n    public var invDeltaTime:Float;\n    public var activeParticles:PointSpriteParticle;\n    public var cachedParticles:PointSpriteParticle;\n        \n    public var renderer:PointSpriteRenderer;\n    public var ZERO_FORCE:Point;\n\n    public function new(particleCount:Int, deltaTime:Float) \n    {\n        this.particleCount = particleCount;\n        this.deltaTime = deltaTime;\n        this.invDeltaTime = deltaTime / 1000;\n        ZERO_FORCE = new Point();\n        for (i in 0...particleCount) {\n            var p = new PointSpriteParticle();\n            p.next = cachedParticles;\n            cachedParticles = p;\n        }\n        this.renderer = new PointSpriteRenderer();\n        this.renderer.ResizeBatch(particleCount);\n    }\n    \n    public function EmitParticle(x:Float, y:Float, vX:Float, vY:Float, fX:Float, fY:Float, ttl:Int, damping:Float, decayable:Bool, top:Bool, externalForce:Point, data1:Int, data2:Int, data3:Int,data4:Int,data5:Int):Bool {\n        if (cachedParticles == null)\n            return false;\n            \n        var particle = cachedParticles;\n        cachedParticles = cachedParticles.next;\n        \n        if (activeParticles == null) {\n            activeParticles = particle;\n            particle.next = particle.prev = null;\n        } else {\n            particle.next = activeParticles;\n            particle.prev = null;\n            activeParticles.prev = particle;\n            activeParticles = particle;\n        }\n        \n        particle.Initalize(x, y, vX, vY, fX, fY, ttl, damping, decayable ? deltaTime/ttl : 0, top, externalForce!=null?externalForce:ZERO_FORCE, data1, data2, data3, data4);\n\n        return true;\n    }\n        \n    public function Update():Void {\n        renderer.ResetBatch();\n        var particle = activeParticles;\n        while (particle != null) {\n            if (!particle.Update(deltaTime,invDeltaTime)) {\n                var next = particle.next;\n                if (particle.prev == null) {\n                    activeParticles =  particle.next;\n                } else {\n                    particle.prev.next = particle.next;\n                }\n                if (particle.next != null) {\n                    particle.next.prev = particle.prev;\n                }\n                particle.next = cachedParticles;\n                cachedParticles = particle;\n                                \n                particle = next;\n            } else {\n                renderer.AddSpriteToBatch(Std.int(particle.type),particle.pX,particle.pY,particle.size,Std.int(particle.alpha*255),0xFF,0xFF,0xFF);\n                particle = particle.next;\n            }\n        }\n    }\n    \n}","\npackage wgr.particle.emitter;\n\nimport physics.geometry.Vector2D;\nimport wgr.particle.IParticleEngine;\n\nclass Explosion implements IParticleEmitter\n{\n\n    public var mass:Int;\n    public var power:Float;\n\n    public function new(mass:Int,power:Float) {\n        this.mass = mass;\n        this.power = power;\n    }\n\n    public function update(time:Float, position:Vector2D, engine:IParticleEngine):Void {\n        for (i in 0...mass) {\n            var angle = utils.Random.RandomFloat(0,Math.PI*2);\n            var p = utils.Random.RandomFloat(0,power*2);\n            var vx = Math.cos(angle) * p;\n            var vy = Math.sin(angle) * p;\n            engine.EmitParticle(position.x,position.y,vx,vy,0,0.5,utils.Random.RandomInteger(300,1000),0.9,true,true,null,4,255,255,0,0);\n        }\n    }\n\n\n}","\npackage wgr.particle.emitter;\n\nimport physics.geometry.Vector2D;\nimport wgr.particle.IParticleEngine;\n\nclass RandomSpray implements IParticleEmitter\n{\n\n    public var rate:Int;\n    public var speed:Float;\n\n    public function new(rate:Int,speed:Float) {\n        this.rate = rate;\n        this.speed = speed;\n    }\n\n    public function update(time:Float, position:Vector2D, engine:IParticleEngine):Void {\n        var angle = utils.Random.RandomFloat(0,2*Math.PI);\n        var vx = Math.cos(angle) * speed;\n        var vy = Math.sin(angle) * speed;\n        engine.EmitParticle(position.x,position.y,vx,vy,0,0,800,0.99,true,true,null,4,255,255,255,255);\n    }\n\n}","\npackage wgr.renderers.canvas;\n\nimport js.html.CanvasElement;\nimport js.html.CanvasRenderingContext2D;\nimport wgr.display.Camera;\n\nclass CanvasDebugView \n{\n    public var view:CanvasElement;\n    public var ctx:CanvasRenderingContext2D;\n    public var camera:Camera;\n    public var width:Int;\n    public var height:Int;\n\n    public function new(view:CanvasElement,camera:Camera,width:Int = 800,height:Int=600) {\n        this.view = view;\n        this.camera = camera;\n        ctx = view.getContext2d();\n        Resize(width,height);\n    }\n\n    public function Resize(width:Int,height:Int) {\n        this.width = width;\n        this.height = height;\n        view.width = width;\n        view.height = height;\n    }\n\n    public function Clear() {\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, width, height);\n        ctx.strokeStyle = \"rgba(0,255,0,1)\";\n        ctx.translate(camera.position.x,camera.position.y);\n    }\n\n    public function DrawRect(x:Float,y:Float,w:Float,h:Float) {\n        ctx.strokeRect(x,y,w,h);\n    }\n\n    public function DrawAABB(aabb:wgr.geom.AABB) {\n        ctx.strokeRect(aabb.l,aabb.t,aabb.width,aabb.height);\n    }\n\n    public function DrawPhysicsAABB(aabb:physics.geometry.AABB) {\n        ctx.beginPath();\n        ctx.moveTo(aabb.l,aabb.t);\n        ctx.lineTo(aabb.r,aabb.t);\n        ctx.moveTo(aabb.r,aabb.b);\n        ctx.lineTo(aabb.l,aabb.b);\n        ctx.stroke();    \n    }\n\n    public function DrawCross(x:Float,y:Float,l:Float) {\n        ctx.beginPath();\n        ctx.moveTo(x-l,y);\n        ctx.lineTo(x+l,y);\n        ctx.moveTo(x,y-l);\n        ctx.lineTo(x,y+l);\n        ctx.stroke();\n    }\n\n\n}","\npackage wgr.renderers.webgl;\n\nimport js.html.ArrayBuffer;\nimport js.html.Float32Array;\nimport js.html.Uint8ClampedArray;\nimport js.html.webgl.Buffer;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport wgr.display.Camera;\nimport wgr.display.Stage;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\nimport wgr.renderers.webgl.ShaderWrapper;\n\nclass PointSpriteLightMapRenderer implements IRenderer\n{\n\n    public var gl:RenderingContext;\n\n    public var projection:Point;\n\n    public var pointSpriteShader:ShaderWrapper;\n    \n    public var dataBuffer:Buffer;\n    private var arrayBuffer:ArrayBuffer;\n    public var data:Float32Array;\n    public var data8:Uint8ClampedArray;\n\n    public var stage:Stage;\n    public var camera:Camera;\n    public var texture:Texture;\n\n    public var indexRun:Int;\n\n    public function new() {\n    }\n\n    public function Init(gl:RenderingContext,camera:Camera) {\n        this.gl = gl;\n        this.camera = camera;\n        projection = new Point();\n        pointSpriteShader = new ShaderWrapper(gl, WebGLShaders.CompileProgram(gl,SPRITE_VERTEX_SHADER,SPRITE_FRAGMENT_SHADER));\n        dataBuffer =  gl.createBuffer();\n    }\n\n    public function ResizeBatch(size:Int) {\n        arrayBuffer = new ArrayBuffer(20*4*size);\n        data = new Float32Array(arrayBuffer);\n        data8 = new Uint8ClampedArray(arrayBuffer);\n        ResetBatch();\n    }\n\n    public function Resize(width:Int,height:Int) {\n        projection.x = width/2;\n        projection.y = height/2;\n    }\n\n    public function AddStage(stage:Stage) {\n        this.stage = stage;\n    }\n\n    public function ResetBatch() {\n        indexRun=0;\n    }\n\n    public function AddSpriteToBatch(x:Float,y:Float,size:Int,alpha:Int,red:Int,green:Int,blue:Int) {\n        var index = indexRun * 4;\n        data[index+0] = Std.int(x + camera.position.x);\n        data[index+1] = Std.int(y + camera.position.y);   \n        data[index+2] = size;\n        index *= 4;\n        data8[index+12] = red;\n        data8[index+13] = blue;\n        data8[index+14] = green;\n        data8[index+15] = alpha;\n        indexRun++;\n    }\n\n    public function Render(clip:AABB) {\n        gl.enable(RenderingContext.BLEND);\n        gl.blendFunc(RenderingContext.SRC_ALPHA, RenderingContext.ONE_MINUS_SRC_ALPHA);\n\n        gl.useProgram(pointSpriteShader.program);\n        gl.bindBuffer(RenderingContext.ARRAY_BUFFER,dataBuffer);\n        gl.bufferData(RenderingContext.ARRAY_BUFFER,data,RenderingContext.DYNAMIC_DRAW);    \n\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.position);\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.size);\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.colour);\n\n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.position, 2, RenderingContext.FLOAT, false, 16, 0);\n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.size, 1, RenderingContext.FLOAT, false, 16, 8);        \n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.colour, 4, RenderingContext.UNSIGNED_BYTE, true, 16, 12);\n\n        gl.uniform2f(untyped pointSpriteShader.uniform.projectionVector,projection.x,projection.y);\n\n        gl.drawArrays(RenderingContext.POINTS,0,indexRun);\n    }\n\n    public static var SPRITE_VERTEX_SHADER:Array<String> = [\n        \"precision mediump float;\",\n        \"uniform vec2 projectionVector;\",\n\n        \"attribute vec2 position;\",\n        \"attribute float size;\",\n        \"attribute vec4 colour;\",\n        \"varying vec4 vColor;\",\n        \"void main() {\",\n            \"gl_PointSize = size;\",\n            \"vColor = colour;\",\n            \"gl_Position = vec4( position.x / projectionVector.x -1.0, position.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",            \n        \"}\",\n    ];\n\n    public static var SPRITE_FRAGMENT_SHADER:Array<String> = [\n        \"precision mediump float;\",\n\n        \"varying vec4 vColor;\",\n        \"void main() {\",\n            \"gl_FragColor = vColor;\",\n        \"}\"\n    ];\n\n}   ","\npackage wgr.renderers.webgl;\n\nimport js.html.ArrayBuffer;\nimport js.html.Float32Array;\nimport js.html.Uint8ClampedArray;\nimport js.html.webgl.Buffer;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport wgr.display.Camera;\nimport wgr.display.Stage;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\nimport wgr.renderers.webgl.ShaderWrapper;\n\nclass PointSpriteRenderer implements IRenderer\n{\n\n    public var gl:RenderingContext;\n\n    public var projection:Point;\n\n    public var pointSpriteShader:ShaderWrapper;\n    \n    public var dataBuffer:Buffer;\n    private var arrayBuffer:ArrayBuffer;\n    public var data:Float32Array;\n    public var data8:Uint8ClampedArray;\n\n    public var stage:Stage;\n    public var camera:Camera;\n    public var texture:Texture;\n\n    public var tileSize:Float;\n    public var texTilesWide:Float;\n    public var texTilesHigh:Float;\n    public var invTexTilesWide:Float;\n    public var invTexTilesHigh:Float;\n\n    public var indexRun:Int;\n\n    public function new() {\n    }\n\n    public function Init(gl:RenderingContext,camera:Camera) {\n        this.gl = gl;\n        this.camera = camera;\n        projection = new Point();\n        pointSpriteShader = new ShaderWrapper(gl, WebGLShaders.CompileProgram(gl,SPRITE_VERTEX_SHADER,SPRITE_FRAGMENT_SHADER));\n        dataBuffer =  gl.createBuffer();\n    }\n\n    public function ResizeBatch(size:Int) {\n        arrayBuffer = new ArrayBuffer(20*4*size);\n        data = new Float32Array(arrayBuffer);\n        data8 = new Uint8ClampedArray(arrayBuffer);\n        ResetBatch();\n    }\n\n    public function SetSpriteSheet(texture:Texture,spriteSize:Int,spritesWide:Int,spritesHigh:Int) {\n        this.texture = texture;\n        tileSize = spriteSize;\n        texTilesWide = spritesWide;\n        texTilesHigh = spritesHigh;\n        invTexTilesWide = 1/texTilesWide;\n        invTexTilesHigh = 1/texTilesHigh;\n    }\n\n    public function Resize(width:Int,height:Int) {\n        projection.x = width/2;\n        projection.y = height/2;\n    }\n\n    public function AddStage(stage:Stage) {\n        this.stage = stage;\n    }\n\n    public function ResetBatch() {\n        indexRun=0;\n    }\n\n    public function AddSpriteToBatch(spriteID:Int,x:Float,y:Float,size:Float,alpha:Int,red:Int,green:Int,blue:Int) {\n        var index = indexRun * 5;\n        data[index+0] = Std.int(x + camera.position.x);\n        data[index+1] = Std.int(y + camera.position.y);\n        data[index+2] = size;\n        data[index+3] = spriteID;\n        index *= 4;\n        data8[index+16] = red;\n        data8[index+17] = blue;\n        data8[index+18] = green;\n        data8[index+19] = alpha;\n        indexRun++;\n    }\n\n    public function Render(clip:AABB) {\n        // js.Lib.debug();\n\n        gl.enable(RenderingContext.BLEND);\n        gl.blendFunc(RenderingContext.SRC_ALPHA, RenderingContext.ONE_MINUS_SRC_ALPHA);\n\n        gl.useProgram(pointSpriteShader.program);\n        gl.bindBuffer(RenderingContext.ARRAY_BUFFER,dataBuffer);\n        gl.bufferData(RenderingContext.ARRAY_BUFFER,data,RenderingContext.DYNAMIC_DRAW);    \n\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.position);\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.size);\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.tileType);\n        gl.enableVertexAttribArray(untyped pointSpriteShader.attribute.colour);\n\n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.position, 2, RenderingContext.FLOAT, false, 20, 0);\n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.size, 1, RenderingContext.FLOAT, false, 20, 8);\n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.tileType, 1, RenderingContext.FLOAT, false, 20, 12);\n        gl.vertexAttribPointer(untyped pointSpriteShader.attribute.colour, 4, RenderingContext.UNSIGNED_BYTE, true, 20, 16);\n\n        gl.uniform1f(untyped pointSpriteShader.uniform.texTilesWide, texTilesWide);\n        gl.uniform1f(untyped pointSpriteShader.uniform.texTilesHigh, texTilesHigh);\n        gl.uniform1f(untyped pointSpriteShader.uniform.invTexTilesWide, invTexTilesWide);\n        gl.uniform1f(untyped pointSpriteShader.uniform.invTexTilesHigh, invTexTilesHigh);\n        gl.uniform2f(untyped pointSpriteShader.uniform.projectionVector,projection.x,projection.y);            \n        gl.uniform2f(untyped pointSpriteShader.uniform.flip,0,0);            \n\n        gl.activeTexture(RenderingContext.TEXTURE0);\n        gl.bindTexture(RenderingContext.TEXTURE_2D,texture);\n        gl.drawArrays(RenderingContext.POINTS,0,indexRun);\n    }\n\n    public static var SPRITE_VERTEX_SHADER:Array<String> = [\n        \"precision mediump float;\",\n        \"uniform float texTilesWide;\",\n        \"uniform float texTilesHigh;\",\n        \"uniform float invTexTilesWide;\",\n        \"uniform float invTexTilesHigh;\",\n        \"uniform vec2 projectionVector;\",\n        \"uniform vec2 flip;\",\n\n        \"attribute vec2 position;\",\n        \"attribute float size;\",\n        \"attribute float tileType;\",\n        \"attribute vec4 colour;\",\n        \"varying vec2 vTilePos;\",\n        \"varying vec4 vColor;\",\n        \"void main() {\",\n            \"float t = floor(tileType/texTilesWide);\",\n            \"vTilePos = vec2(tileType-(t*texTilesWide), t);\",\n            \"gl_PointSize = size;\",\n            \"vColor = colour;\",\n            \"gl_Position = vec4( position.x / projectionVector.x -1.0, position.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",            \n        \"}\",\n    ];\n\n/*\nnormal:  -1 * 0-pc.y\nflip:     1 * 1-pc.y\n\n-1 + 2*0\n\nfx = 0\n    (-1+(2*fx)) * (fx-pc.x)\n    (-1+(2*0)) *  (0-pc.x)\n    -1 * (0-pc.x)\n\nfy = 1\n    (-1+(2*fx)) * (fx-pc.x)\n    (-1+(2*1)) * (1-pc.y)\n    1 * (1-pc.y)\n\n\n*/\n\n    public static var SPRITE_FRAGMENT_SHADER:Array<String> = [\n        \"precision mediump float;\",\n        \"uniform sampler2D texture;\",\n        \"uniform float invTexTilesWide;\",\n        \"uniform float invTexTilesHigh;\",\n        \"uniform vec2 flip;\",\n\n        \"varying vec2 vTilePos;\",\n        \"varying vec4 vColor;\",\n        \"void main() {\",\n            //\"vec2 uv = vec2( (-1.0*(0.0-gl_PointCoord.x))*invTexTilesWide + invTexTilesWide*vTilePos.x, (gl_PointCoord.y)*invTexTilesHigh + invTexTilesHigh*vTilePos.y);\",\n            \"vec2 uv = vec2( ((-1.0+(2.0*flip.x))*(flip.x-gl_PointCoord.x))*invTexTilesWide + invTexTilesWide*vTilePos.x, ((-1.0+(2.0*flip.y))*(flip.y-gl_PointCoord.y))*invTexTilesHigh + invTexTilesHigh*vTilePos.y);\",\n            \"gl_FragColor = texture2D( texture, uv ) * vColor;\",\n        \"}\"\n    ];\n\n}   ","\npackage wgr.renderers.webgl;\n\nimport js.html.webgl.Program;\nimport js.html.webgl.RenderingContext;\n\nclass ShaderWrapper \n{\n\n    public var program:Program;\n    public var attribute:Dynamic<String>;\n    public var uniform:Dynamic<String>;\n\n    public function new(gl:RenderingContext,program:Program) {\n        this.program = program;\n        gl.useProgram(this.program);\n        attribute = cast {};\n        uniform = cast {};\n        untyped { \n            var cnt = gl.getProgramParameter(program,RenderingContext.ACTIVE_ATTRIBUTES);\n            var i = 0;            \n            while (i<cnt){\n                var attrib = gl.getActiveAttrib(program,i);\n                attribute[attrib.name] = gl.getAttribLocation(program,attrib.name);\n                i++;\n            }\n\n            cnt = gl.getProgramParameter(program,RenderingContext.ACTIVE_UNIFORMS);\n            i=0;\n            while (i<cnt){\n                var attrib = gl.getActiveUniform(program,i);\n                uniform[attrib.name] = gl.getUniformLocation(program,attrib.name);\n                i++;\n            }\n        }\n    }\n\n}","\npackage wgr.renderers.webgl;\n\nimport js.html.webgl.RenderingContext;\nimport wgr.display.Camera;\nimport wgr.display.Stage;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\nimport wgr.renderers.webgl.IRenderer;\nimport wgr.renderers.webgl.ShaderWrapper;\n\nclass SpriteRenderer implements IRenderer\n{\n\n    public var gl:RenderingContext;\n    public var stage:Stage;\n    public var camera:Camera;\n\n    public var projection:Point;\n\n    public var spriteShader:ShaderWrapper;\n    \n    public var spriteBatch:WebGLBatch;        \n\n    public function new() {\n    }\n\n    public function Init(gl:RenderingContext,camera:Camera) {\n        this.gl = gl;\n        this.camera = camera;\n        projection = new Point();\n        spriteShader = new ShaderWrapper(gl, WebGLShaders.CompileProgram(gl,SPRITE_VERTEX_SHADER,SPRITE_FRAGMENT_SHADER));\n        spriteBatch = new WebGLBatch(gl);\n        spriteBatch.ResizeBatch(1000);\n    }\n\n    public function Resize(width:Int,height:Int) {\n        projection.x = width/2;\n        projection.y = height/2;\n    }\n\n    public function AddStage(stage:Stage) {\n        this.stage = stage;\n    }\n\n    public function Render(clip:AABB) {\n        gl.useProgram(spriteShader.program);\n        gl.enableVertexAttribArray(untyped spriteShader.attribute.aVertexPosition);\n        gl.enableVertexAttribArray(untyped spriteShader.attribute.aTextureCoord);\n        gl.enableVertexAttribArray(untyped spriteShader.attribute.aColor);\n        gl.vertexAttribPointer(untyped spriteShader.attribute.aVertexPosition,2,RenderingContext.FLOAT,false,20,0);\n        gl.vertexAttribPointer(untyped spriteShader.attribute.aTextureCoord,2,RenderingContext.FLOAT,false,20,8);\n        gl.vertexAttribPointer(untyped spriteShader.attribute.aColor,1,RenderingContext.FLOAT,false,20,16);         \n        gl.uniform2f(untyped spriteShader.uniform.projectionVector,projection.x,projection.y);            \n        spriteBatch.Render(spriteShader,stage,camera.viewPortAABB);\n    }\n\n    public static var SPRITE_VERTEX_SHADER:Array<String> = [\n        \"precision mediump float;\",\n        \"attribute vec2 aVertexPosition;\",\n        \"attribute vec2 aTextureCoord;\",\n        \"attribute float aColor;\",\n        \"uniform vec2 projectionVector;\",\n        \"varying vec2 vTextureCoord;\",\n        \"varying float vColor;\",\n        \"void main(void) {\",\n            \"gl_Position = vec4( aVertexPosition.x / projectionVector.x -1.0, aVertexPosition.y / -projectionVector.y + 1.0 , 0.0, 1.0);\",\n            \"vTextureCoord = aTextureCoord;\",\n            \"vColor = aColor;\",\n        \"}\"\n    ];\n\n    public static var SPRITE_FRAGMENT_SHADER:Array<String> = [\n        \"precision mediump float;\",\n        \"varying vec2 vTextureCoord;\",\n        \"varying float vColor;\",\n        \"uniform sampler2D uSampler;\",\n        \"void main(void) {\",\n            \"gl_FragColor = texture2D(uSampler,vTextureCoord) * vColor;\",\n        \"}\"\n    ];\n\n\n}","package wgr.renderers.webgl;\n\nimport ds.Array2D;\nimport js.html.Float32Array;\nimport js.html.Image;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport wgr.geom.Point;\n\nclass TileLayer\n{\n\n    public var scrollScale:Point;\n    public var tileTexture:Texture;\n    public var inverseTextureSize:Float32Array;\n\n    public function new()\n    {\n        scrollScale = new Point(1,1);\n        inverseTextureSize = new Float32Array(2);\n    }\n\n    public function setTextureFromMap(gl:RenderingContext,data:Array2D) {\n        if (tileTexture==null)\n            tileTexture = gl.createTexture();\n        gl.bindTexture(RenderingContext.TEXTURE_2D,tileTexture);\n        gl.texImage2D(RenderingContext.TEXTURE_2D, 0, RenderingContext.RGBA, data.w, data.h, 0, RenderingContext.RGBA, RenderingContext.UNSIGNED_BYTE, data.data8);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_MAG_FILTER,RenderingContext.NEAREST);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_MIN_FILTER,RenderingContext.NEAREST);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_S,RenderingContext.CLAMP_TO_EDGE);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_T,RenderingContext.CLAMP_TO_EDGE);   \n        inverseTextureSize[0] = 1/data.w;\n        inverseTextureSize[1] = 1/data.h;\n          \n    }\n\n    public function setTexture(gl:RenderingContext,image:Image,repeat:Bool) {\n        if (tileTexture==null)\n            tileTexture = gl.createTexture();\n        gl.bindTexture(RenderingContext.TEXTURE_2D,tileTexture);\n        gl.texImage2D(RenderingContext.TEXTURE_2D,0,RenderingContext.RGBA,RenderingContext.RGBA,RenderingContext.UNSIGNED_BYTE,image);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_MAG_FILTER,RenderingContext.NEAREST);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_MIN_FILTER,RenderingContext.NEAREST);\n        if (repeat) {\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_S,RenderingContext.REPEAT);\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_T,RenderingContext.REPEAT);\n        } else {\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_S,RenderingContext.CLAMP_TO_EDGE);\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_T,RenderingContext.CLAMP_TO_EDGE);            \n        }\n\n        inverseTextureSize[0] = 1/image.width;\n        inverseTextureSize[1] = 1/image.height;\n\n    }\n\n}","package wgr.renderers.webgl;\n\nimport ds.Array2D;\nimport js.html.Float32Array;\nimport js.html.Image;\nimport js.html.Uint32Array;\nimport js.html.Uint8Array;\nimport js.html.webgl.Buffer;\nimport js.html.webgl.Program;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport wgr.display.Camera;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\nimport wgr.renderers.webgl.IRenderer;\nimport wgr.renderers.webgl.ShaderWrapper;\nimport wgr.renderers.webgl.WebGLShaders;\nimport wgr.renderers.webgl.TileLayer;\n\nclass TileMap implements IRenderer\n{\n    public var gl:RenderingContext;\n    public var viewportSize:Point;\n    public var scaledViewportSize:Float32Array;\n    public var inverseTileTextureSize:Float32Array;\n    public var inverseSpriteTextureSize:Float32Array;\n\n    public var tileScale:Float;\n    public var tileSize:Int;\n    public var filtered:Bool;\n\n    public var spriteSheet:Texture;\n\n    public var quadVertBuffer:Buffer;\n\n    public var layers:Array<TileLayer>;\n\n    public var tilemapShader:ShaderWrapper;\n\n    public var camera:Camera;\n\n    public function new()\n    {\n    }\n\n    public function Init(gl:RenderingContext,camera:Camera) {\n        this.gl = gl;\n        this.camera = camera;\n        tileScale = 1.0;\n        tileSize = 16;\n        filtered = false;\n        spriteSheet = gl.createTexture();\n        layers = new Array<TileLayer>();\n\n        viewportSize = new Point();\n        scaledViewportSize = new Float32Array(2);\n        inverseTileTextureSize = new Float32Array(2);\n        inverseSpriteTextureSize = new Float32Array(2);\n\n        quadVertBuffer = gl.createBuffer();\n        gl.bindBuffer(RenderingContext.ARRAY_BUFFER, quadVertBuffer);\n\n        var quadVerts = new js.html.Float32Array(\n            [\n                -1, -1, 0, 1,\n                 1, -1, 1, 1,\n                 1,  1, 1, 0,\n\n                -1, -1, 0, 1,\n                 1,  1, 1, 0,\n                -1,  1, 0, 0\n            ]\n        );\n\n        gl.bufferData(RenderingContext.ARRAY_BUFFER, quadVerts, RenderingContext.STATIC_DRAW);\n        tilemapShader = new ShaderWrapper(gl, WebGLShaders.CompileProgram(gl,TILEMAP_VERTEX_SHADER,TILEMAP_FRAGMENT_SHADER));\n    }\n\n    public function Resize(width:Int,height:Int) {\n        viewportSize.x = width;\n        viewportSize.y = height;\n        scaledViewportSize[0] = width/tileScale;\n        scaledViewportSize[1] = height/tileScale;\n    }\n\n    public function TileScale(scale:Float) {\n        this.tileScale = scale;\n        scaledViewportSize[0] = viewportSize.x/scale;\n        scaledViewportSize[1] = viewportSize.y/scale;\n    }\n\n    public function Filtered(filtered:Bool) {\n        this.filtered = filtered;\n        gl.bindTexture(RenderingContext.TEXTURE_2D,spriteSheet);\n        if(filtered) {\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MAG_FILTER, RenderingContext.NEAREST);\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MIN_FILTER, RenderingContext.NEAREST);\n        } else {\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MAG_FILTER, RenderingContext.LINEAR);\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MIN_FILTER, RenderingContext.LINEAR); // Worth it to mipmap here?\n        }        \n    }\n\n    public function SetSpriteSheet(image:Image) {\n        gl.bindTexture(RenderingContext.TEXTURE_2D, spriteSheet);\n        gl.texImage2D(RenderingContext.TEXTURE_2D, 0, RenderingContext.RGBA, RenderingContext.RGBA, RenderingContext.UNSIGNED_BYTE, image);        \n        if(!filtered) {\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MAG_FILTER, RenderingContext.NEAREST);\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MIN_FILTER, RenderingContext.NEAREST);\n        } else {\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MAG_FILTER, RenderingContext.LINEAR);\n            gl.texParameteri(RenderingContext.TEXTURE_2D, RenderingContext.TEXTURE_MIN_FILTER, RenderingContext.LINEAR); // Worth it to mipmap here?\n        }  \n        inverseSpriteTextureSize[0] = 1/image.width;\n        inverseSpriteTextureSize[1] = 1/image.height;\n    }\n\n    public function SetTileLayer(image:Image,layerId:String,scrollScaleX:Float,scrollScaleY:Float) {\n        var layer = new TileLayer();\n        layer.setTexture(gl,image,false);\n        layer.scrollScale.x = scrollScaleX;\n        layer.scrollScale.y = scrollScaleY;\n        layers.push(layer);\n    }\n\n    public function SetTileLayerFromData(data:Array2D,layerId:String,scrollScaleX:Float,scrollScaleY:Float) {\n        var layer = new TileLayer();\n        layer.setTextureFromMap(gl,data);\n        layer.scrollScale.x = scrollScaleX;\n        layer.scrollScale.y = scrollScaleY;\n        layers.push(layer);\n    }\n\n    public function RoundFunction(v:Float):Float {\n        return v;\n        // return Math.round(v);\n        //return Std.int(v);\n        //return cast (0.5 + v) >> 0;\n        //v-=0.5;\n        return Math.round( v * 10) / 10;\n    }\n\n    public function Render(clip:AABB) {\n        var x = -camera.position.x / (tileScale*2);\n        var y = -camera.position.y / (tileScale*2);\n        //x += tileSize/2;\n        //y += tileSize/2;\n\n        gl.enable(RenderingContext.BLEND);\n        gl.blendFunc(RenderingContext.SRC_ALPHA, RenderingContext.ONE_MINUS_SRC_ALPHA);\n\n        gl.useProgram(tilemapShader.program);\n\n        gl.bindBuffer(RenderingContext.ARRAY_BUFFER, quadVertBuffer);\n\n        gl.enableVertexAttribArray(untyped tilemapShader.attribute.position);\n        gl.enableVertexAttribArray(untyped tilemapShader.attribute.texture);\n        gl.vertexAttribPointer(untyped tilemapShader.attribute.position, 2, RenderingContext.FLOAT, false, 16, 0);\n        gl.vertexAttribPointer(untyped tilemapShader.attribute.texture, 2, RenderingContext.FLOAT, false, 16, 8);\n\n        gl.uniform2fv(untyped tilemapShader.uniform.viewportSize, scaledViewportSize);\n        gl.uniform2fv(untyped tilemapShader.uniform.inverseSpriteTextureSize, inverseSpriteTextureSize);\n        gl.uniform1f(untyped tilemapShader.uniform.tileSize, tileSize);\n        gl.uniform1f(untyped tilemapShader.uniform.inverseTileSize, 1/tileSize);\n\n        gl.activeTexture(RenderingContext.TEXTURE0);\n        gl.uniform1i(untyped tilemapShader.uniform.sprites, 0);\n        gl.bindTexture(RenderingContext.TEXTURE_2D, spriteSheet);\n\n        gl.activeTexture(RenderingContext.TEXTURE1);\n        gl.uniform1i(untyped tilemapShader.uniform.tiles, 1);    \n\n        var i = layers.length; \n        while (i>0) {\n            i--; \n            var layer = layers[i];\n            var pX = RoundFunction(x * tileScale * layer.scrollScale.x);\n            var pY = RoundFunction(y * tileScale * layer.scrollScale.y);\n            gl.uniform2f(untyped tilemapShader.uniform.viewOffset, pX, pY);\n            gl.uniform2fv(untyped tilemapShader.uniform.inverseTileTextureSize, layer.inverseTextureSize);\n            gl.bindTexture(RenderingContext.TEXTURE_2D, layer.tileTexture);\n            gl.drawArrays(RenderingContext.TRIANGLES, 0, 6);\n        }\n    }\n    \n    public static var TILEMAP_VERTEX_SHADER:Array<String> = [\n        \"precision mediump float;\",\n        \"attribute vec2 position;\",\n        \"attribute vec2 texture;\",\n        \n        \"varying vec2 pixelCoord;\",\n        \"varying vec2 texCoord;\",\n\n        \"uniform vec2 viewOffset;\",\n        \"uniform vec2 viewportSize;\",\n        \"uniform vec2 inverseTileTextureSize;\",\n        \"uniform float inverseTileSize;\",\n\n        \"void main(void) {\",\n        \"   pixelCoord = (texture * viewportSize) + viewOffset;\",\n        \"   texCoord = pixelCoord * inverseTileTextureSize * inverseTileSize;\",\n        \"   gl_Position = vec4(position, 0.0, 1.0);\",\n        \"}\"\n    ];\n\n    public static var TILEMAP_FRAGMENT_SHADER:Array<String> = [\n       \"precision mediump float;\",\n\n        \"varying vec2 pixelCoord;\",\n        \"varying vec2 texCoord;\",\n\n        \"uniform sampler2D tiles;\",\n        \"uniform sampler2D sprites;\",\n\n        \"uniform vec2 inverseTileTextureSize;\",\n        \"uniform vec2 inverseSpriteTextureSize;\",\n        \"uniform float tileSize;\",\n\n        \"void main(void) {\",\n        \"   vec4 tile = texture2D(tiles, texCoord);\",\n        \"   if(tile.x == 1.0 && tile.y == 1.0) { discard; }\",\n        \"   vec2 spriteOffset = floor(tile.xy * 256.0) * tileSize;\",\n        \"   vec2 spriteCoord = mod(pixelCoord, tileSize);\",\n        \"   gl_FragColor = texture2D(sprites, (spriteOffset + spriteCoord) * inverseSpriteTextureSize);\",\n        \"}\"\n    ];\n\n}","\npackage wgr.renderers.webgl;\n\nimport js.html.Float32Array;\nimport js.html.Uint16Array;\nimport js.html.webgl.Buffer;\nimport js.html.webgl.Program;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport wgr.display.DisplayObject;\nimport wgr.display.DisplayObjectContainer;\nimport wgr.display.Sprite;\nimport wgr.display.Stage;\nimport wgr.geom.AABB;\nimport wgr.renderers.webgl.ShaderWrapper;\n\nclass WebGLBatch \n{\n    public var gl:RenderingContext;\n\n    public var size:Int;\n    public var dynamicSize:Int;\n\n    public var indexBuffer:Buffer;\n    public var indices:Uint16Array;\n\n    public var dataBuffer:Buffer;\n    public var data:Float32Array;\n\n    public var blendMode:Int;\n\n    public function new(gl:RenderingContext) {\n        this.gl = gl;\n        this.size = 1;\n        this.indexBuffer =  gl.createBuffer();\n        this.dataBuffer =  gl.createBuffer();\n        this.blendMode = 0;\n        this.dynamicSize = 1;\n    }\n\n    public function Clean() {\n    }\n\n    public function ResizeBatch(size:Int) {\n        this.size = size;\n        this.dynamicSize = size;\n        \n        data = new Float32Array(dynamicSize*20);\n        gl.bindBuffer(RenderingContext.ARRAY_BUFFER,dataBuffer);\n        gl.bufferData(RenderingContext.ARRAY_BUFFER,data,RenderingContext.DYNAMIC_DRAW);\n\n        indices = new Uint16Array(dynamicSize*6);\n\n        for (i in 0...dynamicSize) {\n            var index2 = i*6;\n            var index3 = i*4;\n            indices[index2+0] = index3 + 0;\n            indices[index2+1] = index3 + 1;\n            indices[index2+2] = index3 + 2;\n            indices[index2+3] = index3 + 0;\n            indices[index2+4] = index3 + 2;\n            indices[index2+5] = index3 + 3;\n        }\n\n        gl.bindBuffer(RenderingContext.ELEMENT_ARRAY_BUFFER,indexBuffer);\n        gl.bufferData(RenderingContext.ELEMENT_ARRAY_BUFFER,indices,RenderingContext.STATIC_DRAW);\n    }\n\n    public function Flush(shader:ShaderWrapper,texture:Texture,size:Int) {\n        gl.bindBuffer(RenderingContext.ARRAY_BUFFER,dataBuffer);\n        gl.bufferData(RenderingContext.ARRAY_BUFFER,data,RenderingContext.STATIC_DRAW);\n        gl.vertexAttribPointer(untyped shader.attribute.aVertexPosition,2,RenderingContext.FLOAT,false,20,0);\n        gl.vertexAttribPointer(untyped shader.attribute.aTextureCoord,2,RenderingContext.FLOAT,false,20,8);\n        gl.vertexAttribPointer(untyped shader.attribute.aColor,1,RenderingContext.FLOAT,false,20,16);        \n        gl.activeTexture(RenderingContext.TEXTURE0);\n        gl.bindTexture(RenderingContext.TEXTURE_2D,texture);\n        gl.drawElements(RenderingContext.TRIANGLES,size*6,RenderingContext.UNSIGNED_SHORT,0);        \n    }\n\n    public inline function AddSpriteToBatch(sprite:Sprite,indexRun:Int) {\n        var index = indexRun * 20;\n        var frame = sprite.texture.frame;\n        var tw = sprite.texture.baseTexture.width;\n        var th = sprite.texture.baseTexture.height;\n        var uvs = sprite.texture.uvs;\n\n\n        //0\n        //Verts\n        data[index + 0 ] = sprite.transformedVerts[0]; \n        data[index + 1 ] = sprite.transformedVerts[1];\n        //UV\n        data[index + 2 ] = uvs[0];//frame.x / tw;\n        data[index + 3 ] = uvs[1];//frame.y / th;\n        //Colour\n        data[index + 4 ] = sprite.worldAlpha;\n\n        //1\n        //Verts\n        data[index + 5 ] = sprite.transformedVerts[2]; \n        data[index + 6 ] = sprite.transformedVerts[3]; \n        //UV\n        data[index + 7 ] = uvs[2];//(frame.x + frame.width) / tw;\n        data[index + 8 ] = uvs[3];//frame.y / th;\n        //Colour\n        data[index + 9 ] = sprite.worldAlpha;\n\n        //2\n        //Verts\n        data[index + 10 ] = sprite.transformedVerts[4]; \n        data[index + 11 ] = sprite.transformedVerts[5]; \n        //UV\n        data[index + 12] = uvs[4];//(frame.x + frame.width) / tw;\n        data[index + 13] = uvs[5];//(frame.y + frame.height) / th; \n        //Colour\n        data[index + 14] = sprite.worldAlpha;\n\n        //3\n        //Verts\n        data[index + 15] =  sprite.transformedVerts[6]; \n        data[index + 16] =  sprite.transformedVerts[7];\n        //UV\n        data[index + 17] = uvs[6];//frame.x / tw;\n        data[index + 18] = uvs[7];//(frame.y + frame.height) / th;\n        //Colour\n        data[index + 19] = sprite.worldAlpha;\n    }\n\n\n    public function Render(shader:ShaderWrapper,stage:Stage,clip:AABB) {\n\n        gl.useProgram(shader.program);\n\n        var node:DisplayObjectContainer;\n        var stack:Array<DisplayObjectContainer>;\n        var top:Int;\n\n        node = stage;\n        stack = new Array<DisplayObjectContainer>();\n\n        stack[0] = node;\n        top = 1;\n\n        var indexRun = 0;\n        var currentTexture = null;\n\n        while (top>0) {\n            var thisNode = stack[--top];\n            //If there is an adjacent node, push it to the stack\n            if (thisNode.next!=null)\n                stack[top++] = cast thisNode.next; //Big assumption is only DisplayListContainers, which it is for now.\n            //If there is a child list, push the head (this will get processed first)\n            if (thisNode.head!=null)\n                stack[top++] = cast thisNode.head; //Same assumption.  \n            //return the result\n\n            if (thisNode.visible&&thisNode.renderable) {\n\n                var sprite:Sprite = cast thisNode;\n\n                if (sprite.texture.baseTexture.texture!=currentTexture || indexRun==size) {\n                    Flush(shader,currentTexture,indexRun);\n                    indexRun=0;\n                    currentTexture = sprite.texture.baseTexture.texture;\n                }\n                if (clip==null || sprite.aabb.intersect(clip)) {\n                    AddSpriteToBatch(sprite,indexRun);\n                    indexRun++;               \n                }\n            }\n        }\n        \n        if (indexRun>0)\n            Flush(shader,currentTexture,indexRun);\n    }\n\n    //TODO Render type Change\n    public function Render2(shader:ShaderWrapper,stage:Stage,clip:AABB) {\n\n        gl.useProgram(shader.program);\n        \n        var indexRun = 0;\n        var currentTexture = null;\n        \n        var renderDisplayObject = function(target:DisplayObject,p:Dynamic){\n            if (!target.visible) {\n                //trace(target.id+\" not visible\");\n                return false;\n            }\n            if (!target.renderable) {\n                return true;\n            }\n            //TODO fix, this assumes were only sprites now...\n            var sprite:Sprite = cast target;\n            if (sprite.texture.baseTexture.texture!=currentTexture || indexRun==size) {\n                Flush(shader,currentTexture,indexRun);\n                indexRun=0;\n                currentTexture = sprite.texture.baseTexture.texture;\n            }\n            if (clip==null || sprite.aabb.intersect(clip)) {\n                AddSpriteToBatch(sprite,indexRun);\n                indexRun++;               \n            }\n            return true;\n        }\n\n        stage.applySlot(renderDisplayObject);\n\n        if (indexRun>0)\n            Flush(shader,currentTexture,indexRun);\n\n    }\n\n    public function Render1(shader:ShaderWrapper,spriteHead:Sprite,clip:AABB) {\n        \n        if (spriteHead==null)\n            return;\n\n        gl.useProgram(shader.program);\n        //gl.bindBuffer(RenderingContext.ELEMENT_ARRAY_BUFFER,indexBuffer);\n\n        var indexRun = 0;\n        var sprite = spriteHead;\n        var currentTexture = sprite.texture.baseTexture.texture;\n        while (sprite!=null) {\n            if (sprite.texture.baseTexture.texture!=currentTexture || indexRun==size) {\n                Flush(shader,currentTexture,indexRun);\n                indexRun=0;\n                currentTexture = sprite.texture.baseTexture.texture;\n            }\n            if (clip==null || sprite.aabb.intersect(clip)) {\n                AddSpriteToBatch(sprite,indexRun);\n                indexRun++;               \n            }\n            sprite = sprite.nextSprite;\n        }\n        if (indexRun>0)\n            Flush(shader,currentTexture,indexRun);\n    }\n\n}","\npackage wgr.renderers.webgl;\n\nimport js.html.CanvasElement;\nimport js.html.Event;\nimport js.html.webgl.ContextAttributes;\nimport js.html.webgl.Program;\nimport js.html.webgl.RenderingContext;\nimport wgr.display.Camera;\nimport wgr.display.Stage;\nimport wgr.geom.Point;\nimport wgr.geom.AABB;\nimport wgr.renderers.webgl.IRenderer;\nimport wgr.renderers.webgl.ShaderWrapper;\nimport wgr.renderers.webgl.SpriteRenderer;\nimport wgr.renderers.webgl.WebGLBatch;\nimport wgr.renderers.webgl.WebGLShaders;\n\nclass WebGLRenderer \n{\n\n    public var stage:Stage;\n    public var camera:Camera;\n    public var view:CanvasElement;\n    public var width:Int;\n    public var height:Int;\n\n    public var gl:RenderingContext;\n    public var contextAttributes:ContextAttributes;\n\n    private var contextLost:Bool;\n\n    public var renderers:Array<IRenderer>;\n\n    public function new(stage:Stage,camera:Camera,view:CanvasElement,width:Int = 800,height:Int=600,transparent:Bool=false,antialias:Bool=false) {\n        this.stage = stage;\n        this.camera = camera;\n        this.view = view;\n        this.contextLost = false;\n\n        contextAttributes = {};\n        contextAttributes.alpha = transparent;\n        contextAttributes.antialias = antialias;\n        contextAttributes.premultipliedAlpha = false;\n        contextAttributes.stencil = false;\n\n        renderers = new Array<IRenderer>();\n\n        InitalizeWebGlContext();\n        Resize(width,height);\n    }\n\n    public function InitalizeWebGlContext() {\n        view.addEventListener('webglcontextlost',onContextLost,false);\n        view.addEventListener('webglcontextrestored',onContextRestored,false); \n        gl = view.getContextWebGL( contextAttributes );\n\n        gl.disable(RenderingContext.DEPTH_TEST);\n        gl.disable(RenderingContext.CULL_FACE);\n        gl.enable(RenderingContext.BLEND);\n        gl.colorMask(true,true,true,contextAttributes.alpha);\n        gl.clearColor(0,0,0,1);\n    }\n\n    public function Resize(width:Int,height:Int) {\n        this.width = width;\n        this.height = height;\n        view.width = width;\n        view.height = height;\n        gl.viewport(0,0,width,height);\n    }\n\n    public function AddRenderer(renderer:IRenderer) {\n        renderer.Init(gl,camera);\n        renderer.Resize(width,height);\n        renderers.push(renderer);\n    }\n\n    public function Render(clip:AABB) {\n        if (contextLost) \n            return;\n        stage.updateTransform();\n        stage.PreRender();\n        //gl.viewport(0,0,width,height);\n        // gl.colorMask(true,true,true,contextAttributes.alpha);\n        // gl.bindFramebuffer(RenderingContext.FRAMEBUFFER,null);\n        //gl.clear(RenderingContext.COLOR_BUFFER_BIT);\n        //gl.blendFunc(RenderingContext.ONE,RenderingContext.ONE_MINUS_SRC_ALPHA);\n        for (renderer in renderers)\n            renderer.Render(clip);\n    }\n\n    private function onContextLost(event:Event) {\n        contextLost = true;\n        trace(\"webGL Context Lost\");\n    }\n\n    private function onContextRestored(event:Event) {\n        contextLost = false;\n        trace(\"webGL Context Restored\");\n    }\n\n}","\npackage wgr.renderers.webgl;\n\nimport js.html.webgl.Program;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Shader;\n\nclass WebGLShaders \n{\n\n    public static function CompileVertexShader(gl:RenderingContext,shaderSrc:Array<String>):Shader {\n        return CompileShader(gl,shaderSrc,RenderingContext.VERTEX_SHADER);\n    }\n\n    public static function CompileFragmentShader(gl:RenderingContext,shaderSrc:Array<String>):Shader {\n        return CompileShader(gl,shaderSrc,RenderingContext.FRAGMENT_SHADER);\n    }\n\n    public static function CompileShader(gl:RenderingContext,shaderSrc:Array<String>,shaderType:Int):Shader {\n        var src = shaderSrc.join(\"\\n\");\n        var shader = gl.createShader(shaderType);\n        gl.shaderSource(shader,src);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader,RenderingContext.COMPILE_STATUS)) {\n            js.Lib.alert(gl.getShaderInfoLog(shader));\n            return null;\n        }\n        return shader;\n    }\n\n    public static function CompileProgram(gl:RenderingContext,vertexSrc:Array<String>,fragmentSrc:Array<String>):Program {\n        var vertexShader = CompileVertexShader(gl,vertexSrc);\n        var fragmentShader = CompileFragmentShader(gl,fragmentSrc);\n        var shaderProgram = gl.createProgram();\n\n        gl.attachShader(shaderProgram,vertexShader);\n        gl.attachShader(shaderProgram,fragmentShader);\n        gl.linkProgram(shaderProgram);\n\n        if (!gl.getProgramParameter(shaderProgram,RenderingContext.LINK_STATUS)) {\n            js.Lib.alert(\"Could not initialize program\");\n            trace(vertexSrc);\n            trace(fragmentSrc);\n            trace(gl.getProgramInfoLog(shaderProgram));\n        }\n        return shaderProgram;\n    }\n\n}","\npackage wgr.texture;\n\nimport haxe.ds.StringMap;\nimport js.html.Image;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport utils.EventTarget;\n\nclass BaseTexture\n{\n    public var width:Float;\n    public var height:Float;\n    public var source:Image;\n    public var resolution:Int;\n    public var powerOfTwo:Bool;\n\n    public var texture:Texture;\n\n    public function new(source:Image) {\n        this.source = source;\n        powerOfTwo = false;\n        resolution = 1;\n        width = source.width;\n        height = source.width;         \n    }\n\n    public function RegisterTexture(gl:RenderingContext) {\n        if (texture==null)\n            texture = gl.createTexture();\n        gl.bindTexture(RenderingContext.TEXTURE_2D,texture);\n        gl.pixelStorei(RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);\n        gl.texImage2D(RenderingContext.TEXTURE_2D,0,RenderingContext.RGBA,RenderingContext.RGBA,RenderingContext.UNSIGNED_BYTE,source);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_MAG_FILTER,RenderingContext.LINEAR);\n        gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_MIN_FILTER,RenderingContext.LINEAR);\n        if (powerOfTwo) {\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_S,RenderingContext.REPEAT);\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_T,RenderingContext.REPEAT);\n        } else {\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_S,RenderingContext.CLAMP_TO_EDGE);\n            gl.texParameteri(RenderingContext.TEXTURE_2D,RenderingContext.TEXTURE_WRAP_T,RenderingContext.CLAMP_TO_EDGE);\n        }\n        gl.bindTexture(RenderingContext.TEXTURE_2D,null);\n    }\n\n    public function UnregisterTexture(gl:RenderingContext) {\n        if (texture!=null) {\n            //texture\n        }\n    }\n\n}","\npackage wgr.texture;\n\nimport js.html.Float32Array;\nimport js.html.webgl.RenderingContext;\nimport js.html.webgl.Texture;\nimport wgr.geom.Point;\nimport wgr.geom.Rectangle;\nimport wgr.texture.BaseTexture;\n\nclass Texture \n{\n    public var baseTexture:BaseTexture;\n    public var frame:Rectangle;\n    public var trim:Point;\n    public var pivot:Point;\n    public var noFrame:Bool;\n    public var uvs:Float32Array;\n\n    public function new(baseTexture:BaseTexture,frame:Rectangle,pivot:Point = null) {\n        noFrame = false;\n        this.baseTexture = baseTexture;\n\n        if (frame==null) {\n            noFrame = true;\n            this.frame = new Rectangle(0,0,1,1);\n        } else {\n            this.frame = frame;\n        }\n        this.trim = new Point();\n        this.pivot = pivot==null ? new Point() : pivot;\n        this.uvs = new Float32Array(8);\n        updateUVS();\n    }\n\n    public function updateUVS() {\n\n        var tw = baseTexture.width;\n        var th = baseTexture.height;\n\n        uvs[0] = frame.x / tw;\n        uvs[1] = frame.y / th;\n\n        uvs[2] = (frame.x + frame.width) / tw;\n        uvs[3] = frame.y / th;\n\n        uvs[4] = (frame.x + frame.width) / tw;\n        uvs[5] = (frame.y + frame.height) / th;\n\n        uvs[6] = frame.x / tw;\n        uvs[7] = (frame.y + frame.height) / th;\n    }\n\n}","\npackage wgr.texture;\n\nimport haxe.ds.StringMap;\nimport haxe.xml.Fast;\nimport js.html.Image;\nimport js.html.webgl.RenderingContext;\nimport wgr.geom.Point;\nimport wgr.geom.Rectangle;\nimport wgr.texture.BaseTexture;\nimport utils.EventTarget;\nimport wgr.texture.Texture;\n\nclass TextureManager\n{\n\n    public var baseTextures:StringMap<BaseTexture>;\n    public var textures:StringMap<Texture>;\n    public var total:Int;\n    public var gl:RenderingContext;\n\n    public function new(gl:RenderingContext) {\n        this.gl = gl;\n        baseTextures = new StringMap<BaseTexture>();\n        textures = new StringMap<Texture>();\n    }\n\n    public function AddTexture(id:String,image:Image):BaseTexture {\n        var baseTexture = new BaseTexture(image);\n        baseTexture.RegisterTexture(gl);\n        baseTextures.set(id,baseTexture);\n        return baseTexture;\n    }\n\n    public function ParseTexturePackerJSON(textureConfig:Dynamic,id:String) {   \n        if (!Std.is(textureConfig, String)) \n            return;\n\n        var baseTexture = baseTextures.get(id);\n\n        var textureData = haxe.Json.parse(textureConfig);\n\n        var fields = Reflect.fields(textureData.frames);\n        for (prop in fields) {\n\n            var frame = Reflect.field(textureData.frames, prop);\n\n            textures.set(prop,\n                new Texture(baseTexture,\n                    new Rectangle(\n                        Std.parseInt(frame.frame.x),\n                        Std.parseInt(frame.frame.y), \n                        Std.parseInt(frame.frame.w), \n                        Std.parseInt(frame.frame.h)\n                    ),\n                    new Point(\n                        Std.parseFloat(frame.pivot.x),\n                        Std.parseFloat(frame.pivot.y)\n                    )\n                )\n            );\n        }\n\n    }\n\n    public function ParseTexturesFromTiles(tileSize:Int,id:String) {\n\n    }\n\n}","package worldEngine;\nimport worldEngine.WorldData;\nimport worldEngine.tiles.Tile;\nimport worldEngine.tiles.TileFeature;\nimport physics.dynamics.Body;\nimport physics.dynamics.Feature;\nimport physics.dynamics.Material;\nimport physics.geometry.AABB;\nimport physics.geometry.Ray;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass World\n{\n\t\n\tpublic var worldData:WorldData;\n\t\n\tpublic var worldBody:Body;\n\t\n\tpublic var fakeTileFeature : Feature;\n\n\tpublic function new(worldData:WorldData) \n\t{\n\t\tthis.worldData = worldData;\n\t\t\n\t\tworldBody = new Body();\n\t\tworldBody.MakeStatic();\n\t\t\n\t\t// fakeTileFeature = new Feature(worldBody, null, Material.DEFAULTMATERIAL);\n\t\t// fakeTileFeature.position = new Vector2D();\n\t\t\n\t}\n\n\t// public function VisibleArea(tileBoundary:Int):AABB {\n\t// \treturn new AABB(tileBoundary * worldData.tileSize, (worldData.height - tileBoundary) * worldData.tileSize, (worldData.width - tileBoundary) * worldData.tileSize, tileBoundary * worldData.tileSize);\n\t// }\n\n\t\n\n\tpublic function Collide(body:Body):Void {\n\n\t}\n\n\t// public function CastRay(ray : Ray) : Vector2D {\n\t// \t//Setup position vars\n\n\t// \tvar x:Int = Index(ray.origin.x);\n\t// \tvar y:Int = Index(ray.origin.y);\n\t// \t//var x : Int = Int(ray.origin.x / cellSize);\n\t// \t//var y : Int = Int(ray.origin.y / cellSize);\n\t// \tvar cpos_x:Int = x * cellSize;\n\t// \tvar cpos_y:Int = y * cellSize;\n\t\t\n\t// \tvar d : Vector2D = ray.direction;\n\n\t// \tvar p_x:Float = ray.origin.x;\n\t// \tvar p_y:Float = ray.origin.y;\n\t// \tvar op_x:Float = ray.origin.x;\n\t// \tvar op_y:Float = ray.origin.y;\n\n\t// \tvar flipFlop : Bool = true;\n\t// \tvar transitionEdge : Int = 0;\n\t// \tvar out : Vector2D;\n\n\t// \t//Initalize step vars\n\t// \tvar stepX : Int;\n\t// \tvar tMaxX : Float;\n\t// \tvar tDeltaX : Float;\n\t// \tif (d.x < 0) {\n\t// \t\tstepX = -1;\n\t// \t\ttMaxX = (cpos_x - ray.origin.x) / d.x;\n\t// \t\ttDeltaX = cellSize / -d.x;\n\t// \t} else if (0 < d.x) {\n\t// \t\tstepX = 1;\n\t// \t\ttMaxX = ((cpos_x + cellSize) - ray.origin.x) / d.x;\n\t// \t\ttDeltaX = cellSize / d.x;\n\t// \t} else {\n\t// \t\tstepX = 0;\n\t// \t\ttMaxX = 100000000;\n\t// \t\ttDeltaX = 0;\n\t// \t}\n\t// \tvar stepY : Int;\n\t// \tvar tMaxY : Float;\n\t// \tvar tDeltaY : Float;\n\t// \tif (d.y < 0) {\n\t// \t\tstepY = -1;\n\t// \t\ttMaxY = (cpos_y - ray.origin.y) / d.y;\n\t// \t\ttDeltaY = cellSize / -d.y;\n\t// \t} else if (0 < d.y) {\n\t// \t\tstepY = 1;\n\t// \t\ttMaxY = ((cpos_y + cellSize) - ray.origin.y) / d.y;\n\t// \t\ttDeltaY = cellSize / d.y;\n\t// \t} else {\n\t// \t\tstepY = 0;\n\t// \t\ttMaxY = 100000000;\n\t// \t\ttDeltaY = 0;\n\t// \t}\n\n\t// \t// Get current tile\n\t// \tvar tileFeature : TileFeature = GetGrid(x, y);\n\t// \t//Check it\n\t// \tif (tileFeature.HasFlagBool(TileFeature.COLLIDABLE)) {\n\t// \t\tfakeTileFeature.position.setTo(cpos_x, cpos_y);\n\t// \t\tif (tileFeature.tile.IntersectRay(ray, fakeTileFeature)) {\n\t// \t\t\tout = ray.ClosestIntersectPoint();\n\t// \t\t\t//if (g) {\n\t// \t\t\t\t//g.lineStyle(2, 0xFF0000);\n\t// \t\t\t\t//g.moveTo(p_x, p_y);\n\t// \t\t\t\t//g.lineTo(out.x, out.y);\n\t// \t\t\t\t//g.drawCircle(out.x, out.y, 4);\n\t// \t\t\t//}\n\t// \t\t\treturn out;\n\t// \t\t}\n\t// \t}\n\t\t\n\t// \t//Now loop over them\n\t// \twhile ( tileFeature!=null ) {\n\t// \t\t//if (g) {\n\t// \t\t\t//(flipFlop) ? g.lineStyle(2, 0x0000FF) : g.lineStyle(2, 0x00FF00) ;\n\t// \t\t\t//flipFlop = !flipFlop;\n\t// \t\t\t//g.drawRect(x * cellSize, y * cellSize, cellSize, cellSize);\n\t// \t\t//}\n\n\t// \t\tif (tMaxX < tMaxY) {\n\t// \t\t\ttransitionEdge = (stepX < 0) ? Tile.EDGE_RIGHT : Tile.EDGE_LEFT;\n\t// \t\t\tp_x = ray.origin.x + (tMaxX * d.x);\n\t// \t\t\tp_y = ray.origin.y + (tMaxX * d.y);\n\t// \t\t\ttMaxX = tMaxX + tDeltaX;\n\t// \t\t\tx = x + stepX;\n\t// \t\t\t//tileFeature = (stepX < 0) ? tileFeature.left : tileFeature.right;\n\t// \t\t} else {\n\t// \t\t\ttransitionEdge = (stepY < 0) ? Tile.EDGE_BOTTOM : Tile.EDGE_TOP;\n\t// \t\t\tp_x = ray.origin.x + (tMaxY * d.x);\n\t// \t\t\tp_y = ray.origin.y + (tMaxY * d.y);\n\t// \t\t\ttMaxY = tMaxY + tDeltaY;\n\t// \t\t\ty = y + stepY;\n\t// \t\t\t//tileFeature = (stepY < 0) ? tileFeature.up : tileFeature.down;\n\t// \t\t}\n\t// \t\ttileFeature = GetGrid(x, y);\n\t// \t\t// debug drawing\n\t// \t\t//if (g) {\n\t// \t\t\t//g.moveTo(op_x, op_y);\n\t// \t\t\t//g.lineTo(p_x, p_y);\n\t// \t\t//}\n\t\t\t\n\t// \t\tvar distX:Float = p_x - ray.origin.x;\n\t// \t\tvar distY:Float = p_y - ray.origin.y;\n\t// \t\tvar currentLen:Float = distX * distX + distY * distY;\n\t// \t\tif (currentLen > ray.rangeSqr) {\n\t// \t\t\t//trace(\"too long\");\n\t// \t\t\tray.ReportResult(null, Math.sqrt(currentLen));\n\t// \t\t\treturn null;\n\t// \t\t}\n\n\t// \t\tif (tileFeature!=null && tileFeature.HasFlagBool(TileFeature.COLLIDABLE)) {\n\t// \t\t\tif ( ( (transitionEdge == Tile.EDGE_TOP) && (tileFeature.tile.edgeT == 1) ) || ( (transitionEdge == Tile.EDGE_RIGHT) && (tileFeature.tile.edgeR == 1) ) || ( (transitionEdge == Tile.EDGE_BOTTOM) && (tileFeature.tile.edgeB == 1) ) || ( (transitionEdge == Tile.EDGE_LEFT) && (tileFeature.tile.edgeL == 1) ) ) {\n\t// \t\t\t\tout = new Vector2D(p_x,p_y);\n\t// \t\t\t\tray.ReportResult(fakeTileFeature, Math.sqrt(currentLen));\n\t// \t\t\t\t//if (g)\n\t// \t\t\t\t\t//g.drawCircle(out.x, out.y, 4);\n\t// \t\t\t\treturn out;\n\t// \t\t\t} else {\n\t// \t\t\t\tfakeTileFeature.position.setTo(x*cellSize, y*cellSize);\n\t// \t\t\t\tif (tileFeature.tile.IntersectRay(ray, fakeTileFeature)) {\n\t// \t\t\t\t\tout = ray.ClosestIntersectPoint();\n\t// \t\t\t\t\t//if (g) {\n\t// \t\t\t\t\t\t//g.moveTo(op_x, op_y);\n\t// \t\t\t\t\t\t//g.lineTo(out.x, out.y);\n\t// \t\t\t\t\t\t//g.drawCircle(out.x, out.y, 4);\n\t// \t\t\t\t\t//}\n\t// \t\t\t\t\treturn out;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\top_x = p_x;\n\t// \t\top_y = p_y;\n\t// \t}\n\t// \treturn null;\n\t// }\n\t\n}","package worldEngine;\nimport ds.Array2D;\nimport engine.graphics.IGameGraphics;\nimport engine.map.tmx.TmxMap;\nimport worldEngine.tiles.TileFactory;\n\n/**\n * ...\n * @author rje\n */\n\nclass WorldData \n{\n\n\t// public var width : Int;\n\t// public var height : Int;\n\tpublic var tileSize : Int;\n\tpublic var invTileSize : Float;\n\tpublic var worldCellSize : Int;\n\t\n\tpublic var tmxMap:TmxMap;\n\tpublic var tileFactory:TileFactory;\n\tpublic var collisionData:Array2D;\n\n\tpublic var staticGraphics:Array<IGameGraphics>;\n\n\tpublic var worldBounds:physics.geometry.AABB;\n\t\t\n\tpublic function new(tileSize:Int,tmxMap:TmxMap,collisionLayerName:String) \n\t{\n\t\tthis.tileSize = tileSize;\n\t\tthis.invTileSize = 1/tileSize;\n\t\tthis.tmxMap = tmxMap;\n\t\ttileFactory = new TileFactory();\n\t\tcollisionData = engine.map.tmx.TmxLayer.layerToCollisionMap(tmxMap.getLayer(collisionLayerName));\n\t\t\n\t\tworldBounds = new physics.geometry.AABB(0,collisionData.h*tileSize,collisionData.w*tileSize,0);\n\t\tworldCellSize = cast worldBounds.width();\n\t}\n\t\n\tpublic function InitalizeWorld():Void {\n\t\tProcessTiles();\n\t\tProcessObjects();\n\t\tProcessWayPoints();\n\t}\n\n\t\n\tinline public function Index(value:Float):Int {\n\t\t//FIXME Not sure this always works...\n\t\t//return Std.int(value / cellSize);\n\t\t//return Math.floor(value * invTileSize);\n\t\treturn Std.int(value * invTileSize);\n\t}\n\n\tpublic function ProcessTiles():Void {\n\t\t// for (y in 0...height) {\n\t\t// \tfor (x in 0...width) {\n\t\t\t\t//var centre = world.GetGridSafe(x, y);\n\t\t\t\t//centre.SetEdgeData(world.GetGridSafe(x-1, y), world.GetGridSafe(x, y-1), world.GetGridSafe(x+1, y), world.GetGridSafe(x, y+1));\n\t\t// \t}\n\t\t// }\n\t}\n\n\tpublic function ProcessObjects():Void {\n\t\t\n\t}\n\t\n\tpublic function ProcessWayPoints():Void {\n\t\t\n\t}\n\n}","package worldEngine;\n\nimport ds.Array2D;\nimport physics.collision.broadphase.managedgrid.ManagedGrid;\nimport physics.collision.narrowphase.INarrowphase;\nimport physics.dynamics.Body;\nimport physics.dynamics.Feature;\nimport physics.dynamics.Material;\nimport physics.geometry.Ray;\nimport physics.geometry.Vector2D;\nimport worldEngine.tiles.Tile;\nimport worldEngine.World;\n/**\n * ...\n * @author rje\n */\n\nclass WorldPhysicsEngine extends ManagedGrid\n{\n\n\tpublic var worldData:WorldData;\n\n\tpublic var tempFeature:Feature;\n\t\n\tpublic var collisionData:Array2D;\n\n\tpublic var collisionOrderX:Array<Int>;\n\tpublic var collisionOrderY:Array<Int>;\n\n\tpublic var worldBody:Body;\n\n\tpublic function new(fps : Int, pps : Int, narrowphase:INarrowphase, worldData:WorldData) \n\t{\n\t\tworldBody = new Body();\n\t\tworldBody.MakeStatic();\n\t\t\n\t\tthis.worldData = worldData;\n\n\t\tsuper(fps,pps,narrowphase,Math.ceil(worldData.worldBounds.width()/worldData.worldCellSize), Math.ceil(worldData.worldBounds.height()/worldData.worldCellSize), worldData.worldCellSize);\n\n\t\ttempFeature = new Feature(worldBody, null, new Material());\n\t\ttempFeature.position = new Vector2D();\n\n\t\tcollisionData = worldData.collisionData;\n\n\t\tcollisionOrderX = [0,-1,1];\n\t\tcollisionOrderY = [2,1,0,-1,-2];\n\t}\n\t\n   \toverride public function Collide() {\n   \t\tsuper.Collide();\n        for (cell in grid.data) {        \n            for (i in 0...cell.dynamicItems.length) {\n           \t\tvar body = cell.dynamicItems[i];\n\t\t\t\tfor (bodyFeature in body.features) {\n\t\t\t\t\t\n\t\t\t\t\t// var cx = world.worldData.Index(body.position.x);\n\t\t\t\t\t// var cy = world.worldData.Index(body.position.y);\n\t\t\t\t\t// js.Lib.debug();\n\t\t\t\t\tvar cx = worldData.Index( ((bodyFeature.shape.aabb.r+bodyFeature.shape.aabb.l)/2) + body.position.x);\n\t\t\t\t\tvar cy = worldData.Index( ((bodyFeature.shape.aabb.b+bodyFeature.shape.aabb.t)/2) + body.position.y);\n\n\t\t\t\t\tfor ( y in collisionOrderY ) {\n\t\t\t\t\t\tfor( x in collisionOrderX ) {\t\n\t\t\t\t\t\t\t// trace(cx+x,cy+y);\n\t\t\t\t\t\t\tvar tileID = collisionData.get(cx+x,cy+y);\n\t\t\t\t\t\t\tif (tileID>0) {\n\t\t\t\t\t\t\t\ttempFeature.shape = worldData.tileFactory.tiles[tileID];\n\t\t\t\t\t\t\t\ttempFeature.position.setTo((cx+x)*worldData.tileSize,(cy+y)*worldData.tileSize);\n\t\t\t\t\t\t\t\tnarrowphase.CollideFeatures(tempFeature, bodyFeature);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// tileFeature = world.GetGridSafe(x, y);\n\t\t\t\t\t\t\t// if (tileFeature.HasFlagBool(TileFeature.COLLIDABLE)) {\n\t\t\t\t\t\t\t// \ttempFeature.shape = tileFeature.tile;\n\t\t\t\t\t\t\t// \ttempFeature.position.setTo(x*world.worldData.tileSize,y*world.worldData.tileSize);\n\t\t\t\t\t\t\t// \tmanager.narrowphase.CollideFeatures(tempFeature, bodyFeature);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}  \n            }\n        }\n        // js.Lib.debug();\n    }\n\n    override public function CastRay(ray : Ray) : Vector2D {\n\t\t//Setup position vars\n\n\t\tvar x:Int = worldData.Index(ray.origin.x);\n\t\tvar y:Int = worldData.Index(ray.origin.y);\n\t\t//var x : Int = Int(ray.origin.x / worldData.tileSize);\n\t\t//var y : Int = Int(ray.origin.y / worldData.tileSize);\n\t\tvar cpos_x:Int = x * worldData.tileSize;\n\t\tvar cpos_y:Int = y * worldData.tileSize;\n\t\t\n\t\tvar d : Vector2D = ray.direction;\n\n\t\tvar p_x:Float = ray.origin.x;\n\t\tvar p_y:Float = ray.origin.y;\n\t\tvar op_x:Float = ray.origin.x;\n\t\tvar op_y:Float = ray.origin.y;\n\n\t\tvar flipFlop : Bool = true;\n\t\tvar transitionEdge : Int = 0;\n\t\tvar out : Vector2D;\n\n\t\t//Initalize step vars\n\t\tvar stepX : Int;\n\t\tvar tMaxX : Float;\n\t\tvar tDeltaX : Float;\n\t\tif (d.x < 0) {\n\t\t\tstepX = -1;\n\t\t\ttMaxX = (cpos_x - ray.origin.x) / d.x;\n\t\t\ttDeltaX = worldData.tileSize / -d.x;\n\t\t} else if (0 < d.x) {\n\t\t\tstepX = 1;\n\t\t\ttMaxX = ((cpos_x + worldData.tileSize) - ray.origin.x) / d.x;\n\t\t\ttDeltaX = worldData.tileSize / d.x;\n\t\t} else {\n\t\t\tstepX = 0;\n\t\t\ttMaxX = 100000000;\n\t\t\ttDeltaX = 0;\n\t\t}\n\t\tvar stepY : Int;\n\t\tvar tMaxY : Float;\n\t\tvar tDeltaY : Float;\n\t\tif (d.y < 0) {\n\t\t\tstepY = -1;\n\t\t\ttMaxY = (cpos_y - ray.origin.y) / d.y;\n\t\t\ttDeltaY = worldData.tileSize / -d.y;\n\t\t} else if (0 < d.y) {\n\t\t\tstepY = 1;\n\t\t\ttMaxY = ((cpos_y + worldData.tileSize) - ray.origin.y) / d.y;\n\t\t\ttDeltaY = worldData.tileSize / d.y;\n\t\t} else {\n\t\t\tstepY = 0;\n\t\t\ttMaxY = 100000000;\n\t\t\ttDeltaY = 0;\n\t\t}\n\n\t\t// Get current tile\n\t\t//var tileFeature : TileFeature = GetGrid(x, y);\n\t\tvar tileID = collisionData.get(x,y);\n\t\tvar tile:Tile;\n\t\t//Check it\n\t\tif (tileID>0) {\n\t\t\ttile = worldData.tileFactory.tiles[tileID];\n\t\t\ttempFeature.shape = worldData.tileFactory.tiles[tileID];\n\t\t\ttempFeature.position.setTo(cpos_x, cpos_y);\n\t\t\t//fakeTileFeature.position.setTo(cpos_x, cpos_y);\n\n\t\t\tif (tempFeature.shape.IntersectRay(ray, tempFeature)) {\n\n\t\t\t\tout = ray.ClosestIntersectPoint();\n\t\t\t\t//if (g) {\n\t\t\t\t\t//g.lineStyle(2, 0xFF0000);\n\t\t\t\t\t//g.moveTo(p_x, p_y);\n\t\t\t\t\t//g.lineTo(out.x, out.y);\n\t\t\t\t\t//g.drawCircle(out.x, out.y, 4);\n\t\t\t\t//}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Now loop over them\n\t\twhile ( true ) {\n\t\t\t//if (g) {\n\t\t\t\t//(flipFlop) ? g.lineStyle(2, 0x0000FF) : g.lineStyle(2, 0x00FF00) ;\n\t\t\t\t//flipFlop = !flipFlop;\n\t\t\t\t//g.drawRect(x * worldData.tileSize, y * worldData.tileSize, worldData.tileSize, worldData.tileSize);\n\t\t\t//}\n\n\t\t\tif (tMaxX < tMaxY) {\n\t\t\t\ttransitionEdge = (stepX < 0) ? Tile.EDGE_RIGHT : Tile.EDGE_LEFT;\n\t\t\t\tp_x = ray.origin.x + (tMaxX * d.x);\n\t\t\t\tp_y = ray.origin.y + (tMaxX * d.y);\n\t\t\t\ttMaxX = tMaxX + tDeltaX;\n\t\t\t\tx = x + stepX;\n\t\t\t\t//tileFeature = (stepX < 0) ? tileFeature.left : tileFeature.right;\n\t\t\t} else {\n\t\t\t\ttransitionEdge = (stepY < 0) ? Tile.EDGE_BOTTOM : Tile.EDGE_TOP;\n\t\t\t\tp_x = ray.origin.x + (tMaxY * d.x);\n\t\t\t\tp_y = ray.origin.y + (tMaxY * d.y);\n\t\t\t\ttMaxY = tMaxY + tDeltaY;\n\t\t\t\ty = y + stepY;\n\t\t\t\t//tileFeature = (stepY < 0) ? tileFeature.up : tileFeature.down;\n\t\t\t}\n\t\t\ttileID = collisionData.get(x,y);\n\t\t\t// debug drawing\n\t\t\t//if (g) {\n\t\t\t\t//g.moveTo(op_x, op_y);\n\t\t\t\t//g.lineTo(p_x, p_y);\n\t\t\t//}\n\t\t\t\n\t\t\tvar distX:Float = p_x - ray.origin.x;\n\t\t\tvar distY:Float = p_y - ray.origin.y;\n\t\t\tvar currentLen:Float = distX * distX + distY * distY;\n\t\t\tif (currentLen > ray.rangeSqr) {\n\t\t\t\t//trace(\"too long\");\n\t\t\t\tray.ReportResult(null, Math.sqrt(currentLen));\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (tileID>0) {\n\t\t\t\ttile = worldData.tileFactory.tiles[tileID];\n\t\t\t\ttempFeature.shape = tile;\n\n\t\t\t\tif ( ( (transitionEdge == Tile.EDGE_TOP) && (tile.edgeT == 1) ) || ( (transitionEdge == Tile.EDGE_RIGHT) && (tile.edgeR == 1) ) || ( (transitionEdge == Tile.EDGE_BOTTOM) && (tile.edgeB == 1) ) || ( (transitionEdge == Tile.EDGE_LEFT) && (tile.edgeL == 1) ) ) {\n\t\t\t\t\tout = new Vector2D(p_x,p_y);\n\t\t\t\t\tray.ReportResult(tempFeature, Math.sqrt(currentLen));\n\t\t\t\t\t//if (g)\n\t\t\t\t\t\t//g.drawCircle(out.x, out.y, 4);\n\t\t\t\t\treturn out;\n\t\t\t\t} else {\n\t\t\t\t\ttempFeature.position.setTo(x*worldData.tileSize, y*worldData.tileSize);\n\t\t\t\t\tif (tempFeature.shape.IntersectRay(ray, tempFeature)) {\n\t\t\t\t\t\tout = ray.ClosestIntersectPoint();\n\t\t\t\t\t\t//if (g) {\n\t\t\t\t\t\t\t//g.moveTo(op_x, op_y);\n\t\t\t\t\t\t\t//g.lineTo(out.x, out.y);\n\t\t\t\t\t\t\t//g.drawCircle(out.x, out.y, 4);\n\t\t\t\t\t\t//}\n\t\t\t\t\t\treturn out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\top_x = p_x;\n\t\t\top_y = p_y;\n\t\t}\n\t\treturn null;\n\t}\n\t\n}","package worldEngine.tiles;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass TileSegment \n{\n\n\tpublic var v0 : Vector2D;\n\tpublic var v1 : Vector2D;\n\tpublic var mask : Int;\n\n\tpublic function new(v0 : Vector2D, v1 : Vector2D, mask : Int) {\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.mask = mask;\n\t}\n\n\tpublic function CheckVertexPairAndApplyMask(c0 : Vector2D, c1 : Vector2D) : Int {\n\t\tif ( ( v0.isEquals(c0) && v1.isEquals(c1) ) || ( v0.isEquals(c1) && v1.isEquals(c0) ) ) {\n\t\t\treturn mask;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n}","package worldEngine.tiles;\n\nimport physics.geometry.Axis;\nimport physics.geometry.Polygon;\nimport physics.geometry.Vector2D;\n\n/**\n * ...\n * @author rje\n */\n\nclass Tile extends Polygon\n{\n\tinline public static var ZERO:Float \t= 0;\n\tinline public static var HALF:Float \t= 0.5;\n\tinline public static var ONE:Float \t\t= 1;\n\t\n\tpublic static var TOP_LEFT_0:Vector2D \t\t= new Vector2D(ZERO,ZERO);\n\tpublic static var MIDDLE_LEFT_1:Vector2D \t= new Vector2D(ZERO,HALF);\n\tpublic static var BOTTOM_LEFT_2:Vector2D \t= new Vector2D(ZERO,ONE);\n\tpublic static var BOTTOM_MIDDLE_3:Vector2D \t= new Vector2D(HALF,ONE);\n\tpublic static var BOTTOM_RIGHT_4:Vector2D \t= new Vector2D(ONE,ONE);\n\tpublic static var MIDDLE_RIGHT_5:Vector2D\t= new Vector2D(ONE,HALF);\n\tpublic static var TOP_RIGHT_6:Vector2D \t\t= new Vector2D(ONE,ZERO);\n\tpublic static var TOP_MIDDLE_7:Vector2D \t= new Vector2D(HALF,ZERO);\n\tpublic static var MIDDLE_MIDDLE_8:Vector2D \t= new Vector2D(HALF,HALF);\n\t\n\tpublic static var VERTS:Array<Vector2D> = [\n\t\tTOP_LEFT_0,\n\t\tMIDDLE_LEFT_1,\n\t\tBOTTOM_LEFT_2,\n\t\tBOTTOM_MIDDLE_3,\n\t\tBOTTOM_RIGHT_4,\n\t\tMIDDLE_RIGHT_5,\n\t\tTOP_RIGHT_6,\n\t\tTOP_MIDDLE_7,\n\t\tMIDDLE_MIDDLE_8\n\t];\n\t\t\n\tinline public static var EDGE_STATE_OFF:Int\t\t\t\t= 0;\n\tinline public static var EDGE_STATE_FULL:Int\t\t\t= 1;\n\tinline public static var EDGE_STATE_INTERESTING:Int\t\t= 4;\n\t\n\tinline public static var EDGE_TOP:Int\t\t= 0;\n\tinline public static var EDGE_RIGHT:Int\t\t= 1;\n\tinline public static var EDGE_BOTTOM:Int\t= 2;\n\tinline public static var EDGE_LEFT:Int\t\t= 3;\n\t\n\tpublic var tileID : Int;\n\tpublic var index : Int;\n\tpublic var originalVertMask:Array<Int>;\n\tpublic var unscaledVerts:Array<Vector2D>;\n\tpublic var scaledVerts:Array<Vector2D>;\n\tpublic var segments:Array<Vector2D>;\n\t\n\tpublic var edgeT:Int;\n\tpublic var edgeR:Int;\n\tpublic var edgeB:Int;\n\tpublic var edgeL:Int;\n\t\n\tpublic var tileWidth : Float;\n\t\n\t//Ouside edges\n\t//Left\n\tpublic static var  SEG_1:Int =  0x01;\n\tpublic static var  SEG_2:Int =  0x02;\n\t//Bottom\n\tpublic static var  SEG_3:Int =  0x04;\n\tpublic static var  SEG_4:Int =  0x08;\n\t//Right\n\tpublic static var  SEG_5:Int =  0x10;\n\tpublic static var  SEG_6:Int =  0x20;\n\t//Top\n\tpublic static var  SEG_7:Int =  0x40;\n\tpublic static var  SEG_8:Int =  0x80;\n\t\n\t\n\t//Inside vertical and horizontal\n\t//Top Middle |\n\tpublic static var  SEG_9:Int = 0x100;\n\t//Middle Left - \n\tpublic static var SEG_10:Int = 0x200;\n\t//Middle Right - \n\tpublic static var SEG_11:Int = 0x400;\n\t//Bottom Middle | \n\tpublic static var SEG_12:Int = 0x800;\n\t\n\t//Inside slopes 45\n\t//Top Left 45 /\n\tpublic static var SEG_13:Int = 0x1000;\n\t//Bottom Left 45 / \n\tpublic static var SEG_14:Int = 0x2000;\n\t//Top Right 45 / \n\tpublic static var SEG_15:Int = 0x4000;\n\t//Bottom Right 45 / \n\tpublic static var SEG_16:Int = 0x8000;\n\t\n\t//Top Left 45 \n\tpublic static var SEG_17:Int = 0x10000;\n\t//Bottom Left 45\n\tpublic static var SEG_18:Int = 0x20000;\n\t//Top Right 45\n\tpublic static var SEG_19:Int = 0x40000;\n\t//Bottom Right 45\n\tpublic static var SEG_20:Int = 0x80000;\n\t\n\t//Inside slopes 66\n\t//Left /\n\tpublic static var SEG_21:Int = 0x100000;\n\t//Right /\n\tpublic static var SEG_22:Int = 0x200000;\n\t//Left \\\n\tpublic static var SEG_23:Int = 0x400000;\n\t//Right \\ \n\tpublic static var SEG_24:Int = 0x800000;\n\t\n\t//Inside slopes 22\n\t//Top /\n\tpublic static var SEG_25:Int = 0x1000000;\n\t//Bottom /\n\tpublic static var SEG_26:Int = 0x2000000;\n\t//Top \\\n\tpublic static var SEG_27:Int = 0x4000000;\n\t//Bottom \\\n\tpublic static var SEG_28:Int = 0x8000000;\n\t\n\tpublic static var SEG_UP:Int = 0;//0x10000000;\n\t\n\tpublic static var EDGE_SEGMENT_MASK:Int = 0xFF;\n\t\n\tpublic static var VERT_TO_SEG_DEF:Array<TileSegment> = [\n\t\n\t\t//Left\n\t\tnew TileSegment(TOP_LEFT_0,MIDDLE_LEFT_1,SEG_1),\n\t\tnew TileSegment(TOP_LEFT_0,BOTTOM_LEFT_2,SEG_1|SEG_2),\n\t\tnew TileSegment(MIDDLE_LEFT_1,BOTTOM_LEFT_2,SEG_2),\n\t\n\t\t//Bottom\n\t\tnew TileSegment(BOTTOM_LEFT_2,BOTTOM_MIDDLE_3,SEG_3),\n\t\tnew TileSegment(BOTTOM_LEFT_2,BOTTOM_RIGHT_4,SEG_3|SEG_4),\n\t\tnew TileSegment(BOTTOM_MIDDLE_3,BOTTOM_RIGHT_4,SEG_4),\n\t\t\n\t\t//Right\n\t\tnew TileSegment(BOTTOM_RIGHT_4,MIDDLE_RIGHT_5,SEG_5),\n\t\tnew TileSegment(BOTTOM_RIGHT_4,TOP_RIGHT_6,SEG_5|SEG_6),\n\t\tnew TileSegment(MIDDLE_RIGHT_5,TOP_RIGHT_6,SEG_6),\n\t\t\n\t\t//Top\n\t\tnew TileSegment(TOP_RIGHT_6,TOP_MIDDLE_7,SEG_7),\n\t\tnew TileSegment(TOP_RIGHT_6,TOP_LEFT_0,SEG_7|SEG_8),\n\t\tnew TileSegment(TOP_MIDDLE_7,TOP_LEFT_0,SEG_8),\n\t\t\n\t\t//Inside Vert\n\t\tnew TileSegment(TOP_MIDDLE_7,MIDDLE_MIDDLE_8,SEG_9),\n\t\tnew TileSegment(TOP_MIDDLE_7,BOTTOM_MIDDLE_3,SEG_9|SEG_12),\n\t\tnew TileSegment(MIDDLE_MIDDLE_8,BOTTOM_MIDDLE_3,SEG_12),\t\t\t\n\n\t\t//Inside Horiz\n\t\tnew TileSegment(MIDDLE_LEFT_1,MIDDLE_MIDDLE_8,SEG_10),\n\t\tnew TileSegment(MIDDLE_LEFT_1,MIDDLE_RIGHT_5,SEG_10|SEG_11),\n\t\tnew TileSegment(MIDDLE_MIDDLE_8,MIDDLE_RIGHT_5,SEG_11),\t\n\t\t\n\t\t\n\t\t//Inside slopes 45 /\n\t\tnew TileSegment(MIDDLE_LEFT_1,TOP_MIDDLE_7,SEG_13),\n\t\t\n\t\tnew TileSegment(BOTTOM_LEFT_2,MIDDLE_MIDDLE_8,SEG_14),\n\t\tnew TileSegment(BOTTOM_LEFT_2,TOP_RIGHT_6,SEG_14|SEG_15),\t\n\t\tnew TileSegment(MIDDLE_MIDDLE_8,TOP_RIGHT_6,SEG_15),\t\n\n\t\tnew TileSegment(BOTTOM_MIDDLE_3,MIDDLE_RIGHT_5,SEG_16),\n\t\t\n\t\t\n\t\t//Inside slopes 45 \\\n\t\tnew TileSegment(MIDDLE_LEFT_1,BOTTOM_MIDDLE_3,SEG_18),\n\t\t\n\t\tnew TileSegment(TOP_LEFT_0,MIDDLE_MIDDLE_8,SEG_17),\n\t\tnew TileSegment(TOP_LEFT_0,BOTTOM_RIGHT_4,SEG_17|SEG_20),\t\n\t\tnew TileSegment(MIDDLE_MIDDLE_8,BOTTOM_RIGHT_4,SEG_20),\t\n\n\t\tnew TileSegment(MIDDLE_RIGHT_5,TOP_MIDDLE_7,SEG_19),\n\t\t\n\n\t\t//Inside slopes 66\n\t\tnew TileSegment(BOTTOM_LEFT_2,TOP_MIDDLE_7,SEG_21),\n\t\tnew TileSegment(BOTTOM_MIDDLE_3,TOP_RIGHT_6,SEG_22),\n\t\tnew TileSegment(BOTTOM_MIDDLE_3,TOP_LEFT_0,SEG_23),\t\n\t\tnew TileSegment(BOTTOM_RIGHT_4,TOP_MIDDLE_7,SEG_24),\n\t\t\n\t\t//Inside slopes 22\n\t\tnew TileSegment(MIDDLE_LEFT_1,TOP_RIGHT_6,SEG_25),\n\t\tnew TileSegment(BOTTOM_LEFT_2,MIDDLE_RIGHT_5,SEG_26),\n\t\tnew TileSegment(MIDDLE_RIGHT_5,TOP_LEFT_0,SEG_27),\t\n\t\tnew TileSegment(BOTTOM_RIGHT_4,MIDDLE_LEFT_1,SEG_28)\n\t\t\n\t];\n\t\t\t\n\tpublic var edges : Int;\n\tpublic var edgeUp : Int;\n\t\n\tpublic var size : Float;\n\tpublic var modifier : Int;\n\t\t\n\t/*\n\t * External Linking Edge data\n\t * \n\t *    *-128--*--64--*\n\t *    |      |      |\n\t *    1      |     32\n\t *    |      |      |\n\t *    *------*------*\n\t *    |      |      |\n\t *    2      |     16\n\t *    |      |      |\n\t *    *--4---*--8---*\n\t * \n\t */\n\t\n\tpublic function new(size : Float, originalVertMask : Array<Int> , tileID : Int, modifier : Int) {\n\t\tthis.modifier = modifier;\n\t\tthis.size = size;\n\t\tthis.originalVertMask = originalVertMask;\n\t\tGetScaledVerts();\n\t\tsuper(scaledVerts, new Vector2D());\n\t\tthis.tileWidth = size;\n\t\tthis.tileID = tileID;\n\t\tif (modifier&0x04>0) //Vert\n\t\t\tthis.tileID = (1 << 31) | this.tileID;\n\t\tif (modifier&0x02>0) //Horiz\n\t\t\tthis.tileID = (1 << 30) | this.tileID;\n\t\tif (modifier&0x01>0) //Diag\n\t\t\tthis.tileID = (1 << 29) | this.tileID;\n\t}\n\n\tpublic function GetScaledVerts() : Void {\t\t\n\t\tvar vertMask:Array<Int> = originalVertMask;\n\t\t\n\t\tfor (i in 0...modifier) {\n\t\t\tvertMask = rotateClockwise(vertMask);\n\t\t}\n\t\t\n\t\tunscaledVerts = new Array<Vector2D>();\n\n\t\tfor (i in 0...vertMask.length) {\n\t\t\tif (vertMask[i]==1) unscaledVerts.push(VERTS[i].clone());\n\t\t}\n\t\t\n\t\t// if (vertMask[0]==1) unscaledVerts.push(VERTS[0].clone());\n\t\t// if (vertMask[1]==1) unscaledVerts.push(VERTS[1].clone());\n\t\t// if (vertMask[2]==1) unscaledVerts.push(VERTS[2].clone());\n\t\t// if (vertMask[3]==1) unscaledVerts.push(VERTS[3].clone());\n\t\t// if (vertMask[4]==1) unscaledVerts.push(VERTS[4].clone());\n\t\t// if (vertMask[5]==1) unscaledVerts.push(VERTS[5].clone());\n\t\t// if (vertMask[6]==1) unscaledVerts.push(VERTS[6].clone());\n\t\t// if (vertMask[7]==1) unscaledVerts.push(VERTS[7].clone());\n\t\t\n\t\tvar numVerts:Int = unscaledVerts.length;\n\t\t//trace(getQualifiedClassName(this));\n\t\tfor (i in 0...numVerts) {\n\t\t//for (var i : Int = 0; i < numVerts; i++) {\n\t\t\t\n\t\t\tvar v0:Vector2D = unscaledVerts[i];\n\t\t\tvar v1:Vector2D = unscaledVerts[(i + 1) % numVerts];\n\t\t\t//trace(\"Checking \",v0,v1);\n\t\t\tvar n:Vector2D = v1.minus(v0).rightHandNormal().unit();\n\t\t\tfor  (segment in VERT_TO_SEG_DEF) {\n\t\t\t//for each (var segment : TileSegment in VERT_TO_SEG_DEF) {\n\t\t\t\tvar mask:Int = segment.CheckVertexPairAndApplyMask(v0, v1);\n\t\t\t\tif (mask>0) {\n\t\t\t\t\t//trace(v0,v1,n);\n\t\t\t\t\tedges |= mask;\n\t\t\t\t\tif ((n.y<0)||(n.x==-1&&n.y==0)) {\n\t\t\t\t\t\tedgeUp |= mask;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tedgeT = edges & SEG_7 > 0 && edges & SEG_8 > 0 ? EDGE_STATE_FULL : EDGE_STATE_INTERESTING;\n\t\tedgeR = edges & SEG_5 > 0 && edges & SEG_6 > 0 ? EDGE_STATE_FULL : EDGE_STATE_INTERESTING;\n\t\tedgeB = edges & SEG_3 > 0 && edges & SEG_4 > 0 ? EDGE_STATE_FULL : EDGE_STATE_INTERESTING;\n\t\tedgeL = edges & SEG_1 > 0 && edges & SEG_2 > 0 ? EDGE_STATE_FULL : EDGE_STATE_INTERESTING;\n\t\t\n\t\t//trace(\"finished=\",edges,edgeUp);\n\t\t//Scale them now...\n\t\tscaledVerts = new Array();\n\t\t//for each ( var v : Vector2D in unscaledVerts) {\n\t\tfor (v in unscaledVerts) {\n\t\t\tscaledVerts.push(v.mult(size));\n\t\t}\n\t}\n\t\n\tpublic function CheckVertexPair(v0:Vector2D,v1:Vector2D,c0:Vector2D,c1:Vector2D):Bool {\n\t\treturn ( ( v0.isEquals(c0) && v1.isEquals(c1) ) || ( v0.isEquals(c1) && v1.isEquals(c0) ) );\n\t}\n\t\n\t/*\n\n\t076\n\t185\n\t234\n\t\n\t*/\n\n\tpublic function rotateClockwise(verts:Array<Int>):Array<Int> {\n\t\tvar result:Array<Int> = [];\n\t\tresult[0] = verts[6];\n\t\tresult[1] = verts[7];\n\t\tresult[2] = verts[0];\n\n\t\tresult[3] = verts[1];\n\t\tresult[4] = verts[2];\n\t\t\n\t\tresult[5] = verts[3];\n\t\tresult[6] = verts[4];\n\n\t\tresult[7] = verts[5];\n\n\t\tresult[8] = verts[8];\t\t\n\n\t\treturn result;\n\t}\n\n\tpublic static function IsCollidable(data:Int) : Bool {\n\t\treturn true;\n\t}\n\t\n}","package worldEngine.tiles;\nimport worldEngine.WorldData;\nimport worldEngine.tiles.Tile;\n\t\t\t\n/**\n * ...\n * @author rje\n */\n\nclass TileFactory \n{\n\tpublic var tiles : Array<Tile>;\n\tpublic var tilesDict : Map<Int,Tile>;\n\n\tpublic var tileTypes:Map<String,Array<Int>>;\n\n\tpublic function new() {\n\t\ttiles = new Array<Tile>();\n\t\ttilesDict = new Map<Int,Tile>();\n\t\ttileTypes = new Map<String,Array<Int>>();\n\t\tInitalize();\n\t}\n\n\tpublic function Initalize():Void {\n\t\t\n\t\tvar idInc : Int = 0;\n\n\t\t// New Format\n\t\t/*\n\t\ttype 6 Rotate\n\t\t6\t\t\t\t                             110\n\t\t2684354566\t\t10100000000000000000000000000110\n\t\t3221225478\t\t11000000000000000000000000000110\n\t\t1610612742\t\t 1100000000000000000000000000110\n\n\t\tFlip\n\t\tRotate\n\t\t2147483654\t\t10000000000000000000000000000110\n\t\t3758096390\t\t11100000000000000000000000000110\n\t\t1073741830\t\t 1000000000000000000000000000110\n\t\t536870918\t\t  100000000000000000000000000110\n\t\t * \n\t\t */\n\n\t\ttileTypes = [\n\t\t\t\"empty\"  => [0,0,0,0,0,0,0,0,0],\n\t\t\t\"full\"   => [1,0,1,0,1,0,1,0,0],\n\t\t\t\"half45\" => [1,0,1,0,1,0,0,0,0],\n\t\t\t\"half\"   => [1,0,1,1,0,0,0,1,0],\n\t\t\t\"half22\" => [1,0,1,1,0,0,0,0,0],\n\t\t\t\"half66\" => [0,1,1,0,1,0,0,0,0],\n\t\t\t\"full22\" => [1,0,1,0,1,0,0,1,0],\n\t\t\t\"full66\" => [1,0,1,0,1,1,0,0,0]\n\t\t];\n\n\t\tfor (tileType in tileTypes) {\n\t\t\tvar modifierCount = idInc < 2 ? 1 : 4;\n\t\t\tfor (modifier in 0...modifierCount) {\n\t\t\t\ttiles.push( new Tile( 32,tileType,idInc++,modifier ) );\n\t\t\t}\n\t\t}\n\t\t// trace(tiles);\n\t}\n\n}","package worldEngine.tiles;\n\n/**\n * ...\n * @author rje\n */\n\nclass TileFeature\n{\n\n\tinline public static var COLLIDABLE:Int = \t1 << 0;\n\tinline public static var DRAWABLE:Int =\t\t1 << 1;\n\t\n\tinline public static var STYLE_OFFSET:Int = 16;\n\tinline public static var RANDOMDATA_OFFSET:Int = 24;\n\t\n\tpublic var tile:Tile;\n\tpublic var edgeData:Int;\n\tpublic var data:Int;\n\t\n\tpublic function new(tile:Tile) {\n\t\tthis.tile = tile;\n\t\tthis.data = DRAWABLE;\n\t\tSetFlagBool(COLLIDABLE, tile.vertices.length > 0);\n\t}\n\t\n\tinline public function HasFlagBool(flag:Int):Bool {\n\t\treturn (data & flag > 0);\n\t}\n\t\n\tinline public function SetFlagBool(flag:Int,state:Bool):Void {\n\t\tif (state) {\n\t\t\tdata |= flag;\n\t\t} else {\n\t\t\tdata &= ~flag;\n\t\t}\n\t}\n\t\n\tinline public function SetRandomData(random:Int):Void {\n\t\tdata |= random << RANDOMDATA_OFFSET;\n\t}\n\t\n\tinline public function GetRandomData():Int {\n\t\treturn (data >> RANDOMDATA_OFFSET) & 0xFF;\n\t}\n\n\tinline public function SetStyleData(style:Int):Void {\n\t\tdata |= style << STYLE_OFFSET;\n\t}\n\n\tinline public function GetStyleData():Int {\n\t\treturn (data >> STYLE_OFFSET) & 0xFF;\n\t}\t\n\n\tpublic function SetEdgeData(left:TileFeature, up:TileFeature, right:TileFeature, down:TileFeature ):Void {\n\t\tif (!HasFlagBool(COLLIDABLE))\n\t\t\treturn;\n\t\t\t\n\t\tif (left!=null&&left.HasFlagBool(COLLIDABLE)) {\n\t\t\tif ((tile.edges&Tile.SEG_1>0)&&(left.tile.edges&Tile.SEG_6>0)) edgeData |= Tile.SEG_1;\n\t\t\tif ((tile.edges&Tile.SEG_2>0)&&(left.tile.edges&Tile.SEG_5>0)) edgeData |= Tile.SEG_2;\n\t\t}\n\t\tif (right!=null&&right.HasFlagBool(COLLIDABLE)) {\n\t\t\tif ((tile.edges&Tile.SEG_6>0)&&(right.tile.edges&Tile.SEG_1>0)) edgeData |= Tile.SEG_6;\n\t\t\tif ((tile.edges&Tile.SEG_5>0)&&(right.tile.edges&Tile.SEG_2>0)) edgeData |= Tile.SEG_5;\n\t\t}\n\t\tif (up!=null&&up.HasFlagBool(COLLIDABLE)) {\n\t\t\tif ((tile.edges&Tile.SEG_8>0)&&(up.tile.edges&Tile.SEG_3>0)) edgeData |= Tile.SEG_8;\n\t\t\tif ((tile.edges&Tile.SEG_7>0)&&(up.tile.edges&Tile.SEG_4>0)) edgeData |= Tile.SEG_7;\n\t\t}\n\t\tif (down!=null&&down.HasFlagBool(COLLIDABLE)) {\n\t\t\tif ((tile.edges&Tile.SEG_3>0)&&(down.tile.edges&Tile.SEG_8>0)) edgeData |= Tile.SEG_3;\n\t\t\tif ((tile.edges&Tile.SEG_4>0)&&(down.tile.edges&Tile.SEG_7>0)) edgeData |= Tile.SEG_4;\n\t\t}\t\t\t\n\t\t\n\t}\n\t\n}","/*\n * Copyright (C)2005-2012 Haxe Foundation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n\tThis class defines mathematical functions and constants.\n**/\n#if cpp @:include(\"hxMath\") #end\nextern class Math\n{\n\t/**\n\t\tRepresents the ratio of the circumference of a circle to its diameter, \n\t\tspecified by the constant, . `PI` is approximately 3.141592653589793.\n\t**/\n\tstatic var PI(default,null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes negative infinity.\n\n\t\tFor example, this is the result of -1.0 / 0.0.\n\n\t\tOperations with NEGATIVE_INFINITY as an operand may result in\n\t\tNEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. \n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\t**/\n\tstatic var NEGATIVE_INFINITY(default, null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes negative infinity.\n\n\t\tFor example, this is the result of 1.0 / 0.0.\n\n\t\tOperations with POSITIVE_INFINITY as an operand may result in\n\t\tNEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. \n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\t**/\n\tstatic var POSITIVE_INFINITY(default,null) : Float;\n\n\t/**\n\t\tA special Float constant which denotes an invalid number.\n\n\t\tNaN stands for \"Not a Number\". It occurs when a mathematically incorrect\n\t\toperation is executed, such as taking the square root of a negative\n\t\tnumber: Math.sqrt(-1).\n\n\t\tAll further operations with NaN as an operand will result in NaN.\n\n\t\tIf this constant is converted to an Int, e.g. through Std.int(), the\n\t\tresult is unspecified.\n\n\t\tIn order to test if a value is NaN, you should use Math.isNaN() function.\n\n\t\t@php In PHP versions prior to 5.3.1 VC 9 there may be unexpected\n\t\tresults when performing arithmetic operations with NaN on Windows, \n\t\tsee [https://bugs.php.net/bug.php?id=42143]\n\t**/\n\tstatic var NaN(default, null) : Float;\n\n\t/**\n\t\tReturns the absolute value of `v`.\n\n\t\tIf `v` is positive or 0, the result is unchanged. Otherwise the result \n\t\tis -`v`.\n\t\t\n\t\tIf `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is \n\t\tPOSITIVE_INFINITY.\n\t\t\n\t\tIf `v` is NaN, the result is NaN.\n\t**/\n\tstatic function abs(v:Float):Float;\n\n\t/**\n\t\tReturns the smaller of values `a` and `b`.\n\n\t\tIf `a` or `b` are NaN, the result is NaN.\n\t\tIf `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.\n\t\tIf `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t**/\n\tstatic function min(a:Float, b:Float):Float;\n\n\t/**\n\t\tReturns the greater of values `a` and `b`.\n\n\t\tIf `a` or `b` are NaN, the result is NaN.\n\t\tIf `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.\n\t**/\n\tstatic function max(a:Float, b:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric sine of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function sin(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric cosine of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function cos(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric tangent of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function tan(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc of the specified angle `v`, in radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function asin(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc cosine of the specified angle `v`, \n\t\tin radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function acos(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc tangent of the specified angle `v`, \n\t\tin radians.\n\t\t\n\t\tIf `v` is NaN or infinite, the result is NaN.\n\t**/\n\tstatic function atan(v:Float):Float;\n\n\t/**\n\t\tReturns the trigonometric arc tangent whose tangent is the quotient of \n\t\ttwo specified numbers, in radians.\n\t\t\n\t\tIf parameter `x` or `y`  is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is NaN.\n\t**/\n\tstatic function atan2(y:Float, x:Float):Float;\n\n\t/**\n\t\tReturns Euler's number, raised to the power of `v`.\n\t\t\n\t\texp(1.0) is approximately 2.718281828459.\n\t\t\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is NEGATIVE_INFINITY, the result is 0.0.\n\t\tIf `v` is NaN, the result is NaN.\n\t**/\n\tstatic function exp(v:Float):Float;\n\n\t/**\n\t\tReturns the natural logarithm of `v`.\n\t\t\n\t\tThis is the mathematical inverse operation of exp, \n\t\ti.e. `log(exp(v)) == v` always holds.\n\t\t\n\t\tIf `v` is negative (including NEGATIVE_INFINITY) or NaN, the result \n\t\tis NaN.\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is 0.0, the result is NEGATIVE_INFINITY.\n\t**/\n\tstatic function log(v:Float):Float;\n\n\t/**\n\t\tReturns a specified base `v` raised to the specified power `exp`.\n\t**/\n\tstatic function pow(v:Float, exp:Float):Float;\n\n\t/**\n\t\tReturns the square root of `v`.\n\t\t\n\t\tIf `v` is negative (including NEGATIVE_INFINITY) or NaN, the result \n\t\tis NaN.\n\t\tIf `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.\n\t\tIf `v` is 0.0, the result is 0.0.\n\t**/\n\tstatic function sqrt(v:Float):Float;\n\n\t/**\n\t\tRounds `v` to the nearest integer value.\n\t\t\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function round(v:Float):Int;\n\n\t/**\n\t\tReturns the largest integer value that is not greater than `v`.\n\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function floor(v:Float):Int;\n\n\t/**\n\t\tReturns the smallest integer value that is not less than `v`.\n\n\t\tIf `v` is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY \n\t\tor POSITIVE_INFINITY, the result is unspecified.\n\t**/\n\tstatic function ceil(v:Float):Int;\n\n\t/**\n\t\tReturns a pseudo-random number which is greater than or equal to 0.0, \n\t\tand less than 1.0.\n\t**/\n\tstatic function random() : Float;\n\n\t#if ((flash9 && !as3) || cpp)\n\t/**\n\t\tReturns the largest integer value that is not greater than `v`, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function ffloor( v : Float ) : Float;\n\n\t/**\n\t\tReturns the smallest integer value that is not less than `v`, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function fceil( v : Float ) : Float;\n\n\t/**\n\t\tRounds `v` to the nearest integer value, as a Float.\n\n\t\tIf `v` is is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, \n\t\tthe result is unspecified.\n\t**/\n\tstatic function fround( v : Float ) : Float;\n\n\t#else\n\n\tstatic inline function ffloor( v : Float ) : Float {\n\t\treturn floor(v);\n\t}\n\n\tstatic inline function fceil( v : Float ) : Float {\n\t\treturn ceil(v);\n\t}\n\n\tstatic inline function fround( v : Float ) : Float {\n\t\treturn round(v);\n\t}\n\n\t#end\n\n\n\t/**\n\t\tTells if `f` is a finite number.\n\n\t\tIf `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result \n\t\tis false, otherwise the result is true.\n\t**/\n\tstatic function isFinite( f : Float ) : Bool;\n\n\t/**\n\t\tTells if `f` is not a valid number.\n\n\t\tIf `f` is NaN, the result is true, otherwise the result is false. \n\t\tIn particular, both POSITIVE_INFINITY and NEGATIVE_INFINITY are\n\t\tnot considered NaN.\n\t**/\n\tstatic function isNaN( f : Float ) : Bool;\n\n\tprivate static function __init__() : Void untyped {\n\t#if flash9\n\t\tNaN = __global__[\"Number\"].NaN;\n\t\tNEGATIVE_INFINITY = __global__[\"Number\"].NEGATIVE_INFINITY;\n\t\tPOSITIVE_INFINITY = __global__[\"Number\"].POSITIVE_INFINITY;\n\t#else\n\t\t#if !js // genjs.ml will insert this only if necessary.\n\t\t\tMath.__name__ = [\"Math\"];\n\t\t#end\n\t\tMath.NaN = Number[\"NaN\"];\n\t\tMath.NEGATIVE_INFINITY = Number[\"NEGATIVE_INFINITY\"];\n\t\tMath.POSITIVE_INFINITY = Number[\"POSITIVE_INFINITY\"];\n\t#end\n\t#if js\n\t\t__feature__(\"Type.resolveClass\",$hxClasses['Math'] = Math);\n\t#end\n\t\tMath.isFinite = function(i) {\n\t\t\treturn\n\t\t\t#if flash9\n\t\t\t__global__[\"isFinite\"](i);\n\t\t\t#elseif flash\n\t\t\t_global[\"isFinite\"](i);\n\t\t\t#elseif js\n\t\t\t__js__(\"isFinite\")(i);\n\t\t\t#else\n\t\t\tfalse;\n\t\t\t#end\n\t\t};\n\t\tMath.isNaN = function(i) {\n\t\t\treturn\n\t\t\t#if flash9\n\t\t\t__global__[\"isNaN\"](i);\n\t\t\t#elseif flash\n\t\t\t_global[\"isNaN\"](i);\n\t\t\t#elseif js\n\t\t\t__js__(\"isNaN\")(i);\n\t\t\t#else\n\t\t\tfalse;\n\t\t\t#end\n\t\t};\n\t}\n\n}\n\n\n","package engine.ai.steering;\n\n/**\n * ...\n * @author rje\n */\n\nclass SteeringSettings \n{\n\n\t// Arrive speed settings\n\tpublic static inline var speedTweaker:Float\t=\t.3;\n\tpublic static inline var arriveFast:Float\t\t=\t1;\n\tpublic static inline var arriveNormal:Float\t=\t3;\n\tpublic static inline var arriveSlow:Float\t\t=\t5;\n\t\n\t// Wander Settings\n\tpublic static inline var wanderJitter:Float\t=\t300; // ( per second )\n\tpublic static inline var wanderDistance:Float\t=\t25;\n\tpublic static inline var wanderRadius:Float\t=\t15;\n\t\n\t// Probabilities - Used to determine the chance that the Prioritized Dithering ( fastest ) calculation method will run a behavior\n\tpublic static inline var separationProbability:Float\t\t\t=\t0.2;\n\tpublic static inline var cohesionProbability:Float\t\t\t=\t0.6;\n\tpublic static inline var alignmentProbability:Float\t\t\t=\t0.3;\n\t\n\tpublic static inline var dodgeProbability:Float\t\t\t=\t0.6;\n\t\n\tpublic static inline var seekProbability:Float\t\t\t\t=\t0.8;\n\tpublic static inline var fleeProbability:Float\t\t\t\t=\t0.6;\n\tpublic static inline var pursuitProbability:Float\t\t\t\t=\t0.8;\n\tpublic static inline var evadeProbability:Float\t\t\t\t=\t1;\n\tpublic static inline var offsetPursuitProbability:Float\t\t=\t0.8;\n\tpublic static inline var arriveProbability:Float\t\t\t\t=\t0.5;\n\t\n\tpublic static inline var obstacleAvoidanceProbability:Float\t=\t0.5;\n\tpublic static inline var wallAvoidanceProbability:Float\t\t=\t0.5;\n\tpublic static inline var hideProbability:Float\t\t\t\t=\t0.8;\n\tpublic static inline var followPathProbability:Float\t\t\t=\t0.7;\n\t\n\tpublic static inline var interposeProbability:Float\t\t\t=\t0.8;\t\t\n\tpublic static inline var wanderProbability:Float\t\t\t\t=\t0.8;\n\t\n\t// Weights - Scalar to effect the weights of individual behaviors\n\tpublic static inline var  separationWeight:Float\t\t\t=\t1;\n\tpublic static inline var  alignmentWeight:Float\t\t\t=\t3;\n\tpublic static inline var  cohesionWeight:Float\t\t\t\t=\t2;\n\t\n\tpublic static inline var  dodgeWeight:Float\t\t\t\t=\t1;\t\t\n\t\n\tpublic static inline var seekWeight:Float\t\t\t\t\t=\t1;\n\tpublic static inline var fleeWeight:Float\t\t\t\t\t=\t1;\n\tpublic static inline var pursuitWeight:Float\t\t\t\t=\t1;\n\tpublic static inline var evadeWeight:Float\t\t\t\t=\t0.1;\n\tpublic static inline var offsetPursuitWeight:Float\t\t=\t1;\n\tpublic static inline var arriveWeight:Float\t\t\t\t=\t1;\n\t\n\tpublic static inline var obstacleAvoidanceWeight:Float\t=\t10;\n\tpublic static inline var wallAvoidanceWeight:Float\t\t=\t10;\n\tpublic static inline var hideWeight:Float\t\t\t\t\t=\t1;\n\tpublic static inline var followPathWeight:Float\t\t\t=\t0.5;\n\t\n\tpublic static inline var interposeWeight:Float\t\t\t=\t1;\t\t\n\tpublic static inline var wanderWeight:Float\t\t\t\t=\t1;\n\t\n\t// Priorities - Order in which behaviors are calculated ( lower Floats get calculated first )\n\tpublic static inline var wallAvoidancePriority:Float\t\t=\t10;\n\tpublic static inline var obstacleAvoidancePriority:Float\t=\t20;\n\tpublic static inline var evadePriority:Float\t\t\t\t=\t30;\n\tpublic static inline var hidePriority:Float\t\t\t\t=\t35;\n\t\n\tpublic static inline var seperationPriority:Float\t\t\t=\t40;\n\tpublic static inline var alignmentPriority:Float\t\t\t=\t50;\n\tpublic static inline var cohesionPriority:Float\t\t\t=\t60;\n\t\n\tpublic static inline var dodgePriority:Float\t\t\t\t=\t65;\n\t\n\tpublic static inline var seekPriority:Float\t\t\t\t=\t70;\n\tpublic static inline var fleePriority:Float\t\t\t\t=\t80;\n\tpublic static inline var arrivePriority:Float\t\t\t\t=\t90;\n\tpublic static inline var pursuitPriority:Float\t\t\t=\t100;\n\tpublic static inline var offsetPursuitPriority:Float\t\t=\t110;\n\tpublic static inline var interposePriority:Float\t\t\t=\t120;\n\tpublic static inline var followPathPriority:Float\t\t\t=\t130;\n\tpublic static inline var wanderPriority:Float\t\t\t\t=\t140;\n\t\n}","package physics;\n\n/**\n * ...\n * @author rje\n */\n\nclass Constants \n{\n\n\tpublic static inline var FMAX : Float = 1e99;\n\tpublic static inline var SLEEP_BIAS : Float = 0.99332805041467;\n\tpublic static inline var SLEEP_EPSILON : Float = 0.0009;\n\tpublic static inline var WAKE_MOTION : Float = 10;\n\t\n}","package physics.geometry;\n\n/**\n * ...\n * @author rje\n */\n\nclass Shapes \n{\n\tpublic static inline var AXIS_ALIGNED_BOX_SHAPE : Int = 0;\n\tpublic static inline var CIRCLE_SHAPE : Int = 1;\n\tpublic static inline var SEGMENT_SHAPE : Int = 2;\n\tpublic static inline var POLYGON_SHAPE : Int = 4;\n\tpublic static inline var POLYGON_POLYGON : Int = POLYGON_SHAPE | POLYGON_SHAPE;\n\tpublic static inline var CIRCLE_POLYGON : Int = CIRCLE_SHAPE | POLYGON_SHAPE;\n\tpublic static inline var CIRCLE_CIRCLE : Int = CIRCLE_SHAPE | CIRCLE_SHAPE;\n\tpublic static inline var CIRCLE_SEGMENT : Int = CIRCLE_SHAPE | SEGMENT_SHAPE;\n\tpublic static inline var SEGMENT_POLYGON : Int = SEGMENT_SHAPE | POLYGON_SHAPE;\n}","package utils;\n\n/**\n * ...\n * @author rje\n */\n\nclass Limits \n{\n\t/**\n\t * Min value, signed byte.\n\t */\n\tinline public static var INT8_MIN =-0x80;\n\t\n\t/**\n\t * Max value, signed byte.\n\t */\n\tinline public static var INT8_MAX = 0x7F;\n\t\n\t/**\n\t * Max value, unsigned byte.\n\t */\n\tinline public static var UINT8_MAX = 0xFF;\n\t\n\t/**\n\t * Min value, signed short.\n\t */\n\tinline public static var INT16_MIN =-0x8000;\n\t\n\t/**\n\t * Max value, signed short.\n\t */\n\tinline public static var INT16_MAX = 0x7FFF;\n\t\n\t/**\n\t * Max value, unsigned short.\n\t */\n\tinline public static var UINT16_MAX = 0xFFFF;\n\t\n\t/**\n\t * Min value, signed integer.<br/>\n\t * Equals 0x40000000 when targeting neko, otherwise 0x80000000.\n\t */\n\tinline public static var INT32_MIN =\n\t#if neko\n\t0x40000000;\n\t#else\n\t0x80000000;\n\t#end\n\t\n\t/**\n\t * Max value, signed integer.<br/>\n\t * Equals 0x3fffffff when targeting neko, otherwise 0x7fffffff.\n\t */\n\tinline public static var INT32_MAX =\n\t#if neko\n\t0x3FFFFFFF;\n\t#else\n\t0x7fffffff;\n\t#end\n\t\n\t/**\n\t * Max value, unsigned integer.<br/>\n\t * Equals 0x7fffffff when targeting neko, otherwise 0xffffffff.\n\t * \n\t */\n\tinline public static var UINT32_MAX =\n\t#if neko\n\t0x7fffffff;\n\t#else\n\t0xffffffff;\n\t#end\n\t\n\t/**\n\t * Number of bits using for representing integers.<br/>\n\t * Equals 31 when targeting neko, otherwise 32.\n\t */\n\tinline public static var INT_BITS =\n\t#if neko\n\t31;\n\t#else\n\t32;\n\t#end\n\t\n\t/**\n\t * The largest representable number (single-precision IEEE-754).\n\t */\n\tinline public static var FLOAT_MAX = 3.40282346638528e+38;\n\t\n\t/**\n\t * The smallest representable number (single-precision IEEE-754).\n\t */\n\tinline public static var FLOAT_MIN = -3.40282346638528e+38;\n\t\n\t/**\n\t * The smallest representable number (double-precision IEEE-754).\n\t */\n\tinline public static var DOUBLE_MAX = 1.79769313486231e+308;\n\t\n\t/**\n\t * The largest representable number (double-precision IEEE-754).\n\t */\n\tinline public static var DOUBLE_MIN = -1.79769313486231e+308; \n}\n"],
"names":[],
"mappings":"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"
}